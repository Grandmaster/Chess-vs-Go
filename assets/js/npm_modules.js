(function () {
  function r(e, n, t) {
    function o(i, f) {
      if (!n[i]) {
        if (!e[i]) {
          var c = "function" == typeof require && require;
          if (!f && c) return c(i, !0);
          if (u) return u(i, !0);
          var a = new Error("Cannot find module '" + i + "'");
          throw ((a.code = "MODULE_NOT_FOUND"), a);
        }
        var p = (n[i] = { exports: {} });
        e[i][0].call(
          p.exports,
          function (r) {
            var n = e[i][1][r];
            return o(n || r);
          },
          p,
          p.exports,
          r,
          e,
          n,
          t
        );
      }
      return n[i].exports;
    }
    for (
      var u = "function" == typeof require && require, i = 0;
      i < t.length;
      i++
    )
      o(t[i]);
    return o;
  }
  return r;
})()(
  {
    1: [
      function (require, module, exports) {
        require("lodash");
        require("immutable");
        const godash = require("godash").default;
        if (!window.godash) {
          window.godash = godash;
        }
      },
      { godash: 2, immutable: 3, lodash: 4 },
    ],
    2: [
      function (require, module, exports) {
        !(function (t, n) {
          "object" == typeof exports && "object" == typeof module
            ? (module.exports = n())
            : "function" == typeof define && define.amd
            ? define([], n)
            : "object" == typeof exports
            ? (exports.godash = n())
            : (t.godash = n());
        })(window, function () {
          return (function (t) {
            var n = {};
            function r(e) {
              if (n[e]) return n[e].exports;
              var i = (n[e] = { i: e, l: !1, exports: {} });
              return (
                t[e].call(i.exports, i, i.exports, r), (i.l = !0), i.exports
              );
            }
            return (
              (r.m = t),
              (r.c = n),
              (r.d = function (t, n, e) {
                r.o(t, n) ||
                  Object.defineProperty(t, n, { enumerable: !0, get: e });
              }),
              (r.r = function (t) {
                "undefined" != typeof Symbol &&
                  Symbol.toStringTag &&
                  Object.defineProperty(t, Symbol.toStringTag, {
                    value: "Module",
                  }),
                  Object.defineProperty(t, "__esModule", { value: !0 });
              }),
              (r.t = function (t, n) {
                if ((1 & n && (t = r(t)), 8 & n)) return t;
                if (4 & n && "object" == typeof t && t && t.__esModule)
                  return t;
                var e = Object.create(null);
                if (
                  (r.r(e),
                  Object.defineProperty(e, "default", {
                    enumerable: !0,
                    value: t,
                  }),
                  2 & n && "string" != typeof t)
                )
                  for (var i in t)
                    r.d(
                      e,
                      i,
                      function (n) {
                        return t[n];
                      }.bind(null, i)
                    );
                return e;
              }),
              (r.n = function (t) {
                var n =
                  t && t.__esModule
                    ? function () {
                        return t.default;
                      }
                    : function () {
                        return t;
                      };
                return r.d(n, "a", n), n;
              }),
              (r.o = function (t, n) {
                return Object.prototype.hasOwnProperty.call(t, n);
              }),
              (r.p = ""),
              r((r.s = 2))
            );
          })([
            function (t, n, r) {
              (function (t, e) {
                var i;
                /**
                 * @license
                 * Lodash <https://lodash.com/>
                 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
                 * Released under MIT license <https://lodash.com/license>
                 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
                 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
                 */ (function () {
                  var u,
                    o = 200,
                    a =
                      "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.",
                    f = "Expected a function",
                    c = "__lodash_hash_undefined__",
                    s = 500,
                    h = "__lodash_placeholder__",
                    l = 1,
                    p = 2,
                    _ = 4,
                    v = 1,
                    y = 2,
                    d = 1,
                    g = 2,
                    w = 4,
                    m = 8,
                    b = 16,
                    S = 32,
                    I = 64,
                    z = 128,
                    x = 256,
                    O = 512,
                    j = 30,
                    A = "...",
                    E = 800,
                    k = 16,
                    M = 1,
                    D = 2,
                    q = 1 / 0,
                    R = 9007199254740991,
                    L = 17976931348623157e292,
                    T = NaN,
                    U = 4294967295,
                    C = U - 1,
                    W = U >>> 1,
                    B = [
                      ["ary", z],
                      ["bind", d],
                      ["bindKey", g],
                      ["curry", m],
                      ["curryRight", b],
                      ["flip", O],
                      ["partial", S],
                      ["partialRight", I],
                      ["rearg", x],
                    ],
                    K = "[object Arguments]",
                    P = "[object Array]",
                    N = "[object AsyncFunction]",
                    $ = "[object Boolean]",
                    F = "[object Date]",
                    J = "[object DOMException]",
                    H = "[object Error]",
                    V = "[object Function]",
                    Z = "[object GeneratorFunction]",
                    G = "[object Map]",
                    Y = "[object Number]",
                    X = "[object Null]",
                    Q = "[object Object]",
                    tt = "[object Proxy]",
                    nt = "[object RegExp]",
                    rt = "[object Set]",
                    et = "[object String]",
                    it = "[object Symbol]",
                    ut = "[object Undefined]",
                    ot = "[object WeakMap]",
                    at = "[object WeakSet]",
                    ft = "[object ArrayBuffer]",
                    ct = "[object DataView]",
                    st = "[object Float32Array]",
                    ht = "[object Float64Array]",
                    lt = "[object Int8Array]",
                    pt = "[object Int16Array]",
                    _t = "[object Int32Array]",
                    vt = "[object Uint8Array]",
                    yt = "[object Uint8ClampedArray]",
                    dt = "[object Uint16Array]",
                    gt = "[object Uint32Array]",
                    wt = /\b__p \+= '';/g,
                    mt = /\b(__p \+=) '' \+/g,
                    bt = /(__e\(.*?\)|\b__t\)) \+\n'';/g,
                    St = /&(?:amp|lt|gt|quot|#39);/g,
                    It = /[&<>"']/g,
                    zt = RegExp(St.source),
                    xt = RegExp(It.source),
                    Ot = /<%-([\s\S]+?)%>/g,
                    jt = /<%([\s\S]+?)%>/g,
                    At = /<%=([\s\S]+?)%>/g,
                    Et = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
                    kt = /^\w*$/,
                    Mt = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
                    Dt = /[\\^$.*+?()[\]{}|]/g,
                    qt = RegExp(Dt.source),
                    Rt = /^\s+|\s+$/g,
                    Lt = /^\s+/,
                    Tt = /\s+$/,
                    Ut = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
                    Ct = /\{\n\/\* \[wrapped with (.+)\] \*/,
                    Wt = /,? & /,
                    Bt = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g,
                    Kt = /\\(\\)?/g,
                    Pt = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,
                    Nt = /\w*$/,
                    $t = /^[-+]0x[0-9a-f]+$/i,
                    Ft = /^0b[01]+$/i,
                    Jt = /^\[object .+?Constructor\]$/,
                    Ht = /^0o[0-7]+$/i,
                    Vt = /^(?:0|[1-9]\d*)$/,
                    Zt = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g,
                    Gt = /($^)/,
                    Yt = /['\n\r\u2028\u2029\\]/g,
                    Xt = "\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff",
                    Qt =
                      "\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",
                    tn = "[\\ud800-\\udfff]",
                    nn = "[" + Qt + "]",
                    rn = "[" + Xt + "]",
                    en = "\\d+",
                    un = "[\\u2700-\\u27bf]",
                    on = "[a-z\\xdf-\\xf6\\xf8-\\xff]",
                    an =
                      "[^\\ud800-\\udfff" +
                      Qt +
                      en +
                      "\\u2700-\\u27bfa-z\\xdf-\\xf6\\xf8-\\xffA-Z\\xc0-\\xd6\\xd8-\\xde]",
                    fn = "\\ud83c[\\udffb-\\udfff]",
                    cn = "[^\\ud800-\\udfff]",
                    sn = "(?:\\ud83c[\\udde6-\\uddff]){2}",
                    hn = "[\\ud800-\\udbff][\\udc00-\\udfff]",
                    ln = "[A-Z\\xc0-\\xd6\\xd8-\\xde]",
                    pn = "(?:" + on + "|" + an + ")",
                    _n = "(?:" + ln + "|" + an + ")",
                    vn = "(?:" + rn + "|" + fn + ")" + "?",
                    yn =
                      "[\\ufe0e\\ufe0f]?" +
                      vn +
                      ("(?:\\u200d(?:" +
                        [cn, sn, hn].join("|") +
                        ")[\\ufe0e\\ufe0f]?" +
                        vn +
                        ")*"),
                    dn = "(?:" + [un, sn, hn].join("|") + ")" + yn,
                    gn =
                      "(?:" + [cn + rn + "?", rn, sn, hn, tn].join("|") + ")",
                    wn = RegExp("['’]", "g"),
                    mn = RegExp(rn, "g"),
                    bn = RegExp(fn + "(?=" + fn + ")|" + gn + yn, "g"),
                    Sn = RegExp(
                      [
                        ln +
                          "?" +
                          on +
                          "+(?:['’](?:d|ll|m|re|s|t|ve))?(?=" +
                          [nn, ln, "$"].join("|") +
                          ")",
                        _n +
                          "+(?:['’](?:D|LL|M|RE|S|T|VE))?(?=" +
                          [nn, ln + pn, "$"].join("|") +
                          ")",
                        ln + "?" + pn + "+(?:['’](?:d|ll|m|re|s|t|ve))?",
                        ln + "+(?:['’](?:D|LL|M|RE|S|T|VE))?",
                        "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])",
                        "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])",
                        en,
                        dn,
                      ].join("|"),
                      "g"
                    ),
                    In = RegExp(
                      "[\\u200d\\ud800-\\udfff" + Xt + "\\ufe0e\\ufe0f]"
                    ),
                    zn = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/,
                    xn = [
                      "Array",
                      "Buffer",
                      "DataView",
                      "Date",
                      "Error",
                      "Float32Array",
                      "Float64Array",
                      "Function",
                      "Int8Array",
                      "Int16Array",
                      "Int32Array",
                      "Map",
                      "Math",
                      "Object",
                      "Promise",
                      "RegExp",
                      "Set",
                      "String",
                      "Symbol",
                      "TypeError",
                      "Uint8Array",
                      "Uint8ClampedArray",
                      "Uint16Array",
                      "Uint32Array",
                      "WeakMap",
                      "_",
                      "clearTimeout",
                      "isFinite",
                      "parseInt",
                      "setTimeout",
                    ],
                    On = -1,
                    jn = {};
                  (jn[st] = jn[ht] = jn[lt] = jn[pt] = jn[_t] = jn[vt] = jn[
                    yt
                  ] = jn[dt] = jn[gt] = !0),
                    (jn[K] = jn[P] = jn[ft] = jn[$] = jn[ct] = jn[F] = jn[
                      H
                    ] = jn[V] = jn[G] = jn[Y] = jn[Q] = jn[nt] = jn[rt] = jn[
                      et
                    ] = jn[ot] = !1);
                  var An = {};
                  (An[K] = An[P] = An[ft] = An[ct] = An[$] = An[F] = An[
                    st
                  ] = An[ht] = An[lt] = An[pt] = An[_t] = An[G] = An[Y] = An[
                    Q
                  ] = An[nt] = An[rt] = An[et] = An[it] = An[vt] = An[yt] = An[
                    dt
                  ] = An[gt] = !0),
                    (An[H] = An[V] = An[ot] = !1);
                  var En = {
                      "\\": "\\",
                      "'": "'",
                      "\n": "n",
                      "\r": "r",
                      "\u2028": "u2028",
                      "\u2029": "u2029",
                    },
                    kn = parseFloat,
                    Mn = parseInt,
                    Dn = "object" == typeof t && t && t.Object === Object && t,
                    qn =
                      "object" == typeof self &&
                      self &&
                      self.Object === Object &&
                      self,
                    Rn = Dn || qn || Function("return this")(),
                    Ln = n && !n.nodeType && n,
                    Tn = Ln && "object" == typeof e && e && !e.nodeType && e,
                    Un = Tn && Tn.exports === Ln,
                    Cn = Un && Dn.process,
                    Wn = (function () {
                      try {
                        var t = Tn && Tn.require && Tn.require("util").types;
                        return t || (Cn && Cn.binding && Cn.binding("util"));
                      } catch (t) {}
                    })(),
                    Bn = Wn && Wn.isArrayBuffer,
                    Kn = Wn && Wn.isDate,
                    Pn = Wn && Wn.isMap,
                    Nn = Wn && Wn.isRegExp,
                    $n = Wn && Wn.isSet,
                    Fn = Wn && Wn.isTypedArray;
                  function Jn(t, n, r) {
                    switch (r.length) {
                      case 0:
                        return t.call(n);
                      case 1:
                        return t.call(n, r[0]);
                      case 2:
                        return t.call(n, r[0], r[1]);
                      case 3:
                        return t.call(n, r[0], r[1], r[2]);
                    }
                    return t.apply(n, r);
                  }
                  function Hn(t, n, r, e) {
                    for (var i = -1, u = null == t ? 0 : t.length; ++i < u; ) {
                      var o = t[i];
                      n(e, o, r(o), t);
                    }
                    return e;
                  }
                  function Vn(t, n) {
                    for (
                      var r = -1, e = null == t ? 0 : t.length;
                      ++r < e && !1 !== n(t[r], r, t);

                    );
                    return t;
                  }
                  function Zn(t, n) {
                    for (
                      var r = null == t ? 0 : t.length;
                      r-- && !1 !== n(t[r], r, t);

                    );
                    return t;
                  }
                  function Gn(t, n) {
                    for (var r = -1, e = null == t ? 0 : t.length; ++r < e; )
                      if (!n(t[r], r, t)) return !1;
                    return !0;
                  }
                  function Yn(t, n) {
                    for (
                      var r = -1, e = null == t ? 0 : t.length, i = 0, u = [];
                      ++r < e;

                    ) {
                      var o = t[r];
                      n(o, r, t) && (u[i++] = o);
                    }
                    return u;
                  }
                  function Xn(t, n) {
                    return !!(null == t ? 0 : t.length) && fr(t, n, 0) > -1;
                  }
                  function Qn(t, n, r) {
                    for (var e = -1, i = null == t ? 0 : t.length; ++e < i; )
                      if (r(n, t[e])) return !0;
                    return !1;
                  }
                  function tr(t, n) {
                    for (
                      var r = -1, e = null == t ? 0 : t.length, i = Array(e);
                      ++r < e;

                    )
                      i[r] = n(t[r], r, t);
                    return i;
                  }
                  function nr(t, n) {
                    for (var r = -1, e = n.length, i = t.length; ++r < e; )
                      t[i + r] = n[r];
                    return t;
                  }
                  function rr(t, n, r, e) {
                    var i = -1,
                      u = null == t ? 0 : t.length;
                    for (e && u && (r = t[++i]); ++i < u; )
                      r = n(r, t[i], i, t);
                    return r;
                  }
                  function er(t, n, r, e) {
                    var i = null == t ? 0 : t.length;
                    for (e && i && (r = t[--i]); i--; ) r = n(r, t[i], i, t);
                    return r;
                  }
                  function ir(t, n) {
                    for (var r = -1, e = null == t ? 0 : t.length; ++r < e; )
                      if (n(t[r], r, t)) return !0;
                    return !1;
                  }
                  var ur = lr("length");
                  function or(t, n, r) {
                    var e;
                    return (
                      r(t, function (t, r, i) {
                        if (n(t, r, i)) return (e = r), !1;
                      }),
                      e
                    );
                  }
                  function ar(t, n, r, e) {
                    for (
                      var i = t.length, u = r + (e ? 1 : -1);
                      e ? u-- : ++u < i;

                    )
                      if (n(t[u], u, t)) return u;
                    return -1;
                  }
                  function fr(t, n, r) {
                    return n == n
                      ? (function (t, n, r) {
                          var e = r - 1,
                            i = t.length;
                          for (; ++e < i; ) if (t[e] === n) return e;
                          return -1;
                        })(t, n, r)
                      : ar(t, sr, r);
                  }
                  function cr(t, n, r, e) {
                    for (var i = r - 1, u = t.length; ++i < u; )
                      if (e(t[i], n)) return i;
                    return -1;
                  }
                  function sr(t) {
                    return t != t;
                  }
                  function hr(t, n) {
                    var r = null == t ? 0 : t.length;
                    return r ? vr(t, n) / r : T;
                  }
                  function lr(t) {
                    return function (n) {
                      return null == n ? u : n[t];
                    };
                  }
                  function pr(t) {
                    return function (n) {
                      return null == t ? u : t[n];
                    };
                  }
                  function _r(t, n, r, e, i) {
                    return (
                      i(t, function (t, i, u) {
                        r = e ? ((e = !1), t) : n(r, t, i, u);
                      }),
                      r
                    );
                  }
                  function vr(t, n) {
                    for (var r, e = -1, i = t.length; ++e < i; ) {
                      var o = n(t[e]);
                      o !== u && (r = r === u ? o : r + o);
                    }
                    return r;
                  }
                  function yr(t, n) {
                    for (var r = -1, e = Array(t); ++r < t; ) e[r] = n(r);
                    return e;
                  }
                  function dr(t) {
                    return function (n) {
                      return t(n);
                    };
                  }
                  function gr(t, n) {
                    return tr(n, function (n) {
                      return t[n];
                    });
                  }
                  function wr(t, n) {
                    return t.has(n);
                  }
                  function mr(t, n) {
                    for (
                      var r = -1, e = t.length;
                      ++r < e && fr(n, t[r], 0) > -1;

                    );
                    return r;
                  }
                  function br(t, n) {
                    for (var r = t.length; r-- && fr(n, t[r], 0) > -1; );
                    return r;
                  }
                  var Sr = pr({
                      À: "A",
                      Á: "A",
                      Â: "A",
                      Ã: "A",
                      Ä: "A",
                      Å: "A",
                      à: "a",
                      á: "a",
                      â: "a",
                      ã: "a",
                      ä: "a",
                      å: "a",
                      Ç: "C",
                      ç: "c",
                      Ð: "D",
                      ð: "d",
                      È: "E",
                      É: "E",
                      Ê: "E",
                      Ë: "E",
                      è: "e",
                      é: "e",
                      ê: "e",
                      ë: "e",
                      Ì: "I",
                      Í: "I",
                      Î: "I",
                      Ï: "I",
                      ì: "i",
                      í: "i",
                      î: "i",
                      ï: "i",
                      Ñ: "N",
                      ñ: "n",
                      Ò: "O",
                      Ó: "O",
                      Ô: "O",
                      Õ: "O",
                      Ö: "O",
                      Ø: "O",
                      ò: "o",
                      ó: "o",
                      ô: "o",
                      õ: "o",
                      ö: "o",
                      ø: "o",
                      Ù: "U",
                      Ú: "U",
                      Û: "U",
                      Ü: "U",
                      ù: "u",
                      ú: "u",
                      û: "u",
                      ü: "u",
                      Ý: "Y",
                      ý: "y",
                      ÿ: "y",
                      Æ: "Ae",
                      æ: "ae",
                      Þ: "Th",
                      þ: "th",
                      ß: "ss",
                      Ā: "A",
                      Ă: "A",
                      Ą: "A",
                      ā: "a",
                      ă: "a",
                      ą: "a",
                      Ć: "C",
                      Ĉ: "C",
                      Ċ: "C",
                      Č: "C",
                      ć: "c",
                      ĉ: "c",
                      ċ: "c",
                      č: "c",
                      Ď: "D",
                      Đ: "D",
                      ď: "d",
                      đ: "d",
                      Ē: "E",
                      Ĕ: "E",
                      Ė: "E",
                      Ę: "E",
                      Ě: "E",
                      ē: "e",
                      ĕ: "e",
                      ė: "e",
                      ę: "e",
                      ě: "e",
                      Ĝ: "G",
                      Ğ: "G",
                      Ġ: "G",
                      Ģ: "G",
                      ĝ: "g",
                      ğ: "g",
                      ġ: "g",
                      ģ: "g",
                      Ĥ: "H",
                      Ħ: "H",
                      ĥ: "h",
                      ħ: "h",
                      Ĩ: "I",
                      Ī: "I",
                      Ĭ: "I",
                      Į: "I",
                      İ: "I",
                      ĩ: "i",
                      ī: "i",
                      ĭ: "i",
                      į: "i",
                      ı: "i",
                      Ĵ: "J",
                      ĵ: "j",
                      Ķ: "K",
                      ķ: "k",
                      ĸ: "k",
                      Ĺ: "L",
                      Ļ: "L",
                      Ľ: "L",
                      Ŀ: "L",
                      Ł: "L",
                      ĺ: "l",
                      ļ: "l",
                      ľ: "l",
                      ŀ: "l",
                      ł: "l",
                      Ń: "N",
                      Ņ: "N",
                      Ň: "N",
                      Ŋ: "N",
                      ń: "n",
                      ņ: "n",
                      ň: "n",
                      ŋ: "n",
                      Ō: "O",
                      Ŏ: "O",
                      Ő: "O",
                      ō: "o",
                      ŏ: "o",
                      ő: "o",
                      Ŕ: "R",
                      Ŗ: "R",
                      Ř: "R",
                      ŕ: "r",
                      ŗ: "r",
                      ř: "r",
                      Ś: "S",
                      Ŝ: "S",
                      Ş: "S",
                      Š: "S",
                      ś: "s",
                      ŝ: "s",
                      ş: "s",
                      š: "s",
                      Ţ: "T",
                      Ť: "T",
                      Ŧ: "T",
                      ţ: "t",
                      ť: "t",
                      ŧ: "t",
                      Ũ: "U",
                      Ū: "U",
                      Ŭ: "U",
                      Ů: "U",
                      Ű: "U",
                      Ų: "U",
                      ũ: "u",
                      ū: "u",
                      ŭ: "u",
                      ů: "u",
                      ű: "u",
                      ų: "u",
                      Ŵ: "W",
                      ŵ: "w",
                      Ŷ: "Y",
                      ŷ: "y",
                      Ÿ: "Y",
                      Ź: "Z",
                      Ż: "Z",
                      Ž: "Z",
                      ź: "z",
                      ż: "z",
                      ž: "z",
                      Ĳ: "IJ",
                      ĳ: "ij",
                      Œ: "Oe",
                      œ: "oe",
                      ŉ: "'n",
                      ſ: "s",
                    }),
                    Ir = pr({
                      "&": "&amp;",
                      "<": "&lt;",
                      ">": "&gt;",
                      '"': "&quot;",
                      "'": "&#39;",
                    });
                  function zr(t) {
                    return "\\" + En[t];
                  }
                  function xr(t) {
                    return In.test(t);
                  }
                  function Or(t) {
                    var n = -1,
                      r = Array(t.size);
                    return (
                      t.forEach(function (t, e) {
                        r[++n] = [e, t];
                      }),
                      r
                    );
                  }
                  function jr(t, n) {
                    return function (r) {
                      return t(n(r));
                    };
                  }
                  function Ar(t, n) {
                    for (var r = -1, e = t.length, i = 0, u = []; ++r < e; ) {
                      var o = t[r];
                      (o !== n && o !== h) || ((t[r] = h), (u[i++] = r));
                    }
                    return u;
                  }
                  function Er(t) {
                    var n = -1,
                      r = Array(t.size);
                    return (
                      t.forEach(function (t) {
                        r[++n] = t;
                      }),
                      r
                    );
                  }
                  function kr(t) {
                    var n = -1,
                      r = Array(t.size);
                    return (
                      t.forEach(function (t) {
                        r[++n] = [t, t];
                      }),
                      r
                    );
                  }
                  function Mr(t) {
                    return xr(t)
                      ? (function (t) {
                          var n = (bn.lastIndex = 0);
                          for (; bn.test(t); ) ++n;
                          return n;
                        })(t)
                      : ur(t);
                  }
                  function Dr(t) {
                    return xr(t)
                      ? (function (t) {
                          return t.match(bn) || [];
                        })(t)
                      : (function (t) {
                          return t.split("");
                        })(t);
                  }
                  var qr = pr({
                    "&amp;": "&",
                    "&lt;": "<",
                    "&gt;": ">",
                    "&quot;": '"',
                    "&#39;": "'",
                  });
                  var Rr = (function t(n) {
                    var r,
                      e = (n =
                        null == n
                          ? Rn
                          : Rr.defaults(Rn.Object(), n, Rr.pick(Rn, xn))).Array,
                      i = n.Date,
                      Xt = n.Error,
                      Qt = n.Function,
                      tn = n.Math,
                      nn = n.Object,
                      rn = n.RegExp,
                      en = n.String,
                      un = n.TypeError,
                      on = e.prototype,
                      an = Qt.prototype,
                      fn = nn.prototype,
                      cn = n["__core-js_shared__"],
                      sn = an.toString,
                      hn = fn.hasOwnProperty,
                      ln = 0,
                      pn = (r = /[^.]+$/.exec(
                        (cn && cn.keys && cn.keys.IE_PROTO) || ""
                      ))
                        ? "Symbol(src)_1." + r
                        : "",
                      _n = fn.toString,
                      vn = sn.call(nn),
                      yn = Rn._,
                      dn = rn(
                        "^" +
                          sn
                            .call(hn)
                            .replace(Dt, "\\$&")
                            .replace(
                              /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
                              "$1.*?"
                            ) +
                          "$"
                      ),
                      gn = Un ? n.Buffer : u,
                      bn = n.Symbol,
                      In = n.Uint8Array,
                      En = gn ? gn.allocUnsafe : u,
                      Dn = jr(nn.getPrototypeOf, nn),
                      qn = nn.create,
                      Ln = fn.propertyIsEnumerable,
                      Tn = on.splice,
                      Cn = bn ? bn.isConcatSpreadable : u,
                      Wn = bn ? bn.iterator : u,
                      ur = bn ? bn.toStringTag : u,
                      pr = (function () {
                        try {
                          var t = Cu(nn, "defineProperty");
                          return t({}, "", {}), t;
                        } catch (t) {}
                      })(),
                      Lr = n.clearTimeout !== Rn.clearTimeout && n.clearTimeout,
                      Tr = i && i.now !== Rn.Date.now && i.now,
                      Ur = n.setTimeout !== Rn.setTimeout && n.setTimeout,
                      Cr = tn.ceil,
                      Wr = tn.floor,
                      Br = nn.getOwnPropertySymbols,
                      Kr = gn ? gn.isBuffer : u,
                      Pr = n.isFinite,
                      Nr = on.join,
                      $r = jr(nn.keys, nn),
                      Fr = tn.max,
                      Jr = tn.min,
                      Hr = i.now,
                      Vr = n.parseInt,
                      Zr = tn.random,
                      Gr = on.reverse,
                      Yr = Cu(n, "DataView"),
                      Xr = Cu(n, "Map"),
                      Qr = Cu(n, "Promise"),
                      te = Cu(n, "Set"),
                      ne = Cu(n, "WeakMap"),
                      re = Cu(nn, "create"),
                      ee = ne && new ne(),
                      ie = {},
                      ue = so(Yr),
                      oe = so(Xr),
                      ae = so(Qr),
                      fe = so(te),
                      ce = so(ne),
                      se = bn ? bn.prototype : u,
                      he = se ? se.valueOf : u,
                      le = se ? se.toString : u;
                    function pe(t) {
                      if (Aa(t) && !da(t) && !(t instanceof de)) {
                        if (t instanceof ye) return t;
                        if (hn.call(t, "__wrapped__")) return ho(t);
                      }
                      return new ye(t);
                    }
                    var _e = (function () {
                      function t() {}
                      return function (n) {
                        if (!ja(n)) return {};
                        if (qn) return qn(n);
                        t.prototype = n;
                        var r = new t();
                        return (t.prototype = u), r;
                      };
                    })();
                    function ve() {}
                    function ye(t, n) {
                      (this.__wrapped__ = t),
                        (this.__actions__ = []),
                        (this.__chain__ = !!n),
                        (this.__index__ = 0),
                        (this.__values__ = u);
                    }
                    function de(t) {
                      (this.__wrapped__ = t),
                        (this.__actions__ = []),
                        (this.__dir__ = 1),
                        (this.__filtered__ = !1),
                        (this.__iteratees__ = []),
                        (this.__takeCount__ = U),
                        (this.__views__ = []);
                    }
                    function ge(t) {
                      var n = -1,
                        r = null == t ? 0 : t.length;
                      for (this.clear(); ++n < r; ) {
                        var e = t[n];
                        this.set(e[0], e[1]);
                      }
                    }
                    function we(t) {
                      var n = -1,
                        r = null == t ? 0 : t.length;
                      for (this.clear(); ++n < r; ) {
                        var e = t[n];
                        this.set(e[0], e[1]);
                      }
                    }
                    function me(t) {
                      var n = -1,
                        r = null == t ? 0 : t.length;
                      for (this.clear(); ++n < r; ) {
                        var e = t[n];
                        this.set(e[0], e[1]);
                      }
                    }
                    function be(t) {
                      var n = -1,
                        r = null == t ? 0 : t.length;
                      for (this.__data__ = new me(); ++n < r; ) this.add(t[n]);
                    }
                    function Se(t) {
                      var n = (this.__data__ = new we(t));
                      this.size = n.size;
                    }
                    function Ie(t, n) {
                      var r = da(t),
                        e = !r && ya(t),
                        i = !r && !e && ba(t),
                        u = !r && !e && !i && Ta(t),
                        o = r || e || i || u,
                        a = o ? yr(t.length, en) : [],
                        f = a.length;
                      for (var c in t)
                        (!n && !hn.call(t, c)) ||
                          (o &&
                            ("length" == c ||
                              (i && ("offset" == c || "parent" == c)) ||
                              (u &&
                                ("buffer" == c ||
                                  "byteLength" == c ||
                                  "byteOffset" == c)) ||
                              Fu(c, f))) ||
                          a.push(c);
                      return a;
                    }
                    function ze(t) {
                      var n = t.length;
                      return n ? t[bi(0, n - 1)] : u;
                    }
                    function xe(t, n) {
                      return ao(ru(t), Re(n, 0, t.length));
                    }
                    function Oe(t) {
                      return ao(ru(t));
                    }
                    function je(t, n, r) {
                      ((r === u || pa(t[n], r)) && (r !== u || n in t)) ||
                        De(t, n, r);
                    }
                    function Ae(t, n, r) {
                      var e = t[n];
                      (hn.call(t, n) && pa(e, r) && (r !== u || n in t)) ||
                        De(t, n, r);
                    }
                    function Ee(t, n) {
                      for (var r = t.length; r--; )
                        if (pa(t[r][0], n)) return r;
                      return -1;
                    }
                    function ke(t, n, r, e) {
                      return (
                        We(t, function (t, i, u) {
                          n(e, t, r(t), u);
                        }),
                        e
                      );
                    }
                    function Me(t, n) {
                      return t && eu(n, uf(n), t);
                    }
                    function De(t, n, r) {
                      "__proto__" == n && pr
                        ? pr(t, n, {
                            configurable: !0,
                            enumerable: !0,
                            value: r,
                            writable: !0,
                          })
                        : (t[n] = r);
                    }
                    function qe(t, n) {
                      for (
                        var r = -1, i = n.length, o = e(i), a = null == t;
                        ++r < i;

                      )
                        o[r] = a ? u : Qa(t, n[r]);
                      return o;
                    }
                    function Re(t, n, r) {
                      return (
                        t == t &&
                          (r !== u && (t = t <= r ? t : r),
                          n !== u && (t = t >= n ? t : n)),
                        t
                      );
                    }
                    function Le(t, n, r, e, i, o) {
                      var a,
                        f = n & l,
                        c = n & p,
                        s = n & _;
                      if ((r && (a = i ? r(t, e, i, o) : r(t)), a !== u))
                        return a;
                      if (!ja(t)) return t;
                      var h = da(t);
                      if (h) {
                        if (
                          ((a = (function (t) {
                            var n = t.length,
                              r = new t.constructor(n);
                            n &&
                              "string" == typeof t[0] &&
                              hn.call(t, "index") &&
                              ((r.index = t.index), (r.input = t.input));
                            return r;
                          })(t)),
                          !f)
                        )
                          return ru(t, a);
                      } else {
                        var v = Ku(t),
                          y = v == V || v == Z;
                        if (ba(t)) return Gi(t, f);
                        if (v == Q || v == K || (y && !i)) {
                          if (((a = c || y ? {} : Nu(t)), !f))
                            return c
                              ? (function (t, n) {
                                  return eu(t, Bu(t), n);
                                })(
                                  t,
                                  (function (t, n) {
                                    return t && eu(n, of(n), t);
                                  })(a, t)
                                )
                              : (function (t, n) {
                                  return eu(t, Wu(t), n);
                                })(t, Me(a, t));
                        } else {
                          if (!An[v]) return i ? t : {};
                          a = (function (t, n, r) {
                            var e = t.constructor;
                            switch (n) {
                              case ft:
                                return Yi(t);
                              case $:
                              case F:
                                return new e(+t);
                              case ct:
                                return (function (t, n) {
                                  var r = n ? Yi(t.buffer) : t.buffer;
                                  return new t.constructor(
                                    r,
                                    t.byteOffset,
                                    t.byteLength
                                  );
                                })(t, r);
                              case st:
                              case ht:
                              case lt:
                              case pt:
                              case _t:
                              case vt:
                              case yt:
                              case dt:
                              case gt:
                                return Xi(t, r);
                              case G:
                                return new e();
                              case Y:
                              case et:
                                return new e(t);
                              case nt:
                                return (function (t) {
                                  var n = new t.constructor(
                                    t.source,
                                    Nt.exec(t)
                                  );
                                  return (n.lastIndex = t.lastIndex), n;
                                })(t);
                              case rt:
                                return new e();
                              case it:
                                return (i = t), he ? nn(he.call(i)) : {};
                            }
                            var i;
                          })(t, v, f);
                        }
                      }
                      o || (o = new Se());
                      var d = o.get(t);
                      if (d) return d;
                      o.set(t, a),
                        qa(t)
                          ? t.forEach(function (e) {
                              a.add(Le(e, n, r, e, t, o));
                            })
                          : Ea(t) &&
                            t.forEach(function (e, i) {
                              a.set(i, Le(e, n, r, i, t, o));
                            });
                      var g = h ? u : (s ? (c ? Mu : ku) : c ? of : uf)(t);
                      return (
                        Vn(g || t, function (e, i) {
                          g && (e = t[(i = e)]), Ae(a, i, Le(e, n, r, i, t, o));
                        }),
                        a
                      );
                    }
                    function Te(t, n, r) {
                      var e = r.length;
                      if (null == t) return !e;
                      for (t = nn(t); e--; ) {
                        var i = r[e],
                          o = n[i],
                          a = t[i];
                        if ((a === u && !(i in t)) || !o(a)) return !1;
                      }
                      return !0;
                    }
                    function Ue(t, n, r) {
                      if ("function" != typeof t) throw new un(f);
                      return eo(function () {
                        t.apply(u, r);
                      }, n);
                    }
                    function Ce(t, n, r, e) {
                      var i = -1,
                        u = Xn,
                        a = !0,
                        f = t.length,
                        c = [],
                        s = n.length;
                      if (!f) return c;
                      r && (n = tr(n, dr(r))),
                        e
                          ? ((u = Qn), (a = !1))
                          : n.length >= o &&
                            ((u = wr), (a = !1), (n = new be(n)));
                      t: for (; ++i < f; ) {
                        var h = t[i],
                          l = null == r ? h : r(h);
                        if (((h = e || 0 !== h ? h : 0), a && l == l)) {
                          for (var p = s; p--; ) if (n[p] === l) continue t;
                          c.push(h);
                        } else u(n, l, e) || c.push(h);
                      }
                      return c;
                    }
                    (pe.templateSettings = {
                      escape: Ot,
                      evaluate: jt,
                      interpolate: At,
                      variable: "",
                      imports: { _: pe },
                    }),
                      (pe.prototype = ve.prototype),
                      (pe.prototype.constructor = pe),
                      (ye.prototype = _e(ve.prototype)),
                      (ye.prototype.constructor = ye),
                      (de.prototype = _e(ve.prototype)),
                      (de.prototype.constructor = de),
                      (ge.prototype.clear = function () {
                        (this.__data__ = re ? re(null) : {}), (this.size = 0);
                      }),
                      (ge.prototype.delete = function (t) {
                        var n = this.has(t) && delete this.__data__[t];
                        return (this.size -= n ? 1 : 0), n;
                      }),
                      (ge.prototype.get = function (t) {
                        var n = this.__data__;
                        if (re) {
                          var r = n[t];
                          return r === c ? u : r;
                        }
                        return hn.call(n, t) ? n[t] : u;
                      }),
                      (ge.prototype.has = function (t) {
                        var n = this.__data__;
                        return re ? n[t] !== u : hn.call(n, t);
                      }),
                      (ge.prototype.set = function (t, n) {
                        var r = this.__data__;
                        return (
                          (this.size += this.has(t) ? 0 : 1),
                          (r[t] = re && n === u ? c : n),
                          this
                        );
                      }),
                      (we.prototype.clear = function () {
                        (this.__data__ = []), (this.size = 0);
                      }),
                      (we.prototype.delete = function (t) {
                        var n = this.__data__,
                          r = Ee(n, t);
                        return (
                          !(r < 0) &&
                          (r == n.length - 1 ? n.pop() : Tn.call(n, r, 1),
                          --this.size,
                          !0)
                        );
                      }),
                      (we.prototype.get = function (t) {
                        var n = this.__data__,
                          r = Ee(n, t);
                        return r < 0 ? u : n[r][1];
                      }),
                      (we.prototype.has = function (t) {
                        return Ee(this.__data__, t) > -1;
                      }),
                      (we.prototype.set = function (t, n) {
                        var r = this.__data__,
                          e = Ee(r, t);
                        return (
                          e < 0 ? (++this.size, r.push([t, n])) : (r[e][1] = n),
                          this
                        );
                      }),
                      (me.prototype.clear = function () {
                        (this.size = 0),
                          (this.__data__ = {
                            hash: new ge(),
                            map: new (Xr || we)(),
                            string: new ge(),
                          });
                      }),
                      (me.prototype.delete = function (t) {
                        var n = Tu(this, t).delete(t);
                        return (this.size -= n ? 1 : 0), n;
                      }),
                      (me.prototype.get = function (t) {
                        return Tu(this, t).get(t);
                      }),
                      (me.prototype.has = function (t) {
                        return Tu(this, t).has(t);
                      }),
                      (me.prototype.set = function (t, n) {
                        var r = Tu(this, t),
                          e = r.size;
                        return (
                          r.set(t, n), (this.size += r.size == e ? 0 : 1), this
                        );
                      }),
                      (be.prototype.add = be.prototype.push = function (t) {
                        return this.__data__.set(t, c), this;
                      }),
                      (be.prototype.has = function (t) {
                        return this.__data__.has(t);
                      }),
                      (Se.prototype.clear = function () {
                        (this.__data__ = new we()), (this.size = 0);
                      }),
                      (Se.prototype.delete = function (t) {
                        var n = this.__data__,
                          r = n.delete(t);
                        return (this.size = n.size), r;
                      }),
                      (Se.prototype.get = function (t) {
                        return this.__data__.get(t);
                      }),
                      (Se.prototype.has = function (t) {
                        return this.__data__.has(t);
                      }),
                      (Se.prototype.set = function (t, n) {
                        var r = this.__data__;
                        if (r instanceof we) {
                          var e = r.__data__;
                          if (!Xr || e.length < o - 1)
                            return e.push([t, n]), (this.size = ++r.size), this;
                          r = this.__data__ = new me(e);
                        }
                        return r.set(t, n), (this.size = r.size), this;
                      });
                    var We = ou(He),
                      Be = ou(Ve, !0);
                    function Ke(t, n) {
                      var r = !0;
                      return (
                        We(t, function (t, e, i) {
                          return (r = !!n(t, e, i));
                        }),
                        r
                      );
                    }
                    function Pe(t, n, r) {
                      for (var e = -1, i = t.length; ++e < i; ) {
                        var o = t[e],
                          a = n(o);
                        if (null != a && (f === u ? a == a && !La(a) : r(a, f)))
                          var f = a,
                            c = o;
                      }
                      return c;
                    }
                    function Ne(t, n) {
                      var r = [];
                      return (
                        We(t, function (t, e, i) {
                          n(t, e, i) && r.push(t);
                        }),
                        r
                      );
                    }
                    function $e(t, n, r, e, i) {
                      var u = -1,
                        o = t.length;
                      for (r || (r = $u), i || (i = []); ++u < o; ) {
                        var a = t[u];
                        n > 0 && r(a)
                          ? n > 1
                            ? $e(a, n - 1, r, e, i)
                            : nr(i, a)
                          : e || (i[i.length] = a);
                      }
                      return i;
                    }
                    var Fe = au(),
                      Je = au(!0);
                    function He(t, n) {
                      return t && Fe(t, n, uf);
                    }
                    function Ve(t, n) {
                      return t && Je(t, n, uf);
                    }
                    function Ze(t, n) {
                      return Yn(n, function (n) {
                        return za(t[n]);
                      });
                    }
                    function Ge(t, n) {
                      for (
                        var r = 0, e = (n = Ji(n, t)).length;
                        null != t && r < e;

                      )
                        t = t[co(n[r++])];
                      return r && r == e ? t : u;
                    }
                    function Ye(t, n, r) {
                      var e = n(t);
                      return da(t) ? e : nr(e, r(t));
                    }
                    function Xe(t) {
                      return null == t
                        ? t === u
                          ? ut
                          : X
                        : ur && ur in nn(t)
                        ? (function (t) {
                            var n = hn.call(t, ur),
                              r = t[ur];
                            try {
                              t[ur] = u;
                              var e = !0;
                            } catch (t) {}
                            var i = _n.call(t);
                            e && (n ? (t[ur] = r) : delete t[ur]);
                            return i;
                          })(t)
                        : (function (t) {
                            return _n.call(t);
                          })(t);
                    }
                    function Qe(t, n) {
                      return t > n;
                    }
                    function ti(t, n) {
                      return null != t && hn.call(t, n);
                    }
                    function ni(t, n) {
                      return null != t && n in nn(t);
                    }
                    function ri(t, n, r) {
                      for (
                        var i = r ? Qn : Xn,
                          o = t[0].length,
                          a = t.length,
                          f = a,
                          c = e(a),
                          s = 1 / 0,
                          h = [];
                        f--;

                      ) {
                        var l = t[f];
                        f && n && (l = tr(l, dr(n))),
                          (s = Jr(l.length, s)),
                          (c[f] =
                            !r && (n || (o >= 120 && l.length >= 120))
                              ? new be(f && l)
                              : u);
                      }
                      l = t[0];
                      var p = -1,
                        _ = c[0];
                      t: for (; ++p < o && h.length < s; ) {
                        var v = l[p],
                          y = n ? n(v) : v;
                        if (
                          ((v = r || 0 !== v ? v : 0),
                          !(_ ? wr(_, y) : i(h, y, r)))
                        ) {
                          for (f = a; --f; ) {
                            var d = c[f];
                            if (!(d ? wr(d, y) : i(t[f], y, r))) continue t;
                          }
                          _ && _.push(y), h.push(v);
                        }
                      }
                      return h;
                    }
                    function ei(t, n, r) {
                      var e =
                        null == (t = to(t, (n = Ji(n, t)))) ? t : t[co(Io(n))];
                      return null == e ? u : Jn(e, t, r);
                    }
                    function ii(t) {
                      return Aa(t) && Xe(t) == K;
                    }
                    function ui(t, n, r, e, i) {
                      return (
                        t === n ||
                        (null == t || null == n || (!Aa(t) && !Aa(n))
                          ? t != t && n != n
                          : (function (t, n, r, e, i, o) {
                              var a = da(t),
                                f = da(n),
                                c = a ? P : Ku(t),
                                s = f ? P : Ku(n),
                                h = (c = c == K ? Q : c) == Q,
                                l = (s = s == K ? Q : s) == Q,
                                p = c == s;
                              if (p && ba(t)) {
                                if (!ba(n)) return !1;
                                (a = !0), (h = !1);
                              }
                              if (p && !h)
                                return (
                                  o || (o = new Se()),
                                  a || Ta(t)
                                    ? Au(t, n, r, e, i, o)
                                    : (function (t, n, r, e, i, u, o) {
                                        switch (r) {
                                          case ct:
                                            if (
                                              t.byteLength != n.byteLength ||
                                              t.byteOffset != n.byteOffset
                                            )
                                              return !1;
                                            (t = t.buffer), (n = n.buffer);
                                          case ft:
                                            return !(
                                              t.byteLength != n.byteLength ||
                                              !u(new In(t), new In(n))
                                            );
                                          case $:
                                          case F:
                                          case Y:
                                            return pa(+t, +n);
                                          case H:
                                            return (
                                              t.name == n.name &&
                                              t.message == n.message
                                            );
                                          case nt:
                                          case et:
                                            return t == n + "";
                                          case G:
                                            var a = Or;
                                          case rt:
                                            var f = e & v;
                                            if (
                                              (a || (a = Er),
                                              t.size != n.size && !f)
                                            )
                                              return !1;
                                            var c = o.get(t);
                                            if (c) return c == n;
                                            (e |= y), o.set(t, n);
                                            var s = Au(a(t), a(n), e, i, u, o);
                                            return o.delete(t), s;
                                          case it:
                                            if (he)
                                              return he.call(t) == he.call(n);
                                        }
                                        return !1;
                                      })(t, n, c, r, e, i, o)
                                );
                              if (!(r & v)) {
                                var _ = h && hn.call(t, "__wrapped__"),
                                  d = l && hn.call(n, "__wrapped__");
                                if (_ || d) {
                                  var g = _ ? t.value() : t,
                                    w = d ? n.value() : n;
                                  return o || (o = new Se()), i(g, w, r, e, o);
                                }
                              }
                              if (!p) return !1;
                              return (
                                o || (o = new Se()),
                                (function (t, n, r, e, i, o) {
                                  var a = r & v,
                                    f = ku(t),
                                    c = f.length,
                                    s = ku(n).length;
                                  if (c != s && !a) return !1;
                                  var h = c;
                                  for (; h--; ) {
                                    var l = f[h];
                                    if (!(a ? l in n : hn.call(n, l)))
                                      return !1;
                                  }
                                  var p = o.get(t);
                                  if (p && o.get(n)) return p == n;
                                  var _ = !0;
                                  o.set(t, n), o.set(n, t);
                                  var y = a;
                                  for (; ++h < c; ) {
                                    l = f[h];
                                    var d = t[l],
                                      g = n[l];
                                    if (e)
                                      var w = a
                                        ? e(g, d, l, n, t, o)
                                        : e(d, g, l, t, n, o);
                                    if (
                                      !(w === u
                                        ? d === g || i(d, g, r, e, o)
                                        : w)
                                    ) {
                                      _ = !1;
                                      break;
                                    }
                                    y || (y = "constructor" == l);
                                  }
                                  if (_ && !y) {
                                    var m = t.constructor,
                                      b = n.constructor;
                                    m != b &&
                                      "constructor" in t &&
                                      "constructor" in n &&
                                      !(
                                        "function" == typeof m &&
                                        m instanceof m &&
                                        "function" == typeof b &&
                                        b instanceof b
                                      ) &&
                                      (_ = !1);
                                  }
                                  return o.delete(t), o.delete(n), _;
                                })(t, n, r, e, i, o)
                              );
                            })(t, n, r, e, ui, i))
                      );
                    }
                    function oi(t, n, r, e) {
                      var i = r.length,
                        o = i,
                        a = !e;
                      if (null == t) return !o;
                      for (t = nn(t); i--; ) {
                        var f = r[i];
                        if (a && f[2] ? f[1] !== t[f[0]] : !(f[0] in t))
                          return !1;
                      }
                      for (; ++i < o; ) {
                        var c = (f = r[i])[0],
                          s = t[c],
                          h = f[1];
                        if (a && f[2]) {
                          if (s === u && !(c in t)) return !1;
                        } else {
                          var l = new Se();
                          if (e) var p = e(s, h, c, t, n, l);
                          if (!(p === u ? ui(h, s, v | y, e, l) : p)) return !1;
                        }
                      }
                      return !0;
                    }
                    function ai(t) {
                      return (
                        !(!ja(t) || ((n = t), pn && pn in n)) &&
                        (za(t) ? dn : Jt).test(so(t))
                      );
                      var n;
                    }
                    function fi(t) {
                      return "function" == typeof t
                        ? t
                        : null == t
                        ? Mf
                        : "object" == typeof t
                        ? da(t)
                          ? _i(t[0], t[1])
                          : pi(t)
                        : Bf(t);
                    }
                    function ci(t) {
                      if (!Gu(t)) return $r(t);
                      var n = [];
                      for (var r in nn(t))
                        hn.call(t, r) && "constructor" != r && n.push(r);
                      return n;
                    }
                    function si(t) {
                      if (!ja(t))
                        return (function (t) {
                          var n = [];
                          if (null != t) for (var r in nn(t)) n.push(r);
                          return n;
                        })(t);
                      var n = Gu(t),
                        r = [];
                      for (var e in t)
                        ("constructor" != e || (!n && hn.call(t, e))) &&
                          r.push(e);
                      return r;
                    }
                    function hi(t, n) {
                      return t < n;
                    }
                    function li(t, n) {
                      var r = -1,
                        i = wa(t) ? e(t.length) : [];
                      return (
                        We(t, function (t, e, u) {
                          i[++r] = n(t, e, u);
                        }),
                        i
                      );
                    }
                    function pi(t) {
                      var n = Uu(t);
                      return 1 == n.length && n[0][2]
                        ? Xu(n[0][0], n[0][1])
                        : function (r) {
                            return r === t || oi(r, t, n);
                          };
                    }
                    function _i(t, n) {
                      return Hu(t) && Yu(n)
                        ? Xu(co(t), n)
                        : function (r) {
                            var e = Qa(r, t);
                            return e === u && e === n
                              ? tf(r, t)
                              : ui(n, e, v | y);
                          };
                    }
                    function vi(t, n, r, e, i) {
                      t !== n &&
                        Fe(
                          n,
                          function (o, a) {
                            if ((i || (i = new Se()), ja(o)))
                              !(function (t, n, r, e, i, o, a) {
                                var f = no(t, r),
                                  c = no(n, r),
                                  s = a.get(c);
                                if (s) return void je(t, r, s);
                                var h = o ? o(f, c, r + "", t, n, a) : u,
                                  l = h === u;
                                if (l) {
                                  var p = da(c),
                                    _ = !p && ba(c),
                                    v = !p && !_ && Ta(c);
                                  (h = c),
                                    p || _ || v
                                      ? da(f)
                                        ? (h = f)
                                        : ma(f)
                                        ? (h = ru(f))
                                        : _
                                        ? ((l = !1), (h = Gi(c, !0)))
                                        : v
                                        ? ((l = !1), (h = Xi(c, !0)))
                                        : (h = [])
                                      : Ma(c) || ya(c)
                                      ? ((h = f),
                                        ya(f)
                                          ? (h = $a(f))
                                          : (ja(f) && !za(f)) || (h = Nu(c)))
                                      : (l = !1);
                                }
                                l &&
                                  (a.set(c, h), i(h, c, e, o, a), a.delete(c));
                                je(t, r, h);
                              })(t, n, a, r, vi, e, i);
                            else {
                              var f = e ? e(no(t, a), o, a + "", t, n, i) : u;
                              f === u && (f = o), je(t, a, f);
                            }
                          },
                          of
                        );
                    }
                    function yi(t, n) {
                      var r = t.length;
                      if (r) return Fu((n += n < 0 ? r : 0), r) ? t[n] : u;
                    }
                    function di(t, n, r) {
                      var e = -1;
                      return (
                        (n = tr(n.length ? n : [Mf], dr(Lu()))),
                        (function (t, n) {
                          var r = t.length;
                          for (t.sort(n); r--; ) t[r] = t[r].value;
                          return t;
                        })(
                          li(t, function (t, r, i) {
                            return {
                              criteria: tr(n, function (n) {
                                return n(t);
                              }),
                              index: ++e,
                              value: t,
                            };
                          }),
                          function (t, n) {
                            return (function (t, n, r) {
                              var e = -1,
                                i = t.criteria,
                                u = n.criteria,
                                o = i.length,
                                a = r.length;
                              for (; ++e < o; ) {
                                var f = Qi(i[e], u[e]);
                                if (f) {
                                  if (e >= a) return f;
                                  var c = r[e];
                                  return f * ("desc" == c ? -1 : 1);
                                }
                              }
                              return t.index - n.index;
                            })(t, n, r);
                          }
                        )
                      );
                    }
                    function gi(t, n, r) {
                      for (var e = -1, i = n.length, u = {}; ++e < i; ) {
                        var o = n[e],
                          a = Ge(t, o);
                        r(a, o) && Oi(u, Ji(o, t), a);
                      }
                      return u;
                    }
                    function wi(t, n, r, e) {
                      var i = e ? cr : fr,
                        u = -1,
                        o = n.length,
                        a = t;
                      for (
                        t === n && (n = ru(n)), r && (a = tr(t, dr(r)));
                        ++u < o;

                      )
                        for (
                          var f = 0, c = n[u], s = r ? r(c) : c;
                          (f = i(a, s, f, e)) > -1;

                        )
                          a !== t && Tn.call(a, f, 1), Tn.call(t, f, 1);
                      return t;
                    }
                    function mi(t, n) {
                      for (var r = t ? n.length : 0, e = r - 1; r--; ) {
                        var i = n[r];
                        if (r == e || i !== u) {
                          var u = i;
                          Fu(i) ? Tn.call(t, i, 1) : Ci(t, i);
                        }
                      }
                      return t;
                    }
                    function bi(t, n) {
                      return t + Wr(Zr() * (n - t + 1));
                    }
                    function Si(t, n) {
                      var r = "";
                      if (!t || n < 1 || n > R) return r;
                      do {
                        n % 2 && (r += t), (n = Wr(n / 2)) && (t += t);
                      } while (n);
                      return r;
                    }
                    function Ii(t, n) {
                      return io(Qu(t, n, Mf), t + "");
                    }
                    function zi(t) {
                      return ze(_f(t));
                    }
                    function xi(t, n) {
                      var r = _f(t);
                      return ao(r, Re(n, 0, r.length));
                    }
                    function Oi(t, n, r, e) {
                      if (!ja(t)) return t;
                      for (
                        var i = -1, o = (n = Ji(n, t)).length, a = o - 1, f = t;
                        null != f && ++i < o;

                      ) {
                        var c = co(n[i]),
                          s = r;
                        if (i != a) {
                          var h = f[c];
                          (s = e ? e(h, c, f) : u) === u &&
                            (s = ja(h) ? h : Fu(n[i + 1]) ? [] : {});
                        }
                        Ae(f, c, s), (f = f[c]);
                      }
                      return t;
                    }
                    var ji = ee
                        ? function (t, n) {
                            return ee.set(t, n), t;
                          }
                        : Mf,
                      Ai = pr
                        ? function (t, n) {
                            return pr(t, "toString", {
                              configurable: !0,
                              enumerable: !1,
                              value: Af(n),
                              writable: !0,
                            });
                          }
                        : Mf;
                    function Ei(t) {
                      return ao(_f(t));
                    }
                    function ki(t, n, r) {
                      var i = -1,
                        u = t.length;
                      n < 0 && (n = -n > u ? 0 : u + n),
                        (r = r > u ? u : r) < 0 && (r += u),
                        (u = n > r ? 0 : (r - n) >>> 0),
                        (n >>>= 0);
                      for (var o = e(u); ++i < u; ) o[i] = t[i + n];
                      return o;
                    }
                    function Mi(t, n) {
                      var r;
                      return (
                        We(t, function (t, e, i) {
                          return !(r = n(t, e, i));
                        }),
                        !!r
                      );
                    }
                    function Di(t, n, r) {
                      var e = 0,
                        i = null == t ? e : t.length;
                      if ("number" == typeof n && n == n && i <= W) {
                        for (; e < i; ) {
                          var u = (e + i) >>> 1,
                            o = t[u];
                          null !== o && !La(o) && (r ? o <= n : o < n)
                            ? (e = u + 1)
                            : (i = u);
                        }
                        return i;
                      }
                      return qi(t, n, Mf, r);
                    }
                    function qi(t, n, r, e) {
                      n = r(n);
                      for (
                        var i = 0,
                          o = null == t ? 0 : t.length,
                          a = n != n,
                          f = null === n,
                          c = La(n),
                          s = n === u;
                        i < o;

                      ) {
                        var h = Wr((i + o) / 2),
                          l = r(t[h]),
                          p = l !== u,
                          _ = null === l,
                          v = l == l,
                          y = La(l);
                        if (a) var d = e || v;
                        else
                          d = s
                            ? v && (e || p)
                            : f
                            ? v && p && (e || !_)
                            : c
                            ? v && p && !_ && (e || !y)
                            : !_ && !y && (e ? l <= n : l < n);
                        d ? (i = h + 1) : (o = h);
                      }
                      return Jr(o, C);
                    }
                    function Ri(t, n) {
                      for (var r = -1, e = t.length, i = 0, u = []; ++r < e; ) {
                        var o = t[r],
                          a = n ? n(o) : o;
                        if (!r || !pa(a, f)) {
                          var f = a;
                          u[i++] = 0 === o ? 0 : o;
                        }
                      }
                      return u;
                    }
                    function Li(t) {
                      return "number" == typeof t ? t : La(t) ? T : +t;
                    }
                    function Ti(t) {
                      if ("string" == typeof t) return t;
                      if (da(t)) return tr(t, Ti) + "";
                      if (La(t)) return le ? le.call(t) : "";
                      var n = t + "";
                      return "0" == n && 1 / t == -q ? "-0" : n;
                    }
                    function Ui(t, n, r) {
                      var e = -1,
                        i = Xn,
                        u = t.length,
                        a = !0,
                        f = [],
                        c = f;
                      if (r) (a = !1), (i = Qn);
                      else if (u >= o) {
                        var s = n ? null : Su(t);
                        if (s) return Er(s);
                        (a = !1), (i = wr), (c = new be());
                      } else c = n ? [] : f;
                      t: for (; ++e < u; ) {
                        var h = t[e],
                          l = n ? n(h) : h;
                        if (((h = r || 0 !== h ? h : 0), a && l == l)) {
                          for (var p = c.length; p--; )
                            if (c[p] === l) continue t;
                          n && c.push(l), f.push(h);
                        } else i(c, l, r) || (c !== f && c.push(l), f.push(h));
                      }
                      return f;
                    }
                    function Ci(t, n) {
                      return (
                        null == (t = to(t, (n = Ji(n, t)))) ||
                        delete t[co(Io(n))]
                      );
                    }
                    function Wi(t, n, r, e) {
                      return Oi(t, n, r(Ge(t, n)), e);
                    }
                    function Bi(t, n, r, e) {
                      for (
                        var i = t.length, u = e ? i : -1;
                        (e ? u-- : ++u < i) && n(t[u], u, t);

                      );
                      return r
                        ? ki(t, e ? 0 : u, e ? u + 1 : i)
                        : ki(t, e ? u + 1 : 0, e ? i : u);
                    }
                    function Ki(t, n) {
                      var r = t;
                      return (
                        r instanceof de && (r = r.value()),
                        rr(
                          n,
                          function (t, n) {
                            return n.func.apply(n.thisArg, nr([t], n.args));
                          },
                          r
                        )
                      );
                    }
                    function Pi(t, n, r) {
                      var i = t.length;
                      if (i < 2) return i ? Ui(t[0]) : [];
                      for (var u = -1, o = e(i); ++u < i; )
                        for (var a = t[u], f = -1; ++f < i; )
                          f != u && (o[u] = Ce(o[u] || a, t[f], n, r));
                      return Ui($e(o, 1), n, r);
                    }
                    function Ni(t, n, r) {
                      for (
                        var e = -1, i = t.length, o = n.length, a = {};
                        ++e < i;

                      ) {
                        var f = e < o ? n[e] : u;
                        r(a, t[e], f);
                      }
                      return a;
                    }
                    function $i(t) {
                      return ma(t) ? t : [];
                    }
                    function Fi(t) {
                      return "function" == typeof t ? t : Mf;
                    }
                    function Ji(t, n) {
                      return da(t) ? t : Hu(t, n) ? [t] : fo(Fa(t));
                    }
                    var Hi = Ii;
                    function Vi(t, n, r) {
                      var e = t.length;
                      return (
                        (r = r === u ? e : r), !n && r >= e ? t : ki(t, n, r)
                      );
                    }
                    var Zi =
                      Lr ||
                      function (t) {
                        return Rn.clearTimeout(t);
                      };
                    function Gi(t, n) {
                      if (n) return t.slice();
                      var r = t.length,
                        e = En ? En(r) : new t.constructor(r);
                      return t.copy(e), e;
                    }
                    function Yi(t) {
                      var n = new t.constructor(t.byteLength);
                      return new In(n).set(new In(t)), n;
                    }
                    function Xi(t, n) {
                      var r = n ? Yi(t.buffer) : t.buffer;
                      return new t.constructor(r, t.byteOffset, t.length);
                    }
                    function Qi(t, n) {
                      if (t !== n) {
                        var r = t !== u,
                          e = null === t,
                          i = t == t,
                          o = La(t),
                          a = n !== u,
                          f = null === n,
                          c = n == n,
                          s = La(n);
                        if (
                          (!f && !s && !o && t > n) ||
                          (o && a && c && !f && !s) ||
                          (e && a && c) ||
                          (!r && c) ||
                          !i
                        )
                          return 1;
                        if (
                          (!e && !o && !s && t < n) ||
                          (s && r && i && !e && !o) ||
                          (f && r && i) ||
                          (!a && i) ||
                          !c
                        )
                          return -1;
                      }
                      return 0;
                    }
                    function tu(t, n, r, i) {
                      for (
                        var u = -1,
                          o = t.length,
                          a = r.length,
                          f = -1,
                          c = n.length,
                          s = Fr(o - a, 0),
                          h = e(c + s),
                          l = !i;
                        ++f < c;

                      )
                        h[f] = n[f];
                      for (; ++u < a; ) (l || u < o) && (h[r[u]] = t[u]);
                      for (; s--; ) h[f++] = t[u++];
                      return h;
                    }
                    function nu(t, n, r, i) {
                      for (
                        var u = -1,
                          o = t.length,
                          a = -1,
                          f = r.length,
                          c = -1,
                          s = n.length,
                          h = Fr(o - f, 0),
                          l = e(h + s),
                          p = !i;
                        ++u < h;

                      )
                        l[u] = t[u];
                      for (var _ = u; ++c < s; ) l[_ + c] = n[c];
                      for (; ++a < f; ) (p || u < o) && (l[_ + r[a]] = t[u++]);
                      return l;
                    }
                    function ru(t, n) {
                      var r = -1,
                        i = t.length;
                      for (n || (n = e(i)); ++r < i; ) n[r] = t[r];
                      return n;
                    }
                    function eu(t, n, r, e) {
                      var i = !r;
                      r || (r = {});
                      for (var o = -1, a = n.length; ++o < a; ) {
                        var f = n[o],
                          c = e ? e(r[f], t[f], f, r, t) : u;
                        c === u && (c = t[f]), i ? De(r, f, c) : Ae(r, f, c);
                      }
                      return r;
                    }
                    function iu(t, n) {
                      return function (r, e) {
                        var i = da(r) ? Hn : ke,
                          u = n ? n() : {};
                        return i(r, t, Lu(e, 2), u);
                      };
                    }
                    function uu(t) {
                      return Ii(function (n, r) {
                        var e = -1,
                          i = r.length,
                          o = i > 1 ? r[i - 1] : u,
                          a = i > 2 ? r[2] : u;
                        for (
                          o =
                            t.length > 3 && "function" == typeof o
                              ? (i--, o)
                              : u,
                            a &&
                              Ju(r[0], r[1], a) &&
                              ((o = i < 3 ? u : o), (i = 1)),
                            n = nn(n);
                          ++e < i;

                        ) {
                          var f = r[e];
                          f && t(n, f, e, o);
                        }
                        return n;
                      });
                    }
                    function ou(t, n) {
                      return function (r, e) {
                        if (null == r) return r;
                        if (!wa(r)) return t(r, e);
                        for (
                          var i = r.length, u = n ? i : -1, o = nn(r);
                          (n ? u-- : ++u < i) && !1 !== e(o[u], u, o);

                        );
                        return r;
                      };
                    }
                    function au(t) {
                      return function (n, r, e) {
                        for (
                          var i = -1, u = nn(n), o = e(n), a = o.length;
                          a--;

                        ) {
                          var f = o[t ? a : ++i];
                          if (!1 === r(u[f], f, u)) break;
                        }
                        return n;
                      };
                    }
                    function fu(t) {
                      return function (n) {
                        var r = xr((n = Fa(n))) ? Dr(n) : u,
                          e = r ? r[0] : n.charAt(0),
                          i = r ? Vi(r, 1).join("") : n.slice(1);
                        return e[t]() + i;
                      };
                    }
                    function cu(t) {
                      return function (n) {
                        return rr(xf(df(n).replace(wn, "")), t, "");
                      };
                    }
                    function su(t) {
                      return function () {
                        var n = arguments;
                        switch (n.length) {
                          case 0:
                            return new t();
                          case 1:
                            return new t(n[0]);
                          case 2:
                            return new t(n[0], n[1]);
                          case 3:
                            return new t(n[0], n[1], n[2]);
                          case 4:
                            return new t(n[0], n[1], n[2], n[3]);
                          case 5:
                            return new t(n[0], n[1], n[2], n[3], n[4]);
                          case 6:
                            return new t(n[0], n[1], n[2], n[3], n[4], n[5]);
                          case 7:
                            return new t(
                              n[0],
                              n[1],
                              n[2],
                              n[3],
                              n[4],
                              n[5],
                              n[6]
                            );
                        }
                        var r = _e(t.prototype),
                          e = t.apply(r, n);
                        return ja(e) ? e : r;
                      };
                    }
                    function hu(t) {
                      return function (n, r, e) {
                        var i = nn(n);
                        if (!wa(n)) {
                          var o = Lu(r, 3);
                          (n = uf(n)),
                            (r = function (t) {
                              return o(i[t], t, i);
                            });
                        }
                        var a = t(n, r, e);
                        return a > -1 ? i[o ? n[a] : a] : u;
                      };
                    }
                    function lu(t) {
                      return Eu(function (n) {
                        var r = n.length,
                          e = r,
                          i = ye.prototype.thru;
                        for (t && n.reverse(); e--; ) {
                          var o = n[e];
                          if ("function" != typeof o) throw new un(f);
                          if (i && !a && "wrapper" == qu(o))
                            var a = new ye([], !0);
                        }
                        for (e = a ? e : r; ++e < r; ) {
                          var c = qu((o = n[e])),
                            s = "wrapper" == c ? Du(o) : u;
                          a =
                            s &&
                            Vu(s[0]) &&
                            s[1] == (z | m | S | x) &&
                            !s[4].length &&
                            1 == s[9]
                              ? a[qu(s[0])].apply(a, s[3])
                              : 1 == o.length && Vu(o)
                              ? a[c]()
                              : a.thru(o);
                        }
                        return function () {
                          var t = arguments,
                            e = t[0];
                          if (a && 1 == t.length && da(e))
                            return a.plant(e).value();
                          for (
                            var i = 0, u = r ? n[i].apply(this, t) : e;
                            ++i < r;

                          )
                            u = n[i].call(this, u);
                          return u;
                        };
                      });
                    }
                    function pu(t, n, r, i, o, a, f, c, s, h) {
                      var l = n & z,
                        p = n & d,
                        _ = n & g,
                        v = n & (m | b),
                        y = n & O,
                        w = _ ? u : su(t);
                      return function d() {
                        for (var g = arguments.length, m = e(g), b = g; b--; )
                          m[b] = arguments[b];
                        if (v)
                          var S = Ru(d),
                            I = (function (t, n) {
                              for (var r = t.length, e = 0; r--; )
                                t[r] === n && ++e;
                              return e;
                            })(m, S);
                        if (
                          (i && (m = tu(m, i, o, v)),
                          a && (m = nu(m, a, f, v)),
                          (g -= I),
                          v && g < h)
                        ) {
                          var z = Ar(m, S);
                          return mu(
                            t,
                            n,
                            pu,
                            d.placeholder,
                            r,
                            m,
                            z,
                            c,
                            s,
                            h - g
                          );
                        }
                        var x = p ? r : this,
                          O = _ ? x[t] : t;
                        return (
                          (g = m.length),
                          c
                            ? (m = (function (t, n) {
                                var r = t.length,
                                  e = Jr(n.length, r),
                                  i = ru(t);
                                for (; e--; ) {
                                  var o = n[e];
                                  t[e] = Fu(o, r) ? i[o] : u;
                                }
                                return t;
                              })(m, c))
                            : y && g > 1 && m.reverse(),
                          l && s < g && (m.length = s),
                          this &&
                            this !== Rn &&
                            this instanceof d &&
                            (O = w || su(O)),
                          O.apply(x, m)
                        );
                      };
                    }
                    function _u(t, n) {
                      return function (r, e) {
                        return (function (t, n, r, e) {
                          return (
                            He(t, function (t, i, u) {
                              n(e, r(t), i, u);
                            }),
                            e
                          );
                        })(r, t, n(e), {});
                      };
                    }
                    function vu(t, n) {
                      return function (r, e) {
                        var i;
                        if (r === u && e === u) return n;
                        if ((r !== u && (i = r), e !== u)) {
                          if (i === u) return e;
                          "string" == typeof r || "string" == typeof e
                            ? ((r = Ti(r)), (e = Ti(e)))
                            : ((r = Li(r)), (e = Li(e))),
                            (i = t(r, e));
                        }
                        return i;
                      };
                    }
                    function yu(t) {
                      return Eu(function (n) {
                        return (
                          (n = tr(n, dr(Lu()))),
                          Ii(function (r) {
                            var e = this;
                            return t(n, function (t) {
                              return Jn(t, e, r);
                            });
                          })
                        );
                      });
                    }
                    function du(t, n) {
                      var r = (n = n === u ? " " : Ti(n)).length;
                      if (r < 2) return r ? Si(n, t) : n;
                      var e = Si(n, Cr(t / Mr(n)));
                      return xr(n) ? Vi(Dr(e), 0, t).join("") : e.slice(0, t);
                    }
                    function gu(t) {
                      return function (n, r, i) {
                        return (
                          i &&
                            "number" != typeof i &&
                            Ju(n, r, i) &&
                            (r = i = u),
                          (n = Ba(n)),
                          r === u ? ((r = n), (n = 0)) : (r = Ba(r)),
                          (function (t, n, r, i) {
                            for (
                              var u = -1,
                                o = Fr(Cr((n - t) / (r || 1)), 0),
                                a = e(o);
                              o--;

                            )
                              (a[i ? o : ++u] = t), (t += r);
                            return a;
                          })(n, r, (i = i === u ? (n < r ? 1 : -1) : Ba(i)), t)
                        );
                      };
                    }
                    function wu(t) {
                      return function (n, r) {
                        return (
                          ("string" == typeof n && "string" == typeof r) ||
                            ((n = Na(n)), (r = Na(r))),
                          t(n, r)
                        );
                      };
                    }
                    function mu(t, n, r, e, i, o, a, f, c, s) {
                      var h = n & m;
                      (n |= h ? S : I),
                        (n &= ~(h ? I : S)) & w || (n &= ~(d | g));
                      var l = [
                          t,
                          n,
                          i,
                          h ? o : u,
                          h ? a : u,
                          h ? u : o,
                          h ? u : a,
                          f,
                          c,
                          s,
                        ],
                        p = r.apply(u, l);
                      return (
                        Vu(t) && ro(p, l), (p.placeholder = e), uo(p, t, n)
                      );
                    }
                    function bu(t) {
                      var n = tn[t];
                      return function (t, r) {
                        if (
                          ((t = Na(t)),
                          (r = null == r ? 0 : Jr(Ka(r), 292)) && Pr(t))
                        ) {
                          var e = (Fa(t) + "e").split("e");
                          return +(
                            (e = (Fa(n(e[0] + "e" + (+e[1] + r))) + "e").split(
                              "e"
                            ))[0] +
                            "e" +
                            (+e[1] - r)
                          );
                        }
                        return n(t);
                      };
                    }
                    var Su =
                      te && 1 / Er(new te([, -0]))[1] == q
                        ? function (t) {
                            return new te(t);
                          }
                        : Tf;
                    function Iu(t) {
                      return function (n) {
                        var r = Ku(n);
                        return r == G
                          ? Or(n)
                          : r == rt
                          ? kr(n)
                          : (function (t, n) {
                              return tr(n, function (n) {
                                return [n, t[n]];
                              });
                            })(n, t(n));
                      };
                    }
                    function zu(t, n, r, i, o, a, c, s) {
                      var l = n & g;
                      if (!l && "function" != typeof t) throw new un(f);
                      var p = i ? i.length : 0;
                      if (
                        (p || ((n &= ~(S | I)), (i = o = u)),
                        (c = c === u ? c : Fr(Ka(c), 0)),
                        (s = s === u ? s : Ka(s)),
                        (p -= o ? o.length : 0),
                        n & I)
                      ) {
                        var _ = i,
                          v = o;
                        i = o = u;
                      }
                      var y = l ? u : Du(t),
                        O = [t, n, r, i, o, _, v, a, c, s];
                      if (
                        (y &&
                          (function (t, n) {
                            var r = t[1],
                              e = n[1],
                              i = r | e,
                              u = i < (d | g | z),
                              o =
                                (e == z && r == m) ||
                                (e == z && r == x && t[7].length <= n[8]) ||
                                (e == (z | x) && n[7].length <= n[8] && r == m);
                            if (!u && !o) return t;
                            e & d && ((t[2] = n[2]), (i |= r & d ? 0 : w));
                            var a = n[3];
                            if (a) {
                              var f = t[3];
                              (t[3] = f ? tu(f, a, n[4]) : a),
                                (t[4] = f ? Ar(t[3], h) : n[4]);
                            }
                            (a = n[5]) &&
                              ((f = t[5]),
                              (t[5] = f ? nu(f, a, n[6]) : a),
                              (t[6] = f ? Ar(t[5], h) : n[6]));
                            (a = n[7]) && (t[7] = a);
                            e & z &&
                              (t[8] = null == t[8] ? n[8] : Jr(t[8], n[8]));
                            null == t[9] && (t[9] = n[9]);
                            (t[0] = n[0]), (t[1] = i);
                          })(O, y),
                        (t = O[0]),
                        (n = O[1]),
                        (r = O[2]),
                        (i = O[3]),
                        (o = O[4]),
                        !(s = O[9] =
                          O[9] === u ? (l ? 0 : t.length) : Fr(O[9] - p, 0)) &&
                          n & (m | b) &&
                          (n &= ~(m | b)),
                        n && n != d)
                      )
                        j =
                          n == m || n == b
                            ? (function (t, n, r) {
                                var i = su(t);
                                return function o() {
                                  for (
                                    var a = arguments.length,
                                      f = e(a),
                                      c = a,
                                      s = Ru(o);
                                    c--;

                                  )
                                    f[c] = arguments[c];
                                  var h =
                                    a < 3 && f[0] !== s && f[a - 1] !== s
                                      ? []
                                      : Ar(f, s);
                                  return (a -= h.length) < r
                                    ? mu(
                                        t,
                                        n,
                                        pu,
                                        o.placeholder,
                                        u,
                                        f,
                                        h,
                                        u,
                                        u,
                                        r - a
                                      )
                                    : Jn(
                                        this && this !== Rn && this instanceof o
                                          ? i
                                          : t,
                                        this,
                                        f
                                      );
                                };
                              })(t, n, s)
                            : (n != S && n != (d | S)) || o.length
                            ? pu.apply(u, O)
                            : (function (t, n, r, i) {
                                var u = n & d,
                                  o = su(t);
                                return function n() {
                                  for (
                                    var a = -1,
                                      f = arguments.length,
                                      c = -1,
                                      s = i.length,
                                      h = e(s + f),
                                      l =
                                        this && this !== Rn && this instanceof n
                                          ? o
                                          : t;
                                    ++c < s;

                                  )
                                    h[c] = i[c];
                                  for (; f--; ) h[c++] = arguments[++a];
                                  return Jn(l, u ? r : this, h);
                                };
                              })(t, n, r, i);
                      else
                        var j = (function (t, n, r) {
                          var e = n & d,
                            i = su(t);
                          return function n() {
                            return (this && this !== Rn && this instanceof n
                              ? i
                              : t
                            ).apply(e ? r : this, arguments);
                          };
                        })(t, n, r);
                      return uo((y ? ji : ro)(j, O), t, n);
                    }
                    function xu(t, n, r, e) {
                      return t === u || (pa(t, fn[r]) && !hn.call(e, r))
                        ? n
                        : t;
                    }
                    function Ou(t, n, r, e, i, o) {
                      return (
                        ja(t) &&
                          ja(n) &&
                          (o.set(n, t), vi(t, n, u, Ou, o), o.delete(n)),
                        t
                      );
                    }
                    function ju(t) {
                      return Ma(t) ? u : t;
                    }
                    function Au(t, n, r, e, i, o) {
                      var a = r & v,
                        f = t.length,
                        c = n.length;
                      if (f != c && !(a && c > f)) return !1;
                      var s = o.get(t);
                      if (s && o.get(n)) return s == n;
                      var h = -1,
                        l = !0,
                        p = r & y ? new be() : u;
                      for (o.set(t, n), o.set(n, t); ++h < f; ) {
                        var _ = t[h],
                          d = n[h];
                        if (e)
                          var g = a ? e(d, _, h, n, t, o) : e(_, d, h, t, n, o);
                        if (g !== u) {
                          if (g) continue;
                          l = !1;
                          break;
                        }
                        if (p) {
                          if (
                            !ir(n, function (t, n) {
                              if (!wr(p, n) && (_ === t || i(_, t, r, e, o)))
                                return p.push(n);
                            })
                          ) {
                            l = !1;
                            break;
                          }
                        } else if (_ !== d && !i(_, d, r, e, o)) {
                          l = !1;
                          break;
                        }
                      }
                      return o.delete(t), o.delete(n), l;
                    }
                    function Eu(t) {
                      return io(Qu(t, u, go), t + "");
                    }
                    function ku(t) {
                      return Ye(t, uf, Wu);
                    }
                    function Mu(t) {
                      return Ye(t, of, Bu);
                    }
                    var Du = ee
                      ? function (t) {
                          return ee.get(t);
                        }
                      : Tf;
                    function qu(t) {
                      for (
                        var n = t.name + "",
                          r = ie[n],
                          e = hn.call(ie, n) ? r.length : 0;
                        e--;

                      ) {
                        var i = r[e],
                          u = i.func;
                        if (null == u || u == t) return i.name;
                      }
                      return n;
                    }
                    function Ru(t) {
                      return (hn.call(pe, "placeholder") ? pe : t).placeholder;
                    }
                    function Lu() {
                      var t = pe.iteratee || Df;
                      return (
                        (t = t === Df ? fi : t),
                        arguments.length ? t(arguments[0], arguments[1]) : t
                      );
                    }
                    function Tu(t, n) {
                      var r,
                        e,
                        i = t.__data__;
                      return (
                        "string" == (e = typeof (r = n)) ||
                        "number" == e ||
                        "symbol" == e ||
                        "boolean" == e
                          ? "__proto__" !== r
                          : null === r
                      )
                        ? i["string" == typeof n ? "string" : "hash"]
                        : i.map;
                    }
                    function Uu(t) {
                      for (var n = uf(t), r = n.length; r--; ) {
                        var e = n[r],
                          i = t[e];
                        n[r] = [e, i, Yu(i)];
                      }
                      return n;
                    }
                    function Cu(t, n) {
                      var r = (function (t, n) {
                        return null == t ? u : t[n];
                      })(t, n);
                      return ai(r) ? r : u;
                    }
                    var Wu = Br
                        ? function (t) {
                            return null == t
                              ? []
                              : ((t = nn(t)),
                                Yn(Br(t), function (n) {
                                  return Ln.call(t, n);
                                }));
                          }
                        : Nf,
                      Bu = Br
                        ? function (t) {
                            for (var n = []; t; ) nr(n, Wu(t)), (t = Dn(t));
                            return n;
                          }
                        : Nf,
                      Ku = Xe;
                    function Pu(t, n, r) {
                      for (
                        var e = -1, i = (n = Ji(n, t)).length, u = !1;
                        ++e < i;

                      ) {
                        var o = co(n[e]);
                        if (!(u = null != t && r(t, o))) break;
                        t = t[o];
                      }
                      return u || ++e != i
                        ? u
                        : !!(i = null == t ? 0 : t.length) &&
                            Oa(i) &&
                            Fu(o, i) &&
                            (da(t) || ya(t));
                    }
                    function Nu(t) {
                      return "function" != typeof t.constructor || Gu(t)
                        ? {}
                        : _e(Dn(t));
                    }
                    function $u(t) {
                      return da(t) || ya(t) || !!(Cn && t && t[Cn]);
                    }
                    function Fu(t, n) {
                      var r = typeof t;
                      return (
                        !!(n = null == n ? R : n) &&
                        ("number" == r || ("symbol" != r && Vt.test(t))) &&
                        t > -1 &&
                        t % 1 == 0 &&
                        t < n
                      );
                    }
                    function Ju(t, n, r) {
                      if (!ja(r)) return !1;
                      var e = typeof n;
                      return (
                        !!("number" == e
                          ? wa(r) && Fu(n, r.length)
                          : "string" == e && n in r) && pa(r[n], t)
                      );
                    }
                    function Hu(t, n) {
                      if (da(t)) return !1;
                      var r = typeof t;
                      return (
                        !(
                          "number" != r &&
                          "symbol" != r &&
                          "boolean" != r &&
                          null != t &&
                          !La(t)
                        ) ||
                        kt.test(t) ||
                        !Et.test(t) ||
                        (null != n && t in nn(n))
                      );
                    }
                    function Vu(t) {
                      var n = qu(t),
                        r = pe[n];
                      if ("function" != typeof r || !(n in de.prototype))
                        return !1;
                      if (t === r) return !0;
                      var e = Du(r);
                      return !!e && t === e[0];
                    }
                    ((Yr && Ku(new Yr(new ArrayBuffer(1))) != ct) ||
                      (Xr && Ku(new Xr()) != G) ||
                      (Qr && "[object Promise]" != Ku(Qr.resolve())) ||
                      (te && Ku(new te()) != rt) ||
                      (ne && Ku(new ne()) != ot)) &&
                      (Ku = function (t) {
                        var n = Xe(t),
                          r = n == Q ? t.constructor : u,
                          e = r ? so(r) : "";
                        if (e)
                          switch (e) {
                            case ue:
                              return ct;
                            case oe:
                              return G;
                            case ae:
                              return "[object Promise]";
                            case fe:
                              return rt;
                            case ce:
                              return ot;
                          }
                        return n;
                      });
                    var Zu = cn ? za : $f;
                    function Gu(t) {
                      var n = t && t.constructor;
                      return (
                        t === (("function" == typeof n && n.prototype) || fn)
                      );
                    }
                    function Yu(t) {
                      return t == t && !ja(t);
                    }
                    function Xu(t, n) {
                      return function (r) {
                        return (
                          null != r && r[t] === n && (n !== u || t in nn(r))
                        );
                      };
                    }
                    function Qu(t, n, r) {
                      return (
                        (n = Fr(n === u ? t.length - 1 : n, 0)),
                        function () {
                          for (
                            var i = arguments,
                              u = -1,
                              o = Fr(i.length - n, 0),
                              a = e(o);
                            ++u < o;

                          )
                            a[u] = i[n + u];
                          u = -1;
                          for (var f = e(n + 1); ++u < n; ) f[u] = i[u];
                          return (f[n] = r(a)), Jn(t, this, f);
                        }
                      );
                    }
                    function to(t, n) {
                      return n.length < 2 ? t : Ge(t, ki(n, 0, -1));
                    }
                    function no(t, n) {
                      if (
                        ("constructor" !== n || "function" != typeof t[n]) &&
                        "__proto__" != n
                      )
                        return t[n];
                    }
                    var ro = oo(ji),
                      eo =
                        Ur ||
                        function (t, n) {
                          return Rn.setTimeout(t, n);
                        },
                      io = oo(Ai);
                    function uo(t, n, r) {
                      var e = n + "";
                      return io(
                        t,
                        (function (t, n) {
                          var r = n.length;
                          if (!r) return t;
                          var e = r - 1;
                          return (
                            (n[e] = (r > 1 ? "& " : "") + n[e]),
                            (n = n.join(r > 2 ? ", " : " ")),
                            t.replace(Ut, "{\n/* [wrapped with " + n + "] */\n")
                          );
                        })(
                          e,
                          (function (t, n) {
                            return (
                              Vn(B, function (r) {
                                var e = "_." + r[0];
                                n & r[1] && !Xn(t, e) && t.push(e);
                              }),
                              t.sort()
                            );
                          })(
                            (function (t) {
                              var n = t.match(Ct);
                              return n ? n[1].split(Wt) : [];
                            })(e),
                            r
                          )
                        )
                      );
                    }
                    function oo(t) {
                      var n = 0,
                        r = 0;
                      return function () {
                        var e = Hr(),
                          i = k - (e - r);
                        if (((r = e), i > 0)) {
                          if (++n >= E) return arguments[0];
                        } else n = 0;
                        return t.apply(u, arguments);
                      };
                    }
                    function ao(t, n) {
                      var r = -1,
                        e = t.length,
                        i = e - 1;
                      for (n = n === u ? e : n; ++r < n; ) {
                        var o = bi(r, i),
                          a = t[o];
                        (t[o] = t[r]), (t[r] = a);
                      }
                      return (t.length = n), t;
                    }
                    var fo = (function (t) {
                      var n = aa(t, function (t) {
                          return r.size === s && r.clear(), t;
                        }),
                        r = n.cache;
                      return n;
                    })(function (t) {
                      var n = [];
                      return (
                        46 === t.charCodeAt(0) && n.push(""),
                        t.replace(Mt, function (t, r, e, i) {
                          n.push(e ? i.replace(Kt, "$1") : r || t);
                        }),
                        n
                      );
                    });
                    function co(t) {
                      if ("string" == typeof t || La(t)) return t;
                      var n = t + "";
                      return "0" == n && 1 / t == -q ? "-0" : n;
                    }
                    function so(t) {
                      if (null != t) {
                        try {
                          return sn.call(t);
                        } catch (t) {}
                        try {
                          return t + "";
                        } catch (t) {}
                      }
                      return "";
                    }
                    function ho(t) {
                      if (t instanceof de) return t.clone();
                      var n = new ye(t.__wrapped__, t.__chain__);
                      return (
                        (n.__actions__ = ru(t.__actions__)),
                        (n.__index__ = t.__index__),
                        (n.__values__ = t.__values__),
                        n
                      );
                    }
                    var lo = Ii(function (t, n) {
                        return ma(t) ? Ce(t, $e(n, 1, ma, !0)) : [];
                      }),
                      po = Ii(function (t, n) {
                        var r = Io(n);
                        return (
                          ma(r) && (r = u),
                          ma(t) ? Ce(t, $e(n, 1, ma, !0), Lu(r, 2)) : []
                        );
                      }),
                      _o = Ii(function (t, n) {
                        var r = Io(n);
                        return (
                          ma(r) && (r = u),
                          ma(t) ? Ce(t, $e(n, 1, ma, !0), u, r) : []
                        );
                      });
                    function vo(t, n, r) {
                      var e = null == t ? 0 : t.length;
                      if (!e) return -1;
                      var i = null == r ? 0 : Ka(r);
                      return i < 0 && (i = Fr(e + i, 0)), ar(t, Lu(n, 3), i);
                    }
                    function yo(t, n, r) {
                      var e = null == t ? 0 : t.length;
                      if (!e) return -1;
                      var i = e - 1;
                      return (
                        r !== u &&
                          ((i = Ka(r)),
                          (i = r < 0 ? Fr(e + i, 0) : Jr(i, e - 1))),
                        ar(t, Lu(n, 3), i, !0)
                      );
                    }
                    function go(t) {
                      return (null == t ? 0 : t.length) ? $e(t, 1) : [];
                    }
                    function wo(t) {
                      return t && t.length ? t[0] : u;
                    }
                    var mo = Ii(function (t) {
                        var n = tr(t, $i);
                        return n.length && n[0] === t[0] ? ri(n) : [];
                      }),
                      bo = Ii(function (t) {
                        var n = Io(t),
                          r = tr(t, $i);
                        return (
                          n === Io(r) ? (n = u) : r.pop(),
                          r.length && r[0] === t[0] ? ri(r, Lu(n, 2)) : []
                        );
                      }),
                      So = Ii(function (t) {
                        var n = Io(t),
                          r = tr(t, $i);
                        return (
                          (n = "function" == typeof n ? n : u) && r.pop(),
                          r.length && r[0] === t[0] ? ri(r, u, n) : []
                        );
                      });
                    function Io(t) {
                      var n = null == t ? 0 : t.length;
                      return n ? t[n - 1] : u;
                    }
                    var zo = Ii(xo);
                    function xo(t, n) {
                      return t && t.length && n && n.length ? wi(t, n) : t;
                    }
                    var Oo = Eu(function (t, n) {
                      var r = null == t ? 0 : t.length,
                        e = qe(t, n);
                      return (
                        mi(
                          t,
                          tr(n, function (t) {
                            return Fu(t, r) ? +t : t;
                          }).sort(Qi)
                        ),
                        e
                      );
                    });
                    function jo(t) {
                      return null == t ? t : Gr.call(t);
                    }
                    var Ao = Ii(function (t) {
                        return Ui($e(t, 1, ma, !0));
                      }),
                      Eo = Ii(function (t) {
                        var n = Io(t);
                        return ma(n) && (n = u), Ui($e(t, 1, ma, !0), Lu(n, 2));
                      }),
                      ko = Ii(function (t) {
                        var n = Io(t);
                        return (
                          (n = "function" == typeof n ? n : u),
                          Ui($e(t, 1, ma, !0), u, n)
                        );
                      });
                    function Mo(t) {
                      if (!t || !t.length) return [];
                      var n = 0;
                      return (
                        (t = Yn(t, function (t) {
                          if (ma(t)) return (n = Fr(t.length, n)), !0;
                        })),
                        yr(n, function (n) {
                          return tr(t, lr(n));
                        })
                      );
                    }
                    function Do(t, n) {
                      if (!t || !t.length) return [];
                      var r = Mo(t);
                      return null == n
                        ? r
                        : tr(r, function (t) {
                            return Jn(n, u, t);
                          });
                    }
                    var qo = Ii(function (t, n) {
                        return ma(t) ? Ce(t, n) : [];
                      }),
                      Ro = Ii(function (t) {
                        return Pi(Yn(t, ma));
                      }),
                      Lo = Ii(function (t) {
                        var n = Io(t);
                        return ma(n) && (n = u), Pi(Yn(t, ma), Lu(n, 2));
                      }),
                      To = Ii(function (t) {
                        var n = Io(t);
                        return (
                          (n = "function" == typeof n ? n : u),
                          Pi(Yn(t, ma), u, n)
                        );
                      }),
                      Uo = Ii(Mo);
                    var Co = Ii(function (t) {
                      var n = t.length,
                        r = n > 1 ? t[n - 1] : u;
                      return (
                        (r = "function" == typeof r ? (t.pop(), r) : u),
                        Do(t, r)
                      );
                    });
                    function Wo(t) {
                      var n = pe(t);
                      return (n.__chain__ = !0), n;
                    }
                    function Bo(t, n) {
                      return n(t);
                    }
                    var Ko = Eu(function (t) {
                      var n = t.length,
                        r = n ? t[0] : 0,
                        e = this.__wrapped__,
                        i = function (n) {
                          return qe(n, t);
                        };
                      return !(n > 1 || this.__actions__.length) &&
                        e instanceof de &&
                        Fu(r)
                        ? ((e = e.slice(r, +r + (n ? 1 : 0))).__actions__.push({
                            func: Bo,
                            args: [i],
                            thisArg: u,
                          }),
                          new ye(e, this.__chain__).thru(function (t) {
                            return n && !t.length && t.push(u), t;
                          }))
                        : this.thru(i);
                    });
                    var Po = iu(function (t, n, r) {
                      hn.call(t, r) ? ++t[r] : De(t, r, 1);
                    });
                    var No = hu(vo),
                      $o = hu(yo);
                    function Fo(t, n) {
                      return (da(t) ? Vn : We)(t, Lu(n, 3));
                    }
                    function Jo(t, n) {
                      return (da(t) ? Zn : Be)(t, Lu(n, 3));
                    }
                    var Ho = iu(function (t, n, r) {
                      hn.call(t, r) ? t[r].push(n) : De(t, r, [n]);
                    });
                    var Vo = Ii(function (t, n, r) {
                        var i = -1,
                          u = "function" == typeof n,
                          o = wa(t) ? e(t.length) : [];
                        return (
                          We(t, function (t) {
                            o[++i] = u ? Jn(n, t, r) : ei(t, n, r);
                          }),
                          o
                        );
                      }),
                      Zo = iu(function (t, n, r) {
                        De(t, r, n);
                      });
                    function Go(t, n) {
                      return (da(t) ? tr : li)(t, Lu(n, 3));
                    }
                    var Yo = iu(
                      function (t, n, r) {
                        t[r ? 0 : 1].push(n);
                      },
                      function () {
                        return [[], []];
                      }
                    );
                    var Xo = Ii(function (t, n) {
                        if (null == t) return [];
                        var r = n.length;
                        return (
                          r > 1 && Ju(t, n[0], n[1])
                            ? (n = [])
                            : r > 2 && Ju(n[0], n[1], n[2]) && (n = [n[0]]),
                          di(t, $e(n, 1), [])
                        );
                      }),
                      Qo =
                        Tr ||
                        function () {
                          return Rn.Date.now();
                        };
                    function ta(t, n, r) {
                      return (
                        (n = r ? u : n),
                        (n = t && null == n ? t.length : n),
                        zu(t, z, u, u, u, u, n)
                      );
                    }
                    function na(t, n) {
                      var r;
                      if ("function" != typeof n) throw new un(f);
                      return (
                        (t = Ka(t)),
                        function () {
                          return (
                            --t > 0 && (r = n.apply(this, arguments)),
                            t <= 1 && (n = u),
                            r
                          );
                        }
                      );
                    }
                    var ra = Ii(function (t, n, r) {
                        var e = d;
                        if (r.length) {
                          var i = Ar(r, Ru(ra));
                          e |= S;
                        }
                        return zu(t, e, n, r, i);
                      }),
                      ea = Ii(function (t, n, r) {
                        var e = d | g;
                        if (r.length) {
                          var i = Ar(r, Ru(ea));
                          e |= S;
                        }
                        return zu(n, e, t, r, i);
                      });
                    function ia(t, n, r) {
                      var e,
                        i,
                        o,
                        a,
                        c,
                        s,
                        h = 0,
                        l = !1,
                        p = !1,
                        _ = !0;
                      if ("function" != typeof t) throw new un(f);
                      function v(n) {
                        var r = e,
                          o = i;
                        return (e = i = u), (h = n), (a = t.apply(o, r));
                      }
                      function y(t) {
                        var r = t - s;
                        return s === u || r >= n || r < 0 || (p && t - h >= o);
                      }
                      function d() {
                        var t = Qo();
                        if (y(t)) return g(t);
                        c = eo(
                          d,
                          (function (t) {
                            var r = n - (t - s);
                            return p ? Jr(r, o - (t - h)) : r;
                          })(t)
                        );
                      }
                      function g(t) {
                        return (c = u), _ && e ? v(t) : ((e = i = u), a);
                      }
                      function w() {
                        var t = Qo(),
                          r = y(t);
                        if (((e = arguments), (i = this), (s = t), r)) {
                          if (c === u)
                            return (function (t) {
                              return (h = t), (c = eo(d, n)), l ? v(t) : a;
                            })(s);
                          if (p) return Zi(c), (c = eo(d, n)), v(s);
                        }
                        return c === u && (c = eo(d, n)), a;
                      }
                      return (
                        (n = Na(n) || 0),
                        ja(r) &&
                          ((l = !!r.leading),
                          (o = (p = "maxWait" in r)
                            ? Fr(Na(r.maxWait) || 0, n)
                            : o),
                          (_ = "trailing" in r ? !!r.trailing : _)),
                        (w.cancel = function () {
                          c !== u && Zi(c), (h = 0), (e = s = i = c = u);
                        }),
                        (w.flush = function () {
                          return c === u ? a : g(Qo());
                        }),
                        w
                      );
                    }
                    var ua = Ii(function (t, n) {
                        return Ue(t, 1, n);
                      }),
                      oa = Ii(function (t, n, r) {
                        return Ue(t, Na(n) || 0, r);
                      });
                    function aa(t, n) {
                      if (
                        "function" != typeof t ||
                        (null != n && "function" != typeof n)
                      )
                        throw new un(f);
                      var r = function () {
                        var e = arguments,
                          i = n ? n.apply(this, e) : e[0],
                          u = r.cache;
                        if (u.has(i)) return u.get(i);
                        var o = t.apply(this, e);
                        return (r.cache = u.set(i, o) || u), o;
                      };
                      return (r.cache = new (aa.Cache || me)()), r;
                    }
                    function fa(t) {
                      if ("function" != typeof t) throw new un(f);
                      return function () {
                        var n = arguments;
                        switch (n.length) {
                          case 0:
                            return !t.call(this);
                          case 1:
                            return !t.call(this, n[0]);
                          case 2:
                            return !t.call(this, n[0], n[1]);
                          case 3:
                            return !t.call(this, n[0], n[1], n[2]);
                        }
                        return !t.apply(this, n);
                      };
                    }
                    aa.Cache = me;
                    var ca = Hi(function (t, n) {
                        var r = (n =
                          1 == n.length && da(n[0])
                            ? tr(n[0], dr(Lu()))
                            : tr($e(n, 1), dr(Lu()))).length;
                        return Ii(function (e) {
                          for (var i = -1, u = Jr(e.length, r); ++i < u; )
                            e[i] = n[i].call(this, e[i]);
                          return Jn(t, this, e);
                        });
                      }),
                      sa = Ii(function (t, n) {
                        var r = Ar(n, Ru(sa));
                        return zu(t, S, u, n, r);
                      }),
                      ha = Ii(function (t, n) {
                        var r = Ar(n, Ru(ha));
                        return zu(t, I, u, n, r);
                      }),
                      la = Eu(function (t, n) {
                        return zu(t, x, u, u, u, n);
                      });
                    function pa(t, n) {
                      return t === n || (t != t && n != n);
                    }
                    var _a = wu(Qe),
                      va = wu(function (t, n) {
                        return t >= n;
                      }),
                      ya = ii(
                        (function () {
                          return arguments;
                        })()
                      )
                        ? ii
                        : function (t) {
                            return (
                              Aa(t) &&
                              hn.call(t, "callee") &&
                              !Ln.call(t, "callee")
                            );
                          },
                      da = e.isArray,
                      ga = Bn
                        ? dr(Bn)
                        : function (t) {
                            return Aa(t) && Xe(t) == ft;
                          };
                    function wa(t) {
                      return null != t && Oa(t.length) && !za(t);
                    }
                    function ma(t) {
                      return Aa(t) && wa(t);
                    }
                    var ba = Kr || $f,
                      Sa = Kn
                        ? dr(Kn)
                        : function (t) {
                            return Aa(t) && Xe(t) == F;
                          };
                    function Ia(t) {
                      if (!Aa(t)) return !1;
                      var n = Xe(t);
                      return (
                        n == H ||
                        n == J ||
                        ("string" == typeof t.message &&
                          "string" == typeof t.name &&
                          !Ma(t))
                      );
                    }
                    function za(t) {
                      if (!ja(t)) return !1;
                      var n = Xe(t);
                      return n == V || n == Z || n == N || n == tt;
                    }
                    function xa(t) {
                      return "number" == typeof t && t == Ka(t);
                    }
                    function Oa(t) {
                      return (
                        "number" == typeof t && t > -1 && t % 1 == 0 && t <= R
                      );
                    }
                    function ja(t) {
                      var n = typeof t;
                      return null != t && ("object" == n || "function" == n);
                    }
                    function Aa(t) {
                      return null != t && "object" == typeof t;
                    }
                    var Ea = Pn
                      ? dr(Pn)
                      : function (t) {
                          return Aa(t) && Ku(t) == G;
                        };
                    function ka(t) {
                      return "number" == typeof t || (Aa(t) && Xe(t) == Y);
                    }
                    function Ma(t) {
                      if (!Aa(t) || Xe(t) != Q) return !1;
                      var n = Dn(t);
                      if (null === n) return !0;
                      var r = hn.call(n, "constructor") && n.constructor;
                      return (
                        "function" == typeof r &&
                        r instanceof r &&
                        sn.call(r) == vn
                      );
                    }
                    var Da = Nn
                      ? dr(Nn)
                      : function (t) {
                          return Aa(t) && Xe(t) == nt;
                        };
                    var qa = $n
                      ? dr($n)
                      : function (t) {
                          return Aa(t) && Ku(t) == rt;
                        };
                    function Ra(t) {
                      return (
                        "string" == typeof t || (!da(t) && Aa(t) && Xe(t) == et)
                      );
                    }
                    function La(t) {
                      return "symbol" == typeof t || (Aa(t) && Xe(t) == it);
                    }
                    var Ta = Fn
                      ? dr(Fn)
                      : function (t) {
                          return Aa(t) && Oa(t.length) && !!jn[Xe(t)];
                        };
                    var Ua = wu(hi),
                      Ca = wu(function (t, n) {
                        return t <= n;
                      });
                    function Wa(t) {
                      if (!t) return [];
                      if (wa(t)) return Ra(t) ? Dr(t) : ru(t);
                      if (Wn && t[Wn])
                        return (function (t) {
                          for (var n, r = []; !(n = t.next()).done; )
                            r.push(n.value);
                          return r;
                        })(t[Wn]());
                      var n = Ku(t);
                      return (n == G ? Or : n == rt ? Er : _f)(t);
                    }
                    function Ba(t) {
                      return t
                        ? (t = Na(t)) === q || t === -q
                          ? (t < 0 ? -1 : 1) * L
                          : t == t
                          ? t
                          : 0
                        : 0 === t
                        ? t
                        : 0;
                    }
                    function Ka(t) {
                      var n = Ba(t),
                        r = n % 1;
                      return n == n ? (r ? n - r : n) : 0;
                    }
                    function Pa(t) {
                      return t ? Re(Ka(t), 0, U) : 0;
                    }
                    function Na(t) {
                      if ("number" == typeof t) return t;
                      if (La(t)) return T;
                      if (ja(t)) {
                        var n =
                          "function" == typeof t.valueOf ? t.valueOf() : t;
                        t = ja(n) ? n + "" : n;
                      }
                      if ("string" != typeof t) return 0 === t ? t : +t;
                      t = t.replace(Rt, "");
                      var r = Ft.test(t);
                      return r || Ht.test(t)
                        ? Mn(t.slice(2), r ? 2 : 8)
                        : $t.test(t)
                        ? T
                        : +t;
                    }
                    function $a(t) {
                      return eu(t, of(t));
                    }
                    function Fa(t) {
                      return null == t ? "" : Ti(t);
                    }
                    var Ja = uu(function (t, n) {
                        if (Gu(n) || wa(n)) eu(n, uf(n), t);
                        else for (var r in n) hn.call(n, r) && Ae(t, r, n[r]);
                      }),
                      Ha = uu(function (t, n) {
                        eu(n, of(n), t);
                      }),
                      Va = uu(function (t, n, r, e) {
                        eu(n, of(n), t, e);
                      }),
                      Za = uu(function (t, n, r, e) {
                        eu(n, uf(n), t, e);
                      }),
                      Ga = Eu(qe);
                    var Ya = Ii(function (t, n) {
                        t = nn(t);
                        var r = -1,
                          e = n.length,
                          i = e > 2 ? n[2] : u;
                        for (i && Ju(n[0], n[1], i) && (e = 1); ++r < e; )
                          for (
                            var o = n[r], a = of(o), f = -1, c = a.length;
                            ++f < c;

                          ) {
                            var s = a[f],
                              h = t[s];
                            (h === u || (pa(h, fn[s]) && !hn.call(t, s))) &&
                              (t[s] = o[s]);
                          }
                        return t;
                      }),
                      Xa = Ii(function (t) {
                        return t.push(u, Ou), Jn(ff, u, t);
                      });
                    function Qa(t, n, r) {
                      var e = null == t ? u : Ge(t, n);
                      return e === u ? r : e;
                    }
                    function tf(t, n) {
                      return null != t && Pu(t, n, ni);
                    }
                    var nf = _u(function (t, n, r) {
                        null != n &&
                          "function" != typeof n.toString &&
                          (n = _n.call(n)),
                          (t[n] = r);
                      }, Af(Mf)),
                      rf = _u(function (t, n, r) {
                        null != n &&
                          "function" != typeof n.toString &&
                          (n = _n.call(n)),
                          hn.call(t, n) ? t[n].push(r) : (t[n] = [r]);
                      }, Lu),
                      ef = Ii(ei);
                    function uf(t) {
                      return wa(t) ? Ie(t) : ci(t);
                    }
                    function of(t) {
                      return wa(t) ? Ie(t, !0) : si(t);
                    }
                    var af = uu(function (t, n, r) {
                        vi(t, n, r);
                      }),
                      ff = uu(function (t, n, r, e) {
                        vi(t, n, r, e);
                      }),
                      cf = Eu(function (t, n) {
                        var r = {};
                        if (null == t) return r;
                        var e = !1;
                        (n = tr(n, function (n) {
                          return (n = Ji(n, t)), e || (e = n.length > 1), n;
                        })),
                          eu(t, Mu(t), r),
                          e && (r = Le(r, l | p | _, ju));
                        for (var i = n.length; i--; ) Ci(r, n[i]);
                        return r;
                      });
                    var sf = Eu(function (t, n) {
                      return null == t
                        ? {}
                        : (function (t, n) {
                            return gi(t, n, function (n, r) {
                              return tf(t, r);
                            });
                          })(t, n);
                    });
                    function hf(t, n) {
                      if (null == t) return {};
                      var r = tr(Mu(t), function (t) {
                        return [t];
                      });
                      return (
                        (n = Lu(n)),
                        gi(t, r, function (t, r) {
                          return n(t, r[0]);
                        })
                      );
                    }
                    var lf = Iu(uf),
                      pf = Iu(of);
                    function _f(t) {
                      return null == t ? [] : gr(t, uf(t));
                    }
                    var vf = cu(function (t, n, r) {
                      return (n = n.toLowerCase()), t + (r ? yf(n) : n);
                    });
                    function yf(t) {
                      return zf(Fa(t).toLowerCase());
                    }
                    function df(t) {
                      return (t = Fa(t)) && t.replace(Zt, Sr).replace(mn, "");
                    }
                    var gf = cu(function (t, n, r) {
                        return t + (r ? "-" : "") + n.toLowerCase();
                      }),
                      wf = cu(function (t, n, r) {
                        return t + (r ? " " : "") + n.toLowerCase();
                      }),
                      mf = fu("toLowerCase");
                    var bf = cu(function (t, n, r) {
                      return t + (r ? "_" : "") + n.toLowerCase();
                    });
                    var Sf = cu(function (t, n, r) {
                      return t + (r ? " " : "") + zf(n);
                    });
                    var If = cu(function (t, n, r) {
                        return t + (r ? " " : "") + n.toUpperCase();
                      }),
                      zf = fu("toUpperCase");
                    function xf(t, n, r) {
                      return (
                        (t = Fa(t)),
                        (n = r ? u : n) === u
                          ? (function (t) {
                              return zn.test(t);
                            })(t)
                            ? (function (t) {
                                return t.match(Sn) || [];
                              })(t)
                            : (function (t) {
                                return t.match(Bt) || [];
                              })(t)
                          : t.match(n) || []
                      );
                    }
                    var Of = Ii(function (t, n) {
                        try {
                          return Jn(t, u, n);
                        } catch (t) {
                          return Ia(t) ? t : new Xt(t);
                        }
                      }),
                      jf = Eu(function (t, n) {
                        return (
                          Vn(n, function (n) {
                            (n = co(n)), De(t, n, ra(t[n], t));
                          }),
                          t
                        );
                      });
                    function Af(t) {
                      return function () {
                        return t;
                      };
                    }
                    var Ef = lu(),
                      kf = lu(!0);
                    function Mf(t) {
                      return t;
                    }
                    function Df(t) {
                      return fi("function" == typeof t ? t : Le(t, l));
                    }
                    var qf = Ii(function (t, n) {
                        return function (r) {
                          return ei(r, t, n);
                        };
                      }),
                      Rf = Ii(function (t, n) {
                        return function (r) {
                          return ei(t, r, n);
                        };
                      });
                    function Lf(t, n, r) {
                      var e = uf(n),
                        i = Ze(n, e);
                      null != r ||
                        (ja(n) && (i.length || !e.length)) ||
                        ((r = n), (n = t), (t = this), (i = Ze(n, uf(n))));
                      var u = !(ja(r) && "chain" in r && !r.chain),
                        o = za(t);
                      return (
                        Vn(i, function (r) {
                          var e = n[r];
                          (t[r] = e),
                            o &&
                              (t.prototype[r] = function () {
                                var n = this.__chain__;
                                if (u || n) {
                                  var r = t(this.__wrapped__),
                                    i = (r.__actions__ = ru(this.__actions__));
                                  return (
                                    i.push({
                                      func: e,
                                      args: arguments,
                                      thisArg: t,
                                    }),
                                    (r.__chain__ = n),
                                    r
                                  );
                                }
                                return e.apply(
                                  t,
                                  nr([this.value()], arguments)
                                );
                              });
                        }),
                        t
                      );
                    }
                    function Tf() {}
                    var Uf = yu(tr),
                      Cf = yu(Gn),
                      Wf = yu(ir);
                    function Bf(t) {
                      return Hu(t)
                        ? lr(co(t))
                        : (function (t) {
                            return function (n) {
                              return Ge(n, t);
                            };
                          })(t);
                    }
                    var Kf = gu(),
                      Pf = gu(!0);
                    function Nf() {
                      return [];
                    }
                    function $f() {
                      return !1;
                    }
                    var Ff = vu(function (t, n) {
                        return t + n;
                      }, 0),
                      Jf = bu("ceil"),
                      Hf = vu(function (t, n) {
                        return t / n;
                      }, 1),
                      Vf = bu("floor");
                    var Zf,
                      Gf = vu(function (t, n) {
                        return t * n;
                      }, 1),
                      Yf = bu("round"),
                      Xf = vu(function (t, n) {
                        return t - n;
                      }, 0);
                    return (
                      (pe.after = function (t, n) {
                        if ("function" != typeof n) throw new un(f);
                        return (
                          (t = Ka(t)),
                          function () {
                            if (--t < 1) return n.apply(this, arguments);
                          }
                        );
                      }),
                      (pe.ary = ta),
                      (pe.assign = Ja),
                      (pe.assignIn = Ha),
                      (pe.assignInWith = Va),
                      (pe.assignWith = Za),
                      (pe.at = Ga),
                      (pe.before = na),
                      (pe.bind = ra),
                      (pe.bindAll = jf),
                      (pe.bindKey = ea),
                      (pe.castArray = function () {
                        if (!arguments.length) return [];
                        var t = arguments[0];
                        return da(t) ? t : [t];
                      }),
                      (pe.chain = Wo),
                      (pe.chunk = function (t, n, r) {
                        n = (r ? Ju(t, n, r) : n === u) ? 1 : Fr(Ka(n), 0);
                        var i = null == t ? 0 : t.length;
                        if (!i || n < 1) return [];
                        for (var o = 0, a = 0, f = e(Cr(i / n)); o < i; )
                          f[a++] = ki(t, o, (o += n));
                        return f;
                      }),
                      (pe.compact = function (t) {
                        for (
                          var n = -1,
                            r = null == t ? 0 : t.length,
                            e = 0,
                            i = [];
                          ++n < r;

                        ) {
                          var u = t[n];
                          u && (i[e++] = u);
                        }
                        return i;
                      }),
                      (pe.concat = function () {
                        var t = arguments.length;
                        if (!t) return [];
                        for (var n = e(t - 1), r = arguments[0], i = t; i--; )
                          n[i - 1] = arguments[i];
                        return nr(da(r) ? ru(r) : [r], $e(n, 1));
                      }),
                      (pe.cond = function (t) {
                        var n = null == t ? 0 : t.length,
                          r = Lu();
                        return (
                          (t = n
                            ? tr(t, function (t) {
                                if ("function" != typeof t[1]) throw new un(f);
                                return [r(t[0]), t[1]];
                              })
                            : []),
                          Ii(function (r) {
                            for (var e = -1; ++e < n; ) {
                              var i = t[e];
                              if (Jn(i[0], this, r)) return Jn(i[1], this, r);
                            }
                          })
                        );
                      }),
                      (pe.conforms = function (t) {
                        return (function (t) {
                          var n = uf(t);
                          return function (r) {
                            return Te(r, t, n);
                          };
                        })(Le(t, l));
                      }),
                      (pe.constant = Af),
                      (pe.countBy = Po),
                      (pe.create = function (t, n) {
                        var r = _e(t);
                        return null == n ? r : Me(r, n);
                      }),
                      (pe.curry = function t(n, r, e) {
                        var i = zu(n, m, u, u, u, u, u, (r = e ? u : r));
                        return (i.placeholder = t.placeholder), i;
                      }),
                      (pe.curryRight = function t(n, r, e) {
                        var i = zu(n, b, u, u, u, u, u, (r = e ? u : r));
                        return (i.placeholder = t.placeholder), i;
                      }),
                      (pe.debounce = ia),
                      (pe.defaults = Ya),
                      (pe.defaultsDeep = Xa),
                      (pe.defer = ua),
                      (pe.delay = oa),
                      (pe.difference = lo),
                      (pe.differenceBy = po),
                      (pe.differenceWith = _o),
                      (pe.drop = function (t, n, r) {
                        var e = null == t ? 0 : t.length;
                        return e
                          ? ki(t, (n = r || n === u ? 1 : Ka(n)) < 0 ? 0 : n, e)
                          : [];
                      }),
                      (pe.dropRight = function (t, n, r) {
                        var e = null == t ? 0 : t.length;
                        return e
                          ? ki(
                              t,
                              0,
                              (n = e - (n = r || n === u ? 1 : Ka(n))) < 0
                                ? 0
                                : n
                            )
                          : [];
                      }),
                      (pe.dropRightWhile = function (t, n) {
                        return t && t.length ? Bi(t, Lu(n, 3), !0, !0) : [];
                      }),
                      (pe.dropWhile = function (t, n) {
                        return t && t.length ? Bi(t, Lu(n, 3), !0) : [];
                      }),
                      (pe.fill = function (t, n, r, e) {
                        var i = null == t ? 0 : t.length;
                        return i
                          ? (r &&
                              "number" != typeof r &&
                              Ju(t, n, r) &&
                              ((r = 0), (e = i)),
                            (function (t, n, r, e) {
                              var i = t.length;
                              for (
                                (r = Ka(r)) < 0 && (r = -r > i ? 0 : i + r),
                                  (e = e === u || e > i ? i : Ka(e)) < 0 &&
                                    (e += i),
                                  e = r > e ? 0 : Pa(e);
                                r < e;

                              )
                                t[r++] = n;
                              return t;
                            })(t, n, r, e))
                          : [];
                      }),
                      (pe.filter = function (t, n) {
                        return (da(t) ? Yn : Ne)(t, Lu(n, 3));
                      }),
                      (pe.flatMap = function (t, n) {
                        return $e(Go(t, n), 1);
                      }),
                      (pe.flatMapDeep = function (t, n) {
                        return $e(Go(t, n), q);
                      }),
                      (pe.flatMapDepth = function (t, n, r) {
                        return (r = r === u ? 1 : Ka(r)), $e(Go(t, n), r);
                      }),
                      (pe.flatten = go),
                      (pe.flattenDeep = function (t) {
                        return (null == t ? 0 : t.length) ? $e(t, q) : [];
                      }),
                      (pe.flattenDepth = function (t, n) {
                        return (null == t ? 0 : t.length)
                          ? $e(t, (n = n === u ? 1 : Ka(n)))
                          : [];
                      }),
                      (pe.flip = function (t) {
                        return zu(t, O);
                      }),
                      (pe.flow = Ef),
                      (pe.flowRight = kf),
                      (pe.fromPairs = function (t) {
                        for (
                          var n = -1, r = null == t ? 0 : t.length, e = {};
                          ++n < r;

                        ) {
                          var i = t[n];
                          e[i[0]] = i[1];
                        }
                        return e;
                      }),
                      (pe.functions = function (t) {
                        return null == t ? [] : Ze(t, uf(t));
                      }),
                      (pe.functionsIn = function (t) {
                        return null == t ? [] : Ze(t, of(t));
                      }),
                      (pe.groupBy = Ho),
                      (pe.initial = function (t) {
                        return (null == t ? 0 : t.length) ? ki(t, 0, -1) : [];
                      }),
                      (pe.intersection = mo),
                      (pe.intersectionBy = bo),
                      (pe.intersectionWith = So),
                      (pe.invert = nf),
                      (pe.invertBy = rf),
                      (pe.invokeMap = Vo),
                      (pe.iteratee = Df),
                      (pe.keyBy = Zo),
                      (pe.keys = uf),
                      (pe.keysIn = of),
                      (pe.map = Go),
                      (pe.mapKeys = function (t, n) {
                        var r = {};
                        return (
                          (n = Lu(n, 3)),
                          He(t, function (t, e, i) {
                            De(r, n(t, e, i), t);
                          }),
                          r
                        );
                      }),
                      (pe.mapValues = function (t, n) {
                        var r = {};
                        return (
                          (n = Lu(n, 3)),
                          He(t, function (t, e, i) {
                            De(r, e, n(t, e, i));
                          }),
                          r
                        );
                      }),
                      (pe.matches = function (t) {
                        return pi(Le(t, l));
                      }),
                      (pe.matchesProperty = function (t, n) {
                        return _i(t, Le(n, l));
                      }),
                      (pe.memoize = aa),
                      (pe.merge = af),
                      (pe.mergeWith = ff),
                      (pe.method = qf),
                      (pe.methodOf = Rf),
                      (pe.mixin = Lf),
                      (pe.negate = fa),
                      (pe.nthArg = function (t) {
                        return (
                          (t = Ka(t)),
                          Ii(function (n) {
                            return yi(n, t);
                          })
                        );
                      }),
                      (pe.omit = cf),
                      (pe.omitBy = function (t, n) {
                        return hf(t, fa(Lu(n)));
                      }),
                      (pe.once = function (t) {
                        return na(2, t);
                      }),
                      (pe.orderBy = function (t, n, r, e) {
                        return null == t
                          ? []
                          : (da(n) || (n = null == n ? [] : [n]),
                            da((r = e ? u : r)) || (r = null == r ? [] : [r]),
                            di(t, n, r));
                      }),
                      (pe.over = Uf),
                      (pe.overArgs = ca),
                      (pe.overEvery = Cf),
                      (pe.overSome = Wf),
                      (pe.partial = sa),
                      (pe.partialRight = ha),
                      (pe.partition = Yo),
                      (pe.pick = sf),
                      (pe.pickBy = hf),
                      (pe.property = Bf),
                      (pe.propertyOf = function (t) {
                        return function (n) {
                          return null == t ? u : Ge(t, n);
                        };
                      }),
                      (pe.pull = zo),
                      (pe.pullAll = xo),
                      (pe.pullAllBy = function (t, n, r) {
                        return t && t.length && n && n.length
                          ? wi(t, n, Lu(r, 2))
                          : t;
                      }),
                      (pe.pullAllWith = function (t, n, r) {
                        return t && t.length && n && n.length
                          ? wi(t, n, u, r)
                          : t;
                      }),
                      (pe.pullAt = Oo),
                      (pe.range = Kf),
                      (pe.rangeRight = Pf),
                      (pe.rearg = la),
                      (pe.reject = function (t, n) {
                        return (da(t) ? Yn : Ne)(t, fa(Lu(n, 3)));
                      }),
                      (pe.remove = function (t, n) {
                        var r = [];
                        if (!t || !t.length) return r;
                        var e = -1,
                          i = [],
                          u = t.length;
                        for (n = Lu(n, 3); ++e < u; ) {
                          var o = t[e];
                          n(o, e, t) && (r.push(o), i.push(e));
                        }
                        return mi(t, i), r;
                      }),
                      (pe.rest = function (t, n) {
                        if ("function" != typeof t) throw new un(f);
                        return Ii(t, (n = n === u ? n : Ka(n)));
                      }),
                      (pe.reverse = jo),
                      (pe.sampleSize = function (t, n, r) {
                        return (
                          (n = (r ? Ju(t, n, r) : n === u) ? 1 : Ka(n)),
                          (da(t) ? xe : xi)(t, n)
                        );
                      }),
                      (pe.set = function (t, n, r) {
                        return null == t ? t : Oi(t, n, r);
                      }),
                      (pe.setWith = function (t, n, r, e) {
                        return (
                          (e = "function" == typeof e ? e : u),
                          null == t ? t : Oi(t, n, r, e)
                        );
                      }),
                      (pe.shuffle = function (t) {
                        return (da(t) ? Oe : Ei)(t);
                      }),
                      (pe.slice = function (t, n, r) {
                        var e = null == t ? 0 : t.length;
                        return e
                          ? (r && "number" != typeof r && Ju(t, n, r)
                              ? ((n = 0), (r = e))
                              : ((n = null == n ? 0 : Ka(n)),
                                (r = r === u ? e : Ka(r))),
                            ki(t, n, r))
                          : [];
                      }),
                      (pe.sortBy = Xo),
                      (pe.sortedUniq = function (t) {
                        return t && t.length ? Ri(t) : [];
                      }),
                      (pe.sortedUniqBy = function (t, n) {
                        return t && t.length ? Ri(t, Lu(n, 2)) : [];
                      }),
                      (pe.split = function (t, n, r) {
                        return (
                          r &&
                            "number" != typeof r &&
                            Ju(t, n, r) &&
                            (n = r = u),
                          (r = r === u ? U : r >>> 0)
                            ? (t = Fa(t)) &&
                              ("string" == typeof n || (null != n && !Da(n))) &&
                              !(n = Ti(n)) &&
                              xr(t)
                              ? Vi(Dr(t), 0, r)
                              : t.split(n, r)
                            : []
                        );
                      }),
                      (pe.spread = function (t, n) {
                        if ("function" != typeof t) throw new un(f);
                        return (
                          (n = null == n ? 0 : Fr(Ka(n), 0)),
                          Ii(function (r) {
                            var e = r[n],
                              i = Vi(r, 0, n);
                            return e && nr(i, e), Jn(t, this, i);
                          })
                        );
                      }),
                      (pe.tail = function (t) {
                        var n = null == t ? 0 : t.length;
                        return n ? ki(t, 1, n) : [];
                      }),
                      (pe.take = function (t, n, r) {
                        return t && t.length
                          ? ki(t, 0, (n = r || n === u ? 1 : Ka(n)) < 0 ? 0 : n)
                          : [];
                      }),
                      (pe.takeRight = function (t, n, r) {
                        var e = null == t ? 0 : t.length;
                        return e
                          ? ki(
                              t,
                              (n = e - (n = r || n === u ? 1 : Ka(n))) < 0
                                ? 0
                                : n,
                              e
                            )
                          : [];
                      }),
                      (pe.takeRightWhile = function (t, n) {
                        return t && t.length ? Bi(t, Lu(n, 3), !1, !0) : [];
                      }),
                      (pe.takeWhile = function (t, n) {
                        return t && t.length ? Bi(t, Lu(n, 3)) : [];
                      }),
                      (pe.tap = function (t, n) {
                        return n(t), t;
                      }),
                      (pe.throttle = function (t, n, r) {
                        var e = !0,
                          i = !0;
                        if ("function" != typeof t) throw new un(f);
                        return (
                          ja(r) &&
                            ((e = "leading" in r ? !!r.leading : e),
                            (i = "trailing" in r ? !!r.trailing : i)),
                          ia(t, n, { leading: e, maxWait: n, trailing: i })
                        );
                      }),
                      (pe.thru = Bo),
                      (pe.toArray = Wa),
                      (pe.toPairs = lf),
                      (pe.toPairsIn = pf),
                      (pe.toPath = function (t) {
                        return da(t) ? tr(t, co) : La(t) ? [t] : ru(fo(Fa(t)));
                      }),
                      (pe.toPlainObject = $a),
                      (pe.transform = function (t, n, r) {
                        var e = da(t),
                          i = e || ba(t) || Ta(t);
                        if (((n = Lu(n, 4)), null == r)) {
                          var u = t && t.constructor;
                          r = i
                            ? e
                              ? new u()
                              : []
                            : ja(t) && za(u)
                            ? _e(Dn(t))
                            : {};
                        }
                        return (
                          (i ? Vn : He)(t, function (t, e, i) {
                            return n(r, t, e, i);
                          }),
                          r
                        );
                      }),
                      (pe.unary = function (t) {
                        return ta(t, 1);
                      }),
                      (pe.union = Ao),
                      (pe.unionBy = Eo),
                      (pe.unionWith = ko),
                      (pe.uniq = function (t) {
                        return t && t.length ? Ui(t) : [];
                      }),
                      (pe.uniqBy = function (t, n) {
                        return t && t.length ? Ui(t, Lu(n, 2)) : [];
                      }),
                      (pe.uniqWith = function (t, n) {
                        return (
                          (n = "function" == typeof n ? n : u),
                          t && t.length ? Ui(t, u, n) : []
                        );
                      }),
                      (pe.unset = function (t, n) {
                        return null == t || Ci(t, n);
                      }),
                      (pe.unzip = Mo),
                      (pe.unzipWith = Do),
                      (pe.update = function (t, n, r) {
                        return null == t ? t : Wi(t, n, Fi(r));
                      }),
                      (pe.updateWith = function (t, n, r, e) {
                        return (
                          (e = "function" == typeof e ? e : u),
                          null == t ? t : Wi(t, n, Fi(r), e)
                        );
                      }),
                      (pe.values = _f),
                      (pe.valuesIn = function (t) {
                        return null == t ? [] : gr(t, of(t));
                      }),
                      (pe.without = qo),
                      (pe.words = xf),
                      (pe.wrap = function (t, n) {
                        return sa(Fi(n), t);
                      }),
                      (pe.xor = Ro),
                      (pe.xorBy = Lo),
                      (pe.xorWith = To),
                      (pe.zip = Uo),
                      (pe.zipObject = function (t, n) {
                        return Ni(t || [], n || [], Ae);
                      }),
                      (pe.zipObjectDeep = function (t, n) {
                        return Ni(t || [], n || [], Oi);
                      }),
                      (pe.zipWith = Co),
                      (pe.entries = lf),
                      (pe.entriesIn = pf),
                      (pe.extend = Ha),
                      (pe.extendWith = Va),
                      Lf(pe, pe),
                      (pe.add = Ff),
                      (pe.attempt = Of),
                      (pe.camelCase = vf),
                      (pe.capitalize = yf),
                      (pe.ceil = Jf),
                      (pe.clamp = function (t, n, r) {
                        return (
                          r === u && ((r = n), (n = u)),
                          r !== u && (r = (r = Na(r)) == r ? r : 0),
                          n !== u && (n = (n = Na(n)) == n ? n : 0),
                          Re(Na(t), n, r)
                        );
                      }),
                      (pe.clone = function (t) {
                        return Le(t, _);
                      }),
                      (pe.cloneDeep = function (t) {
                        return Le(t, l | _);
                      }),
                      (pe.cloneDeepWith = function (t, n) {
                        return Le(
                          t,
                          l | _,
                          (n = "function" == typeof n ? n : u)
                        );
                      }),
                      (pe.cloneWith = function (t, n) {
                        return Le(t, _, (n = "function" == typeof n ? n : u));
                      }),
                      (pe.conformsTo = function (t, n) {
                        return null == n || Te(t, n, uf(n));
                      }),
                      (pe.deburr = df),
                      (pe.defaultTo = function (t, n) {
                        return null == t || t != t ? n : t;
                      }),
                      (pe.divide = Hf),
                      (pe.endsWith = function (t, n, r) {
                        (t = Fa(t)), (n = Ti(n));
                        var e = t.length,
                          i = (r = r === u ? e : Re(Ka(r), 0, e));
                        return (r -= n.length) >= 0 && t.slice(r, i) == n;
                      }),
                      (pe.eq = pa),
                      (pe.escape = function (t) {
                        return (t = Fa(t)) && xt.test(t)
                          ? t.replace(It, Ir)
                          : t;
                      }),
                      (pe.escapeRegExp = function (t) {
                        return (t = Fa(t)) && qt.test(t)
                          ? t.replace(Dt, "\\$&")
                          : t;
                      }),
                      (pe.every = function (t, n, r) {
                        var e = da(t) ? Gn : Ke;
                        return r && Ju(t, n, r) && (n = u), e(t, Lu(n, 3));
                      }),
                      (pe.find = No),
                      (pe.findIndex = vo),
                      (pe.findKey = function (t, n) {
                        return or(t, Lu(n, 3), He);
                      }),
                      (pe.findLast = $o),
                      (pe.findLastIndex = yo),
                      (pe.findLastKey = function (t, n) {
                        return or(t, Lu(n, 3), Ve);
                      }),
                      (pe.floor = Vf),
                      (pe.forEach = Fo),
                      (pe.forEachRight = Jo),
                      (pe.forIn = function (t, n) {
                        return null == t ? t : Fe(t, Lu(n, 3), of);
                      }),
                      (pe.forInRight = function (t, n) {
                        return null == t ? t : Je(t, Lu(n, 3), of);
                      }),
                      (pe.forOwn = function (t, n) {
                        return t && He(t, Lu(n, 3));
                      }),
                      (pe.forOwnRight = function (t, n) {
                        return t && Ve(t, Lu(n, 3));
                      }),
                      (pe.get = Qa),
                      (pe.gt = _a),
                      (pe.gte = va),
                      (pe.has = function (t, n) {
                        return null != t && Pu(t, n, ti);
                      }),
                      (pe.hasIn = tf),
                      (pe.head = wo),
                      (pe.identity = Mf),
                      (pe.includes = function (t, n, r, e) {
                        (t = wa(t) ? t : _f(t)), (r = r && !e ? Ka(r) : 0);
                        var i = t.length;
                        return (
                          r < 0 && (r = Fr(i + r, 0)),
                          Ra(t)
                            ? r <= i && t.indexOf(n, r) > -1
                            : !!i && fr(t, n, r) > -1
                        );
                      }),
                      (pe.indexOf = function (t, n, r) {
                        var e = null == t ? 0 : t.length;
                        if (!e) return -1;
                        var i = null == r ? 0 : Ka(r);
                        return i < 0 && (i = Fr(e + i, 0)), fr(t, n, i);
                      }),
                      (pe.inRange = function (t, n, r) {
                        return (
                          (n = Ba(n)),
                          r === u ? ((r = n), (n = 0)) : (r = Ba(r)),
                          (function (t, n, r) {
                            return t >= Jr(n, r) && t < Fr(n, r);
                          })((t = Na(t)), n, r)
                        );
                      }),
                      (pe.invoke = ef),
                      (pe.isArguments = ya),
                      (pe.isArray = da),
                      (pe.isArrayBuffer = ga),
                      (pe.isArrayLike = wa),
                      (pe.isArrayLikeObject = ma),
                      (pe.isBoolean = function (t) {
                        return !0 === t || !1 === t || (Aa(t) && Xe(t) == $);
                      }),
                      (pe.isBuffer = ba),
                      (pe.isDate = Sa),
                      (pe.isElement = function (t) {
                        return Aa(t) && 1 === t.nodeType && !Ma(t);
                      }),
                      (pe.isEmpty = function (t) {
                        if (null == t) return !0;
                        if (
                          wa(t) &&
                          (da(t) ||
                            "string" == typeof t ||
                            "function" == typeof t.splice ||
                            ba(t) ||
                            Ta(t) ||
                            ya(t))
                        )
                          return !t.length;
                        var n = Ku(t);
                        if (n == G || n == rt) return !t.size;
                        if (Gu(t)) return !ci(t).length;
                        for (var r in t) if (hn.call(t, r)) return !1;
                        return !0;
                      }),
                      (pe.isEqual = function (t, n) {
                        return ui(t, n);
                      }),
                      (pe.isEqualWith = function (t, n, r) {
                        var e = (r = "function" == typeof r ? r : u)
                          ? r(t, n)
                          : u;
                        return e === u ? ui(t, n, u, r) : !!e;
                      }),
                      (pe.isError = Ia),
                      (pe.isFinite = function (t) {
                        return "number" == typeof t && Pr(t);
                      }),
                      (pe.isFunction = za),
                      (pe.isInteger = xa),
                      (pe.isLength = Oa),
                      (pe.isMap = Ea),
                      (pe.isMatch = function (t, n) {
                        return t === n || oi(t, n, Uu(n));
                      }),
                      (pe.isMatchWith = function (t, n, r) {
                        return (
                          (r = "function" == typeof r ? r : u),
                          oi(t, n, Uu(n), r)
                        );
                      }),
                      (pe.isNaN = function (t) {
                        return ka(t) && t != +t;
                      }),
                      (pe.isNative = function (t) {
                        if (Zu(t)) throw new Xt(a);
                        return ai(t);
                      }),
                      (pe.isNil = function (t) {
                        return null == t;
                      }),
                      (pe.isNull = function (t) {
                        return null === t;
                      }),
                      (pe.isNumber = ka),
                      (pe.isObject = ja),
                      (pe.isObjectLike = Aa),
                      (pe.isPlainObject = Ma),
                      (pe.isRegExp = Da),
                      (pe.isSafeInteger = function (t) {
                        return xa(t) && t >= -R && t <= R;
                      }),
                      (pe.isSet = qa),
                      (pe.isString = Ra),
                      (pe.isSymbol = La),
                      (pe.isTypedArray = Ta),
                      (pe.isUndefined = function (t) {
                        return t === u;
                      }),
                      (pe.isWeakMap = function (t) {
                        return Aa(t) && Ku(t) == ot;
                      }),
                      (pe.isWeakSet = function (t) {
                        return Aa(t) && Xe(t) == at;
                      }),
                      (pe.join = function (t, n) {
                        return null == t ? "" : Nr.call(t, n);
                      }),
                      (pe.kebabCase = gf),
                      (pe.last = Io),
                      (pe.lastIndexOf = function (t, n, r) {
                        var e = null == t ? 0 : t.length;
                        if (!e) return -1;
                        var i = e;
                        return (
                          r !== u &&
                            (i = (i = Ka(r)) < 0 ? Fr(e + i, 0) : Jr(i, e - 1)),
                          n == n
                            ? (function (t, n, r) {
                                for (var e = r + 1; e--; )
                                  if (t[e] === n) return e;
                                return e;
                              })(t, n, i)
                            : ar(t, sr, i, !0)
                        );
                      }),
                      (pe.lowerCase = wf),
                      (pe.lowerFirst = mf),
                      (pe.lt = Ua),
                      (pe.lte = Ca),
                      (pe.max = function (t) {
                        return t && t.length ? Pe(t, Mf, Qe) : u;
                      }),
                      (pe.maxBy = function (t, n) {
                        return t && t.length ? Pe(t, Lu(n, 2), Qe) : u;
                      }),
                      (pe.mean = function (t) {
                        return hr(t, Mf);
                      }),
                      (pe.meanBy = function (t, n) {
                        return hr(t, Lu(n, 2));
                      }),
                      (pe.min = function (t) {
                        return t && t.length ? Pe(t, Mf, hi) : u;
                      }),
                      (pe.minBy = function (t, n) {
                        return t && t.length ? Pe(t, Lu(n, 2), hi) : u;
                      }),
                      (pe.stubArray = Nf),
                      (pe.stubFalse = $f),
                      (pe.stubObject = function () {
                        return {};
                      }),
                      (pe.stubString = function () {
                        return "";
                      }),
                      (pe.stubTrue = function () {
                        return !0;
                      }),
                      (pe.multiply = Gf),
                      (pe.nth = function (t, n) {
                        return t && t.length ? yi(t, Ka(n)) : u;
                      }),
                      (pe.noConflict = function () {
                        return Rn._ === this && (Rn._ = yn), this;
                      }),
                      (pe.noop = Tf),
                      (pe.now = Qo),
                      (pe.pad = function (t, n, r) {
                        t = Fa(t);
                        var e = (n = Ka(n)) ? Mr(t) : 0;
                        if (!n || e >= n) return t;
                        var i = (n - e) / 2;
                        return du(Wr(i), r) + t + du(Cr(i), r);
                      }),
                      (pe.padEnd = function (t, n, r) {
                        t = Fa(t);
                        var e = (n = Ka(n)) ? Mr(t) : 0;
                        return n && e < n ? t + du(n - e, r) : t;
                      }),
                      (pe.padStart = function (t, n, r) {
                        t = Fa(t);
                        var e = (n = Ka(n)) ? Mr(t) : 0;
                        return n && e < n ? du(n - e, r) + t : t;
                      }),
                      (pe.parseInt = function (t, n, r) {
                        return (
                          r || null == n ? (n = 0) : n && (n = +n),
                          Vr(Fa(t).replace(Lt, ""), n || 0)
                        );
                      }),
                      (pe.random = function (t, n, r) {
                        if (
                          (r &&
                            "boolean" != typeof r &&
                            Ju(t, n, r) &&
                            (n = r = u),
                          r === u &&
                            ("boolean" == typeof n
                              ? ((r = n), (n = u))
                              : "boolean" == typeof t && ((r = t), (t = u))),
                          t === u && n === u
                            ? ((t = 0), (n = 1))
                            : ((t = Ba(t)),
                              n === u ? ((n = t), (t = 0)) : (n = Ba(n))),
                          t > n)
                        ) {
                          var e = t;
                          (t = n), (n = e);
                        }
                        if (r || t % 1 || n % 1) {
                          var i = Zr();
                          return Jr(
                            t + i * (n - t + kn("1e-" + ((i + "").length - 1))),
                            n
                          );
                        }
                        return bi(t, n);
                      }),
                      (pe.reduce = function (t, n, r) {
                        var e = da(t) ? rr : _r,
                          i = arguments.length < 3;
                        return e(t, Lu(n, 4), r, i, We);
                      }),
                      (pe.reduceRight = function (t, n, r) {
                        var e = da(t) ? er : _r,
                          i = arguments.length < 3;
                        return e(t, Lu(n, 4), r, i, Be);
                      }),
                      (pe.repeat = function (t, n, r) {
                        return (
                          (n = (r ? Ju(t, n, r) : n === u) ? 1 : Ka(n)),
                          Si(Fa(t), n)
                        );
                      }),
                      (pe.replace = function () {
                        var t = arguments,
                          n = Fa(t[0]);
                        return t.length < 3 ? n : n.replace(t[1], t[2]);
                      }),
                      (pe.result = function (t, n, r) {
                        var e = -1,
                          i = (n = Ji(n, t)).length;
                        for (i || ((i = 1), (t = u)); ++e < i; ) {
                          var o = null == t ? u : t[co(n[e])];
                          o === u && ((e = i), (o = r)),
                            (t = za(o) ? o.call(t) : o);
                        }
                        return t;
                      }),
                      (pe.round = Yf),
                      (pe.runInContext = t),
                      (pe.sample = function (t) {
                        return (da(t) ? ze : zi)(t);
                      }),
                      (pe.size = function (t) {
                        if (null == t) return 0;
                        if (wa(t)) return Ra(t) ? Mr(t) : t.length;
                        var n = Ku(t);
                        return n == G || n == rt ? t.size : ci(t).length;
                      }),
                      (pe.snakeCase = bf),
                      (pe.some = function (t, n, r) {
                        var e = da(t) ? ir : Mi;
                        return r && Ju(t, n, r) && (n = u), e(t, Lu(n, 3));
                      }),
                      (pe.sortedIndex = function (t, n) {
                        return Di(t, n);
                      }),
                      (pe.sortedIndexBy = function (t, n, r) {
                        return qi(t, n, Lu(r, 2));
                      }),
                      (pe.sortedIndexOf = function (t, n) {
                        var r = null == t ? 0 : t.length;
                        if (r) {
                          var e = Di(t, n);
                          if (e < r && pa(t[e], n)) return e;
                        }
                        return -1;
                      }),
                      (pe.sortedLastIndex = function (t, n) {
                        return Di(t, n, !0);
                      }),
                      (pe.sortedLastIndexBy = function (t, n, r) {
                        return qi(t, n, Lu(r, 2), !0);
                      }),
                      (pe.sortedLastIndexOf = function (t, n) {
                        if (null == t ? 0 : t.length) {
                          var r = Di(t, n, !0) - 1;
                          if (pa(t[r], n)) return r;
                        }
                        return -1;
                      }),
                      (pe.startCase = Sf),
                      (pe.startsWith = function (t, n, r) {
                        return (
                          (t = Fa(t)),
                          (r = null == r ? 0 : Re(Ka(r), 0, t.length)),
                          (n = Ti(n)),
                          t.slice(r, r + n.length) == n
                        );
                      }),
                      (pe.subtract = Xf),
                      (pe.sum = function (t) {
                        return t && t.length ? vr(t, Mf) : 0;
                      }),
                      (pe.sumBy = function (t, n) {
                        return t && t.length ? vr(t, Lu(n, 2)) : 0;
                      }),
                      (pe.template = function (t, n, r) {
                        var e = pe.templateSettings;
                        r && Ju(t, n, r) && (n = u),
                          (t = Fa(t)),
                          (n = Va({}, n, e, xu));
                        var i,
                          o,
                          a = Va({}, n.imports, e.imports, xu),
                          f = uf(a),
                          c = gr(a, f),
                          s = 0,
                          h = n.interpolate || Gt,
                          l = "__p += '",
                          p = rn(
                            (n.escape || Gt).source +
                              "|" +
                              h.source +
                              "|" +
                              (h === At ? Pt : Gt).source +
                              "|" +
                              (n.evaluate || Gt).source +
                              "|$",
                            "g"
                          ),
                          _ =
                            "//# sourceURL=" +
                            (hn.call(n, "sourceURL")
                              ? (n.sourceURL + "").replace(/[\r\n]/g, " ")
                              : "lodash.templateSources[" + ++On + "]") +
                            "\n";
                        t.replace(p, function (n, r, e, u, a, f) {
                          return (
                            e || (e = u),
                            (l += t.slice(s, f).replace(Yt, zr)),
                            r && ((i = !0), (l += "' +\n__e(" + r + ") +\n'")),
                            a && ((o = !0), (l += "';\n" + a + ";\n__p += '")),
                            e &&
                              (l +=
                                "' +\n((__t = (" +
                                e +
                                ")) == null ? '' : __t) +\n'"),
                            (s = f + n.length),
                            n
                          );
                        }),
                          (l += "';\n");
                        var v = hn.call(n, "variable") && n.variable;
                        v || (l = "with (obj) {\n" + l + "\n}\n"),
                          (l = (o ? l.replace(wt, "") : l)
                            .replace(mt, "$1")
                            .replace(bt, "$1;")),
                          (l =
                            "function(" +
                            (v || "obj") +
                            ") {\n" +
                            (v ? "" : "obj || (obj = {});\n") +
                            "var __t, __p = ''" +
                            (i ? ", __e = _.escape" : "") +
                            (o
                              ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n"
                              : ";\n") +
                            l +
                            "return __p\n}");
                        var y = Of(function () {
                          return Qt(f, _ + "return " + l).apply(u, c);
                        });
                        if (((y.source = l), Ia(y))) throw y;
                        return y;
                      }),
                      (pe.times = function (t, n) {
                        if ((t = Ka(t)) < 1 || t > R) return [];
                        var r = U,
                          e = Jr(t, U);
                        (n = Lu(n)), (t -= U);
                        for (var i = yr(e, n); ++r < t; ) n(r);
                        return i;
                      }),
                      (pe.toFinite = Ba),
                      (pe.toInteger = Ka),
                      (pe.toLength = Pa),
                      (pe.toLower = function (t) {
                        return Fa(t).toLowerCase();
                      }),
                      (pe.toNumber = Na),
                      (pe.toSafeInteger = function (t) {
                        return t ? Re(Ka(t), -R, R) : 0 === t ? t : 0;
                      }),
                      (pe.toString = Fa),
                      (pe.toUpper = function (t) {
                        return Fa(t).toUpperCase();
                      }),
                      (pe.trim = function (t, n, r) {
                        if ((t = Fa(t)) && (r || n === u))
                          return t.replace(Rt, "");
                        if (!t || !(n = Ti(n))) return t;
                        var e = Dr(t),
                          i = Dr(n);
                        return Vi(e, mr(e, i), br(e, i) + 1).join("");
                      }),
                      (pe.trimEnd = function (t, n, r) {
                        if ((t = Fa(t)) && (r || n === u))
                          return t.replace(Tt, "");
                        if (!t || !(n = Ti(n))) return t;
                        var e = Dr(t);
                        return Vi(e, 0, br(e, Dr(n)) + 1).join("");
                      }),
                      (pe.trimStart = function (t, n, r) {
                        if ((t = Fa(t)) && (r || n === u))
                          return t.replace(Lt, "");
                        if (!t || !(n = Ti(n))) return t;
                        var e = Dr(t);
                        return Vi(e, mr(e, Dr(n))).join("");
                      }),
                      (pe.truncate = function (t, n) {
                        var r = j,
                          e = A;
                        if (ja(n)) {
                          var i = "separator" in n ? n.separator : i;
                          (r = "length" in n ? Ka(n.length) : r),
                            (e = "omission" in n ? Ti(n.omission) : e);
                        }
                        var o = (t = Fa(t)).length;
                        if (xr(t)) {
                          var a = Dr(t);
                          o = a.length;
                        }
                        if (r >= o) return t;
                        var f = r - Mr(e);
                        if (f < 1) return e;
                        var c = a ? Vi(a, 0, f).join("") : t.slice(0, f);
                        if (i === u) return c + e;
                        if ((a && (f += c.length - f), Da(i))) {
                          if (t.slice(f).search(i)) {
                            var s,
                              h = c;
                            for (
                              i.global ||
                                (i = rn(i.source, Fa(Nt.exec(i)) + "g")),
                                i.lastIndex = 0;
                              (s = i.exec(h));

                            )
                              var l = s.index;
                            c = c.slice(0, l === u ? f : l);
                          }
                        } else if (t.indexOf(Ti(i), f) != f) {
                          var p = c.lastIndexOf(i);
                          p > -1 && (c = c.slice(0, p));
                        }
                        return c + e;
                      }),
                      (pe.unescape = function (t) {
                        return (t = Fa(t)) && zt.test(t)
                          ? t.replace(St, qr)
                          : t;
                      }),
                      (pe.uniqueId = function (t) {
                        var n = ++ln;
                        return Fa(t) + n;
                      }),
                      (pe.upperCase = If),
                      (pe.upperFirst = zf),
                      (pe.each = Fo),
                      (pe.eachRight = Jo),
                      (pe.first = wo),
                      Lf(
                        pe,
                        ((Zf = {}),
                        He(pe, function (t, n) {
                          hn.call(pe.prototype, n) || (Zf[n] = t);
                        }),
                        Zf),
                        { chain: !1 }
                      ),
                      (pe.VERSION = "4.17.15"),
                      Vn(
                        [
                          "bind",
                          "bindKey",
                          "curry",
                          "curryRight",
                          "partial",
                          "partialRight",
                        ],
                        function (t) {
                          pe[t].placeholder = pe;
                        }
                      ),
                      Vn(["drop", "take"], function (t, n) {
                        (de.prototype[t] = function (r) {
                          r = r === u ? 1 : Fr(Ka(r), 0);
                          var e =
                            this.__filtered__ && !n
                              ? new de(this)
                              : this.clone();
                          return (
                            e.__filtered__
                              ? (e.__takeCount__ = Jr(r, e.__takeCount__))
                              : e.__views__.push({
                                  size: Jr(r, U),
                                  type: t + (e.__dir__ < 0 ? "Right" : ""),
                                }),
                            e
                          );
                        }),
                          (de.prototype[t + "Right"] = function (n) {
                            return this.reverse()[t](n).reverse();
                          });
                      }),
                      Vn(["filter", "map", "takeWhile"], function (t, n) {
                        var r = n + 1,
                          e = r == M || 3 == r;
                        de.prototype[t] = function (t) {
                          var n = this.clone();
                          return (
                            n.__iteratees__.push({
                              iteratee: Lu(t, 3),
                              type: r,
                            }),
                            (n.__filtered__ = n.__filtered__ || e),
                            n
                          );
                        };
                      }),
                      Vn(["head", "last"], function (t, n) {
                        var r = "take" + (n ? "Right" : "");
                        de.prototype[t] = function () {
                          return this[r](1).value()[0];
                        };
                      }),
                      Vn(["initial", "tail"], function (t, n) {
                        var r = "drop" + (n ? "" : "Right");
                        de.prototype[t] = function () {
                          return this.__filtered__ ? new de(this) : this[r](1);
                        };
                      }),
                      (de.prototype.compact = function () {
                        return this.filter(Mf);
                      }),
                      (de.prototype.find = function (t) {
                        return this.filter(t).head();
                      }),
                      (de.prototype.findLast = function (t) {
                        return this.reverse().find(t);
                      }),
                      (de.prototype.invokeMap = Ii(function (t, n) {
                        return "function" == typeof t
                          ? new de(this)
                          : this.map(function (r) {
                              return ei(r, t, n);
                            });
                      })),
                      (de.prototype.reject = function (t) {
                        return this.filter(fa(Lu(t)));
                      }),
                      (de.prototype.slice = function (t, n) {
                        t = Ka(t);
                        var r = this;
                        return r.__filtered__ && (t > 0 || n < 0)
                          ? new de(r)
                          : (t < 0
                              ? (r = r.takeRight(-t))
                              : t && (r = r.drop(t)),
                            n !== u &&
                              (r =
                                (n = Ka(n)) < 0
                                  ? r.dropRight(-n)
                                  : r.take(n - t)),
                            r);
                      }),
                      (de.prototype.takeRightWhile = function (t) {
                        return this.reverse().takeWhile(t).reverse();
                      }),
                      (de.prototype.toArray = function () {
                        return this.take(U);
                      }),
                      He(de.prototype, function (t, n) {
                        var r = /^(?:filter|find|map|reject)|While$/.test(n),
                          e = /^(?:head|last)$/.test(n),
                          i = pe[e ? "take" + ("last" == n ? "Right" : "") : n],
                          o = e || /^find/.test(n);
                        i &&
                          (pe.prototype[n] = function () {
                            var n = this.__wrapped__,
                              a = e ? [1] : arguments,
                              f = n instanceof de,
                              c = a[0],
                              s = f || da(n),
                              h = function (t) {
                                var n = i.apply(pe, nr([t], a));
                                return e && l ? n[0] : n;
                              };
                            s &&
                              r &&
                              "function" == typeof c &&
                              1 != c.length &&
                              (f = s = !1);
                            var l = this.__chain__,
                              p = !!this.__actions__.length,
                              _ = o && !l,
                              v = f && !p;
                            if (!o && s) {
                              n = v ? n : new de(this);
                              var y = t.apply(n, a);
                              return (
                                y.__actions__.push({
                                  func: Bo,
                                  args: [h],
                                  thisArg: u,
                                }),
                                new ye(y, l)
                              );
                            }
                            return _ && v
                              ? t.apply(this, a)
                              : ((y = this.thru(h)),
                                _ ? (e ? y.value()[0] : y.value()) : y);
                          });
                      }),
                      Vn(
                        ["pop", "push", "shift", "sort", "splice", "unshift"],
                        function (t) {
                          var n = on[t],
                            r = /^(?:push|sort|unshift)$/.test(t)
                              ? "tap"
                              : "thru",
                            e = /^(?:pop|shift)$/.test(t);
                          pe.prototype[t] = function () {
                            var t = arguments;
                            if (e && !this.__chain__) {
                              var i = this.value();
                              return n.apply(da(i) ? i : [], t);
                            }
                            return this[r](function (r) {
                              return n.apply(da(r) ? r : [], t);
                            });
                          };
                        }
                      ),
                      He(de.prototype, function (t, n) {
                        var r = pe[n];
                        if (r) {
                          var e = r.name + "";
                          hn.call(ie, e) || (ie[e] = []),
                            ie[e].push({ name: n, func: r });
                        }
                      }),
                      (ie[pu(u, g).name] = [{ name: "wrapper", func: u }]),
                      (de.prototype.clone = function () {
                        var t = new de(this.__wrapped__);
                        return (
                          (t.__actions__ = ru(this.__actions__)),
                          (t.__dir__ = this.__dir__),
                          (t.__filtered__ = this.__filtered__),
                          (t.__iteratees__ = ru(this.__iteratees__)),
                          (t.__takeCount__ = this.__takeCount__),
                          (t.__views__ = ru(this.__views__)),
                          t
                        );
                      }),
                      (de.prototype.reverse = function () {
                        if (this.__filtered__) {
                          var t = new de(this);
                          (t.__dir__ = -1), (t.__filtered__ = !0);
                        } else (t = this.clone()).__dir__ *= -1;
                        return t;
                      }),
                      (de.prototype.value = function () {
                        var t = this.__wrapped__.value(),
                          n = this.__dir__,
                          r = da(t),
                          e = n < 0,
                          i = r ? t.length : 0,
                          u = (function (t, n, r) {
                            var e = -1,
                              i = r.length;
                            for (; ++e < i; ) {
                              var u = r[e],
                                o = u.size;
                              switch (u.type) {
                                case "drop":
                                  t += o;
                                  break;
                                case "dropRight":
                                  n -= o;
                                  break;
                                case "take":
                                  n = Jr(n, t + o);
                                  break;
                                case "takeRight":
                                  t = Fr(t, n - o);
                              }
                            }
                            return { start: t, end: n };
                          })(0, i, this.__views__),
                          o = u.start,
                          a = u.end,
                          f = a - o,
                          c = e ? a : o - 1,
                          s = this.__iteratees__,
                          h = s.length,
                          l = 0,
                          p = Jr(f, this.__takeCount__);
                        if (!r || (!e && i == f && p == f))
                          return Ki(t, this.__actions__);
                        var _ = [];
                        t: for (; f-- && l < p; ) {
                          for (var v = -1, y = t[(c += n)]; ++v < h; ) {
                            var d = s[v],
                              g = d.iteratee,
                              w = d.type,
                              m = g(y);
                            if (w == D) y = m;
                            else if (!m) {
                              if (w == M) continue t;
                              break t;
                            }
                          }
                          _[l++] = y;
                        }
                        return _;
                      }),
                      (pe.prototype.at = Ko),
                      (pe.prototype.chain = function () {
                        return Wo(this);
                      }),
                      (pe.prototype.commit = function () {
                        return new ye(this.value(), this.__chain__);
                      }),
                      (pe.prototype.next = function () {
                        this.__values__ === u &&
                          (this.__values__ = Wa(this.value()));
                        var t = this.__index__ >= this.__values__.length;
                        return {
                          done: t,
                          value: t ? u : this.__values__[this.__index__++],
                        };
                      }),
                      (pe.prototype.plant = function (t) {
                        for (var n, r = this; r instanceof ve; ) {
                          var e = ho(r);
                          (e.__index__ = 0),
                            (e.__values__ = u),
                            n ? (i.__wrapped__ = e) : (n = e);
                          var i = e;
                          r = r.__wrapped__;
                        }
                        return (i.__wrapped__ = t), n;
                      }),
                      (pe.prototype.reverse = function () {
                        var t = this.__wrapped__;
                        if (t instanceof de) {
                          var n = t;
                          return (
                            this.__actions__.length && (n = new de(this)),
                            (n = n.reverse()).__actions__.push({
                              func: Bo,
                              args: [jo],
                              thisArg: u,
                            }),
                            new ye(n, this.__chain__)
                          );
                        }
                        return this.thru(jo);
                      }),
                      (pe.prototype.toJSON = pe.prototype.valueOf = pe.prototype.value = function () {
                        return Ki(this.__wrapped__, this.__actions__);
                      }),
                      (pe.prototype.first = pe.prototype.head),
                      Wn &&
                        (pe.prototype[Wn] = function () {
                          return this;
                        }),
                      pe
                    );
                  })();
                  (Rn._ = Rr),
                    (i = function () {
                      return Rr;
                    }.call(n, r, n, e)) === u || (e.exports = i);
                }.call(this));
              }.call(this, r(3), r(4)(t)));
            },
            function (t, n, r) {
              t.exports = (function () {
                "use strict";
                var t = Array.prototype.slice;
                function n(t, n) {
                  n && (t.prototype = Object.create(n.prototype)),
                    (t.prototype.constructor = t);
                }
                function r(t) {
                  return o(t) ? t : J(t);
                }
                function e(t) {
                  return a(t) ? t : H(t);
                }
                function i(t) {
                  return f(t) ? t : V(t);
                }
                function u(t) {
                  return o(t) && !c(t) ? t : Z(t);
                }
                function o(t) {
                  return !(!t || !t[h]);
                }
                function a(t) {
                  return !(!t || !t[l]);
                }
                function f(t) {
                  return !(!t || !t[p]);
                }
                function c(t) {
                  return a(t) || f(t);
                }
                function s(t) {
                  return !(!t || !t[_]);
                }
                n(e, r),
                  n(i, r),
                  n(u, r),
                  (r.isIterable = o),
                  (r.isKeyed = a),
                  (r.isIndexed = f),
                  (r.isAssociative = c),
                  (r.isOrdered = s),
                  (r.Keyed = e),
                  (r.Indexed = i),
                  (r.Set = u);
                var h = "@@__IMMUTABLE_ITERABLE__@@",
                  l = "@@__IMMUTABLE_KEYED__@@",
                  p = "@@__IMMUTABLE_INDEXED__@@",
                  _ = "@@__IMMUTABLE_ORDERED__@@",
                  v = 5,
                  y = 1 << v,
                  d = y - 1,
                  g = {},
                  w = { value: !1 },
                  m = { value: !1 };
                function b(t) {
                  return (t.value = !1), t;
                }
                function S(t) {
                  t && (t.value = !0);
                }
                function I() {}
                function z(t, n) {
                  n = n || 0;
                  for (
                    var r = Math.max(0, t.length - n), e = new Array(r), i = 0;
                    i < r;
                    i++
                  )
                    e[i] = t[i + n];
                  return e;
                }
                function x(t) {
                  return void 0 === t.size && (t.size = t.__iterate(j)), t.size;
                }
                function O(t, n) {
                  if ("number" != typeof n) {
                    var r = n >>> 0;
                    if ("" + r !== n || 4294967295 === r) return NaN;
                    n = r;
                  }
                  return n < 0 ? x(t) + n : n;
                }
                function j() {
                  return !0;
                }
                function A(t, n, r) {
                  return (
                    (0 === t || (void 0 !== r && t <= -r)) &&
                    (void 0 === n || (void 0 !== r && n >= r))
                  );
                }
                function E(t, n) {
                  return M(t, n, 0);
                }
                function k(t, n) {
                  return M(t, n, n);
                }
                function M(t, n, r) {
                  return void 0 === t
                    ? r
                    : t < 0
                    ? Math.max(0, n + t)
                    : void 0 === n
                    ? t
                    : Math.min(n, t);
                }
                var D = 0,
                  q = 1,
                  R = 2,
                  L = "function" == typeof Symbol && Symbol.iterator,
                  T = "@@iterator",
                  U = L || T;
                function C(t) {
                  this.next = t;
                }
                function W(t, n, r, e) {
                  var i = 0 === t ? n : 1 === t ? r : [n, r];
                  return e ? (e.value = i) : (e = { value: i, done: !1 }), e;
                }
                function B() {
                  return { value: void 0, done: !0 };
                }
                function K(t) {
                  return !!$(t);
                }
                function P(t) {
                  return t && "function" == typeof t.next;
                }
                function N(t) {
                  var n = $(t);
                  return n && n.call(t);
                }
                function $(t) {
                  var n = t && ((L && t[L]) || t[T]);
                  if ("function" == typeof n) return n;
                }
                function F(t) {
                  return t && "number" == typeof t.length;
                }
                function J(t) {
                  return null == t
                    ? ut()
                    : o(t)
                    ? t.toSeq()
                    : (function (t) {
                        var n = ft(t) || ("object" == typeof t && new nt(t));
                        if (!n)
                          throw new TypeError(
                            "Expected Array or iterable object of values, or keyed object: " +
                              t
                          );
                        return n;
                      })(t);
                }
                function H(t) {
                  return null == t
                    ? ut().toKeyedSeq()
                    : o(t)
                    ? a(t)
                      ? t.toSeq()
                      : t.fromEntrySeq()
                    : ot(t);
                }
                function V(t) {
                  return null == t
                    ? ut()
                    : o(t)
                    ? a(t)
                      ? t.entrySeq()
                      : t.toIndexedSeq()
                    : at(t);
                }
                function Z(t) {
                  return (null == t
                    ? ut()
                    : o(t)
                    ? a(t)
                      ? t.entrySeq()
                      : t
                    : at(t)
                  ).toSetSeq();
                }
                (C.prototype.toString = function () {
                  return "[Iterator]";
                }),
                  (C.KEYS = D),
                  (C.VALUES = q),
                  (C.ENTRIES = R),
                  (C.prototype.inspect = C.prototype.toSource = function () {
                    return this.toString();
                  }),
                  (C.prototype[U] = function () {
                    return this;
                  }),
                  n(J, r),
                  (J.of = function () {
                    return J(arguments);
                  }),
                  (J.prototype.toSeq = function () {
                    return this;
                  }),
                  (J.prototype.toString = function () {
                    return this.__toString("Seq {", "}");
                  }),
                  (J.prototype.cacheResult = function () {
                    return (
                      !this._cache &&
                        this.__iterateUncached &&
                        ((this._cache = this.entrySeq().toArray()),
                        (this.size = this._cache.length)),
                      this
                    );
                  }),
                  (J.prototype.__iterate = function (t, n) {
                    return ct(this, t, n, !0);
                  }),
                  (J.prototype.__iterator = function (t, n) {
                    return st(this, t, n, !0);
                  }),
                  n(H, J),
                  (H.prototype.toKeyedSeq = function () {
                    return this;
                  }),
                  n(V, J),
                  (V.of = function () {
                    return V(arguments);
                  }),
                  (V.prototype.toIndexedSeq = function () {
                    return this;
                  }),
                  (V.prototype.toString = function () {
                    return this.__toString("Seq [", "]");
                  }),
                  (V.prototype.__iterate = function (t, n) {
                    return ct(this, t, n, !1);
                  }),
                  (V.prototype.__iterator = function (t, n) {
                    return st(this, t, n, !1);
                  }),
                  n(Z, J),
                  (Z.of = function () {
                    return Z(arguments);
                  }),
                  (Z.prototype.toSetSeq = function () {
                    return this;
                  }),
                  (J.isSeq = it),
                  (J.Keyed = H),
                  (J.Set = Z),
                  (J.Indexed = V);
                var G,
                  Y,
                  X,
                  Q = "@@__IMMUTABLE_SEQ__@@";
                function tt(t) {
                  (this._array = t), (this.size = t.length);
                }
                function nt(t) {
                  var n = Object.keys(t);
                  (this._object = t), (this._keys = n), (this.size = n.length);
                }
                function rt(t) {
                  (this._iterable = t), (this.size = t.length || t.size);
                }
                function et(t) {
                  (this._iterator = t), (this._iteratorCache = []);
                }
                function it(t) {
                  return !(!t || !t[Q]);
                }
                function ut() {
                  return G || (G = new tt([]));
                }
                function ot(t) {
                  var n = Array.isArray(t)
                    ? new tt(t).fromEntrySeq()
                    : P(t)
                    ? new et(t).fromEntrySeq()
                    : K(t)
                    ? new rt(t).fromEntrySeq()
                    : "object" == typeof t
                    ? new nt(t)
                    : void 0;
                  if (!n)
                    throw new TypeError(
                      "Expected Array or iterable object of [k, v] entries, or keyed object: " +
                        t
                    );
                  return n;
                }
                function at(t) {
                  var n = ft(t);
                  if (!n)
                    throw new TypeError(
                      "Expected Array or iterable object of values: " + t
                    );
                  return n;
                }
                function ft(t) {
                  return F(t)
                    ? new tt(t)
                    : P(t)
                    ? new et(t)
                    : K(t)
                    ? new rt(t)
                    : void 0;
                }
                function ct(t, n, r, e) {
                  var i = t._cache;
                  if (i) {
                    for (var u = i.length - 1, o = 0; o <= u; o++) {
                      var a = i[r ? u - o : o];
                      if (!1 === n(a[1], e ? a[0] : o, t)) return o + 1;
                    }
                    return o;
                  }
                  return t.__iterateUncached(n, r);
                }
                function st(t, n, r, e) {
                  var i = t._cache;
                  if (i) {
                    var u = i.length - 1,
                      o = 0;
                    return new C(function () {
                      var t = i[r ? u - o : o];
                      return o++ > u
                        ? { value: void 0, done: !0 }
                        : W(n, e ? t[0] : o - 1, t[1]);
                    });
                  }
                  return t.__iteratorUncached(n, r);
                }
                function ht(t, n) {
                  return n
                    ? (function t(n, r, e, i) {
                        return Array.isArray(r)
                          ? n.call(
                              i,
                              e,
                              V(r).map(function (e, i) {
                                return t(n, e, i, r);
                              })
                            )
                          : pt(r)
                          ? n.call(
                              i,
                              e,
                              H(r).map(function (e, i) {
                                return t(n, e, i, r);
                              })
                            )
                          : r;
                      })(n, t, "", { "": t })
                    : lt(t);
                }
                function lt(t) {
                  return Array.isArray(t)
                    ? V(t).map(lt).toList()
                    : pt(t)
                    ? H(t).map(lt).toMap()
                    : t;
                }
                function pt(t) {
                  return (
                    t && (t.constructor === Object || void 0 === t.constructor)
                  );
                }
                function _t(t, n) {
                  if (t === n || (t != t && n != n)) return !0;
                  if (!t || !n) return !1;
                  if (
                    "function" == typeof t.valueOf &&
                    "function" == typeof n.valueOf
                  ) {
                    if (
                      (t = t.valueOf()) === (n = n.valueOf()) ||
                      (t != t && n != n)
                    )
                      return !0;
                    if (!t || !n) return !1;
                  }
                  return !(
                    "function" != typeof t.equals ||
                    "function" != typeof n.equals ||
                    !t.equals(n)
                  );
                }
                function vt(t, n) {
                  if (t === n) return !0;
                  if (
                    !o(n) ||
                    (void 0 !== t.size &&
                      void 0 !== n.size &&
                      t.size !== n.size) ||
                    (void 0 !== t.__hash &&
                      void 0 !== n.__hash &&
                      t.__hash !== n.__hash) ||
                    a(t) !== a(n) ||
                    f(t) !== f(n) ||
                    s(t) !== s(n)
                  )
                    return !1;
                  if (0 === t.size && 0 === n.size) return !0;
                  var r = !c(t);
                  if (s(t)) {
                    var e = t.entries();
                    return (
                      n.every(function (t, n) {
                        var i = e.next().value;
                        return i && _t(i[1], t) && (r || _t(i[0], n));
                      }) && e.next().done
                    );
                  }
                  var i = !1;
                  if (void 0 === t.size)
                    if (void 0 === n.size)
                      "function" == typeof t.cacheResult && t.cacheResult();
                    else {
                      i = !0;
                      var u = t;
                      (t = n), (n = u);
                    }
                  var h = !0,
                    l = n.__iterate(function (n, e) {
                      if (
                        r
                          ? !t.has(n)
                          : i
                          ? !_t(n, t.get(e, g))
                          : !_t(t.get(e, g), n)
                      )
                        return (h = !1), !1;
                    });
                  return h && t.size === l;
                }
                function yt(t, n) {
                  if (!(this instanceof yt)) return new yt(t, n);
                  if (
                    ((this._value = t),
                    (this.size = void 0 === n ? 1 / 0 : Math.max(0, n)),
                    0 === this.size)
                  ) {
                    if (Y) return Y;
                    Y = this;
                  }
                }
                function dt(t, n) {
                  if (!t) throw new Error(n);
                }
                function gt(t, n, r) {
                  if (!(this instanceof gt)) return new gt(t, n, r);
                  if (
                    (dt(0 !== r, "Cannot step a Range by 0"),
                    (t = t || 0),
                    void 0 === n && (n = 1 / 0),
                    (r = void 0 === r ? 1 : Math.abs(r)),
                    n < t && (r = -r),
                    (this._start = t),
                    (this._end = n),
                    (this._step = r),
                    (this.size = Math.max(0, Math.ceil((n - t) / r - 1) + 1)),
                    0 === this.size)
                  ) {
                    if (X) return X;
                    X = this;
                  }
                }
                function wt() {
                  throw TypeError("Abstract");
                }
                function mt() {}
                function bt() {}
                function St() {}
                (J.prototype[Q] = !0),
                  n(tt, V),
                  (tt.prototype.get = function (t, n) {
                    return this.has(t) ? this._array[O(this, t)] : n;
                  }),
                  (tt.prototype.__iterate = function (t, n) {
                    for (
                      var r = this._array, e = r.length - 1, i = 0;
                      i <= e;
                      i++
                    )
                      if (!1 === t(r[n ? e - i : i], i, this)) return i + 1;
                    return i;
                  }),
                  (tt.prototype.__iterator = function (t, n) {
                    var r = this._array,
                      e = r.length - 1,
                      i = 0;
                    return new C(function () {
                      return i > e
                        ? { value: void 0, done: !0 }
                        : W(t, i, r[n ? e - i++ : i++]);
                    });
                  }),
                  n(nt, H),
                  (nt.prototype.get = function (t, n) {
                    return void 0 === n || this.has(t) ? this._object[t] : n;
                  }),
                  (nt.prototype.has = function (t) {
                    return this._object.hasOwnProperty(t);
                  }),
                  (nt.prototype.__iterate = function (t, n) {
                    for (
                      var r = this._object,
                        e = this._keys,
                        i = e.length - 1,
                        u = 0;
                      u <= i;
                      u++
                    ) {
                      var o = e[n ? i - u : u];
                      if (!1 === t(r[o], o, this)) return u + 1;
                    }
                    return u;
                  }),
                  (nt.prototype.__iterator = function (t, n) {
                    var r = this._object,
                      e = this._keys,
                      i = e.length - 1,
                      u = 0;
                    return new C(function () {
                      var o = e[n ? i - u : u];
                      return u++ > i
                        ? { value: void 0, done: !0 }
                        : W(t, o, r[o]);
                    });
                  }),
                  (nt.prototype[_] = !0),
                  n(rt, V),
                  (rt.prototype.__iterateUncached = function (t, n) {
                    if (n) return this.cacheResult().__iterate(t, n);
                    var r = N(this._iterable),
                      e = 0;
                    if (P(r))
                      for (
                        var i;
                        !(i = r.next()).done && !1 !== t(i.value, e++, this);

                      );
                    return e;
                  }),
                  (rt.prototype.__iteratorUncached = function (t, n) {
                    if (n) return this.cacheResult().__iterator(t, n);
                    var r = N(this._iterable);
                    if (!P(r)) return new C(B);
                    var e = 0;
                    return new C(function () {
                      var n = r.next();
                      return n.done ? n : W(t, e++, n.value);
                    });
                  }),
                  n(et, V),
                  (et.prototype.__iterateUncached = function (t, n) {
                    if (n) return this.cacheResult().__iterate(t, n);
                    for (
                      var r, e = this._iterator, i = this._iteratorCache, u = 0;
                      u < i.length;

                    )
                      if (!1 === t(i[u], u++, this)) return u;
                    for (; !(r = e.next()).done; ) {
                      var o = r.value;
                      if (((i[u] = o), !1 === t(o, u++, this))) break;
                    }
                    return u;
                  }),
                  (et.prototype.__iteratorUncached = function (t, n) {
                    if (n) return this.cacheResult().__iterator(t, n);
                    var r = this._iterator,
                      e = this._iteratorCache,
                      i = 0;
                    return new C(function () {
                      if (i >= e.length) {
                        var n = r.next();
                        if (n.done) return n;
                        e[i] = n.value;
                      }
                      return W(t, i, e[i++]);
                    });
                  }),
                  n(yt, V),
                  (yt.prototype.toString = function () {
                    return 0 === this.size
                      ? "Repeat []"
                      : "Repeat [ " +
                          this._value +
                          " " +
                          this.size +
                          " times ]";
                  }),
                  (yt.prototype.get = function (t, n) {
                    return this.has(t) ? this._value : n;
                  }),
                  (yt.prototype.includes = function (t) {
                    return _t(this._value, t);
                  }),
                  (yt.prototype.slice = function (t, n) {
                    var r = this.size;
                    return A(t, n, r)
                      ? this
                      : new yt(this._value, k(n, r) - E(t, r));
                  }),
                  (yt.prototype.reverse = function () {
                    return this;
                  }),
                  (yt.prototype.indexOf = function (t) {
                    return _t(this._value, t) ? 0 : -1;
                  }),
                  (yt.prototype.lastIndexOf = function (t) {
                    return _t(this._value, t) ? this.size : -1;
                  }),
                  (yt.prototype.__iterate = function (t, n) {
                    for (var r = 0; r < this.size; r++)
                      if (!1 === t(this._value, r, this)) return r + 1;
                    return r;
                  }),
                  (yt.prototype.__iterator = function (t, n) {
                    var r = this,
                      e = 0;
                    return new C(function () {
                      return e < r.size
                        ? W(t, e++, r._value)
                        : { value: void 0, done: !0 };
                    });
                  }),
                  (yt.prototype.equals = function (t) {
                    return t instanceof yt ? _t(this._value, t._value) : vt(t);
                  }),
                  n(gt, V),
                  (gt.prototype.toString = function () {
                    return 0 === this.size
                      ? "Range []"
                      : "Range [ " +
                          this._start +
                          "..." +
                          this._end +
                          (1 !== this._step ? " by " + this._step : "") +
                          " ]";
                  }),
                  (gt.prototype.get = function (t, n) {
                    return this.has(t)
                      ? this._start + O(this, t) * this._step
                      : n;
                  }),
                  (gt.prototype.includes = function (t) {
                    var n = (t - this._start) / this._step;
                    return n >= 0 && n < this.size && n === Math.floor(n);
                  }),
                  (gt.prototype.slice = function (t, n) {
                    return A(t, n, this.size)
                      ? this
                      : ((t = E(t, this.size)),
                        (n = k(n, this.size)) <= t
                          ? new gt(0, 0)
                          : new gt(
                              this.get(t, this._end),
                              this.get(n, this._end),
                              this._step
                            ));
                  }),
                  (gt.prototype.indexOf = function (t) {
                    var n = t - this._start;
                    if (n % this._step == 0) {
                      var r = n / this._step;
                      if (r >= 0 && r < this.size) return r;
                    }
                    return -1;
                  }),
                  (gt.prototype.lastIndexOf = function (t) {
                    return this.indexOf(t);
                  }),
                  (gt.prototype.__iterate = function (t, n) {
                    for (
                      var r = this.size - 1,
                        e = this._step,
                        i = n ? this._start + r * e : this._start,
                        u = 0;
                      u <= r;
                      u++
                    ) {
                      if (!1 === t(i, u, this)) return u + 1;
                      i += n ? -e : e;
                    }
                    return u;
                  }),
                  (gt.prototype.__iterator = function (t, n) {
                    var r = this.size - 1,
                      e = this._step,
                      i = n ? this._start + r * e : this._start,
                      u = 0;
                    return new C(function () {
                      var o = i;
                      return (
                        (i += n ? -e : e),
                        u > r ? { value: void 0, done: !0 } : W(t, u++, o)
                      );
                    });
                  }),
                  (gt.prototype.equals = function (t) {
                    return t instanceof gt
                      ? this._start === t._start &&
                          this._end === t._end &&
                          this._step === t._step
                      : vt(this, t);
                  }),
                  n(wt, r),
                  n(mt, wt),
                  n(bt, wt),
                  n(St, wt),
                  (wt.Keyed = mt),
                  (wt.Indexed = bt),
                  (wt.Set = St);
                var It =
                  "function" == typeof Math.imul &&
                  -2 === Math.imul(4294967295, 2)
                    ? Math.imul
                    : function (t, n) {
                        var r = 65535 & (t |= 0),
                          e = 65535 & (n |= 0);
                        return (
                          (r * e +
                            ((((t >>> 16) * e + r * (n >>> 16)) << 16) >>> 0)) |
                          0
                        );
                      };
                function zt(t) {
                  return ((t >>> 1) & 1073741824) | (3221225471 & t);
                }
                function xt(t) {
                  if (!1 === t || null == t) return 0;
                  if (
                    "function" == typeof t.valueOf &&
                    (!1 === (t = t.valueOf()) || null == t)
                  )
                    return 0;
                  if (!0 === t) return 1;
                  var n = typeof t;
                  if ("number" === n) {
                    if (t != t || t === 1 / 0) return 0;
                    var r = 0 | t;
                    for (r !== t && (r ^= 4294967295 * t); t > 4294967295; )
                      r ^= t /= 4294967295;
                    return zt(r);
                  }
                  if ("string" === n)
                    return t.length > qt
                      ? (function (t) {
                          var n = Tt[t];
                          return (
                            void 0 === n &&
                              ((n = Ot(t)),
                              Lt === Rt && ((Lt = 0), (Tt = {})),
                              Lt++,
                              (Tt[t] = n)),
                            n
                          );
                        })(t)
                      : Ot(t);
                  if ("function" == typeof t.hashCode) return t.hashCode();
                  if ("object" === n)
                    return (function (t) {
                      var n;
                      if (kt && void 0 !== (n = jt.get(t))) return n;
                      if (void 0 !== (n = t[Dt])) return n;
                      if (!Et) {
                        if (
                          void 0 !==
                          (n =
                            t.propertyIsEnumerable &&
                            t.propertyIsEnumerable[Dt])
                        )
                          return n;
                        if (
                          void 0 !==
                          (n = (function (t) {
                            if (t && t.nodeType > 0)
                              switch (t.nodeType) {
                                case 1:
                                  return t.uniqueID;
                                case 9:
                                  return (
                                    t.documentElement &&
                                    t.documentElement.uniqueID
                                  );
                              }
                          })(t))
                        )
                          return n;
                      }
                      if (((n = ++Mt), 1073741824 & Mt && (Mt = 0), kt))
                        jt.set(t, n);
                      else {
                        if (void 0 !== At && !1 === At(t))
                          throw new Error(
                            "Non-extensible objects are not allowed as keys."
                          );
                        if (Et)
                          Object.defineProperty(t, Dt, {
                            enumerable: !1,
                            configurable: !1,
                            writable: !1,
                            value: n,
                          });
                        else if (
                          void 0 !== t.propertyIsEnumerable &&
                          t.propertyIsEnumerable ===
                            t.constructor.prototype.propertyIsEnumerable
                        )
                          (t.propertyIsEnumerable = function () {
                            return this.constructor.prototype.propertyIsEnumerable.apply(
                              this,
                              arguments
                            );
                          }),
                            (t.propertyIsEnumerable[Dt] = n);
                        else {
                          if (void 0 === t.nodeType)
                            throw new Error(
                              "Unable to set a non-enumerable property on object."
                            );
                          t[Dt] = n;
                        }
                      }
                      return n;
                    })(t);
                  if ("function" == typeof t.toString) return Ot(t.toString());
                  throw new Error("Value type " + n + " cannot be hashed.");
                }
                function Ot(t) {
                  for (var n = 0, r = 0; r < t.length; r++)
                    n = (31 * n + t.charCodeAt(r)) | 0;
                  return zt(n);
                }
                var jt,
                  At = Object.isExtensible,
                  Et = (function () {
                    try {
                      return Object.defineProperty({}, "@", {}), !0;
                    } catch (t) {
                      return !1;
                    }
                  })(),
                  kt = "function" == typeof WeakMap;
                kt && (jt = new WeakMap());
                var Mt = 0,
                  Dt = "__immutablehash__";
                "function" == typeof Symbol && (Dt = Symbol(Dt));
                var qt = 16,
                  Rt = 255,
                  Lt = 0,
                  Tt = {};
                function Ut(t) {
                  dt(
                    t !== 1 / 0,
                    "Cannot perform this action with an infinite size."
                  );
                }
                function Ct(t) {
                  return null == t
                    ? Xt()
                    : Wt(t) && !s(t)
                    ? t
                    : Xt().withMutations(function (n) {
                        var r = e(t);
                        Ut(r.size),
                          r.forEach(function (t, r) {
                            return n.set(r, t);
                          });
                      });
                }
                function Wt(t) {
                  return !(!t || !t[Kt]);
                }
                n(Ct, mt),
                  (Ct.of = function () {
                    var n = t.call(arguments, 0);
                    return Xt().withMutations(function (t) {
                      for (var r = 0; r < n.length; r += 2) {
                        if (r + 1 >= n.length)
                          throw new Error("Missing value for key: " + n[r]);
                        t.set(n[r], n[r + 1]);
                      }
                    });
                  }),
                  (Ct.prototype.toString = function () {
                    return this.__toString("Map {", "}");
                  }),
                  (Ct.prototype.get = function (t, n) {
                    return this._root ? this._root.get(0, void 0, t, n) : n;
                  }),
                  (Ct.prototype.set = function (t, n) {
                    return Qt(this, t, n);
                  }),
                  (Ct.prototype.setIn = function (t, n) {
                    return this.updateIn(t, g, function () {
                      return n;
                    });
                  }),
                  (Ct.prototype.remove = function (t) {
                    return Qt(this, t, g);
                  }),
                  (Ct.prototype.deleteIn = function (t) {
                    return this.updateIn(t, function () {
                      return g;
                    });
                  }),
                  (Ct.prototype.update = function (t, n, r) {
                    return 1 === arguments.length
                      ? t(this)
                      : this.updateIn([t], n, r);
                  }),
                  (Ct.prototype.updateIn = function (t, n, r) {
                    r || ((r = n), (n = void 0));
                    var e = (function t(n, r, e, i) {
                      var u = n === g,
                        o = r.next();
                      if (o.done) {
                        var a = u ? e : n,
                          f = i(a);
                        return f === a ? n : f;
                      }
                      dt(u || (n && n.set), "invalid keyPath");
                      var c = o.value,
                        s = u ? g : n.get(c, g),
                        h = t(s, r, e, i);
                      return h === s
                        ? n
                        : h === g
                        ? n.remove(c)
                        : (u ? Xt() : n).set(c, h);
                    })(this, ir(t), n, r);
                    return e === g ? void 0 : e;
                  }),
                  (Ct.prototype.clear = function () {
                    return 0 === this.size
                      ? this
                      : this.__ownerID
                      ? ((this.size = 0),
                        (this._root = null),
                        (this.__hash = void 0),
                        (this.__altered = !0),
                        this)
                      : Xt();
                  }),
                  (Ct.prototype.merge = function () {
                    return en(this, void 0, arguments);
                  }),
                  (Ct.prototype.mergeWith = function (n) {
                    var r = t.call(arguments, 1);
                    return en(this, n, r);
                  }),
                  (Ct.prototype.mergeIn = function (n) {
                    var r = t.call(arguments, 1);
                    return this.updateIn(n, Xt(), function (t) {
                      return "function" == typeof t.merge
                        ? t.merge.apply(t, r)
                        : r[r.length - 1];
                    });
                  }),
                  (Ct.prototype.mergeDeep = function () {
                    return en(this, un, arguments);
                  }),
                  (Ct.prototype.mergeDeepWith = function (n) {
                    var r = t.call(arguments, 1);
                    return en(this, on(n), r);
                  }),
                  (Ct.prototype.mergeDeepIn = function (n) {
                    var r = t.call(arguments, 1);
                    return this.updateIn(n, Xt(), function (t) {
                      return "function" == typeof t.mergeDeep
                        ? t.mergeDeep.apply(t, r)
                        : r[r.length - 1];
                    });
                  }),
                  (Ct.prototype.sort = function (t) {
                    return kn(Hn(this, t));
                  }),
                  (Ct.prototype.sortBy = function (t, n) {
                    return kn(Hn(this, n, t));
                  }),
                  (Ct.prototype.withMutations = function (t) {
                    var n = this.asMutable();
                    return (
                      t(n),
                      n.wasAltered() ? n.__ensureOwner(this.__ownerID) : this
                    );
                  }),
                  (Ct.prototype.asMutable = function () {
                    return this.__ownerID ? this : this.__ensureOwner(new I());
                  }),
                  (Ct.prototype.asImmutable = function () {
                    return this.__ensureOwner();
                  }),
                  (Ct.prototype.wasAltered = function () {
                    return this.__altered;
                  }),
                  (Ct.prototype.__iterator = function (t, n) {
                    return new Vt(this, t, n);
                  }),
                  (Ct.prototype.__iterate = function (t, n) {
                    var r = this,
                      e = 0;
                    return (
                      this._root &&
                        this._root.iterate(function (n) {
                          return e++, t(n[1], n[0], r);
                        }, n),
                      e
                    );
                  }),
                  (Ct.prototype.__ensureOwner = function (t) {
                    return t === this.__ownerID
                      ? this
                      : t
                      ? Yt(this.size, this._root, t, this.__hash)
                      : ((this.__ownerID = t), (this.__altered = !1), this);
                  }),
                  (Ct.isMap = Wt);
                var Bt,
                  Kt = "@@__IMMUTABLE_MAP__@@",
                  Pt = Ct.prototype;
                function Nt(t, n) {
                  (this.ownerID = t), (this.entries = n);
                }
                function $t(t, n, r) {
                  (this.ownerID = t), (this.bitmap = n), (this.nodes = r);
                }
                function Ft(t, n, r) {
                  (this.ownerID = t), (this.count = n), (this.nodes = r);
                }
                function Jt(t, n, r) {
                  (this.ownerID = t), (this.keyHash = n), (this.entries = r);
                }
                function Ht(t, n, r) {
                  (this.ownerID = t), (this.keyHash = n), (this.entry = r);
                }
                function Vt(t, n, r) {
                  (this._type = n),
                    (this._reverse = r),
                    (this._stack = t._root && Gt(t._root));
                }
                function Zt(t, n) {
                  return W(t, n[0], n[1]);
                }
                function Gt(t, n) {
                  return { node: t, index: 0, __prev: n };
                }
                function Yt(t, n, r, e) {
                  var i = Object.create(Pt);
                  return (
                    (i.size = t),
                    (i._root = n),
                    (i.__ownerID = r),
                    (i.__hash = e),
                    (i.__altered = !1),
                    i
                  );
                }
                function Xt() {
                  return Bt || (Bt = Yt(0));
                }
                function Qt(t, n, r) {
                  var e, i;
                  if (t._root) {
                    var u = b(w),
                      o = b(m);
                    if (
                      ((e = tn(t._root, t.__ownerID, 0, void 0, n, r, u, o)),
                      !o.value)
                    )
                      return t;
                    i = t.size + (u.value ? (r === g ? -1 : 1) : 0);
                  } else {
                    if (r === g) return t;
                    (i = 1), (e = new Nt(t.__ownerID, [[n, r]]));
                  }
                  return t.__ownerID
                    ? ((t.size = i),
                      (t._root = e),
                      (t.__hash = void 0),
                      (t.__altered = !0),
                      t)
                    : e
                    ? Yt(i, e)
                    : Xt();
                }
                function tn(t, n, r, e, i, u, o, a) {
                  return t
                    ? t.update(n, r, e, i, u, o, a)
                    : u === g
                    ? t
                    : (S(a), S(o), new Ht(n, e, [i, u]));
                }
                function nn(t) {
                  return t.constructor === Ht || t.constructor === Jt;
                }
                function rn(t, n, r, e, i) {
                  if (t.keyHash === e) return new Jt(n, e, [t.entry, i]);
                  var u,
                    o = (0 === r ? t.keyHash : t.keyHash >>> r) & d,
                    a = (0 === r ? e : e >>> r) & d;
                  return new $t(
                    n,
                    (1 << o) | (1 << a),
                    o === a
                      ? [rn(t, n, r + v, e, i)]
                      : ((u = new Ht(n, e, i)), o < a ? [t, u] : [u, t])
                  );
                }
                function en(t, n, r) {
                  for (var i = [], u = 0; u < r.length; u++) {
                    var a = r[u],
                      f = e(a);
                    o(a) ||
                      (f = f.map(function (t) {
                        return ht(t);
                      })),
                      i.push(f);
                  }
                  return an(t, n, i);
                }
                function un(t, n, r) {
                  return t && t.mergeDeep && o(n)
                    ? t.mergeDeep(n)
                    : _t(t, n)
                    ? t
                    : n;
                }
                function on(t) {
                  return function (n, r, e) {
                    if (n && n.mergeDeepWith && o(r))
                      return n.mergeDeepWith(t, r);
                    var i = t(n, r, e);
                    return _t(n, i) ? n : i;
                  };
                }
                function an(t, n, r) {
                  return 0 ===
                    (r = r.filter(function (t) {
                      return 0 !== t.size;
                    })).length
                    ? t
                    : 0 !== t.size || t.__ownerID || 1 !== r.length
                    ? t.withMutations(function (t) {
                        for (
                          var e = n
                              ? function (r, e) {
                                  t.update(e, g, function (t) {
                                    return t === g ? r : n(t, r, e);
                                  });
                                }
                              : function (n, r) {
                                  t.set(r, n);
                                },
                            i = 0;
                          i < r.length;
                          i++
                        )
                          r[i].forEach(e);
                      })
                    : t.constructor(r[0]);
                }
                function fn(t) {
                  return (
                    (t =
                      ((t =
                        (858993459 & (t -= (t >> 1) & 1431655765)) +
                        ((t >> 2) & 858993459)) +
                        (t >> 4)) &
                      252645135),
                    (t += t >> 8),
                    127 & (t += t >> 16)
                  );
                }
                function cn(t, n, r, e) {
                  var i = e ? t : z(t);
                  return (i[n] = r), i;
                }
                (Pt[Kt] = !0),
                  (Pt.delete = Pt.remove),
                  (Pt.removeIn = Pt.deleteIn),
                  (Nt.prototype.get = function (t, n, r, e) {
                    for (var i = this.entries, u = 0, o = i.length; u < o; u++)
                      if (_t(r, i[u][0])) return i[u][1];
                    return e;
                  }),
                  (Nt.prototype.update = function (t, n, r, e, i, u, o) {
                    for (
                      var a = i === g, f = this.entries, c = 0, s = f.length;
                      c < s && !_t(e, f[c][0]);
                      c++
                    );
                    var h = c < s;
                    if (h ? f[c][1] === i : a) return this;
                    if ((S(o), (a || !h) && S(u), !a || 1 !== f.length)) {
                      if (!h && !a && f.length >= sn)
                        return (function (t, n, r, e) {
                          t || (t = new I());
                          for (
                            var i = new Ht(t, xt(r), [r, e]), u = 0;
                            u < n.length;
                            u++
                          ) {
                            var o = n[u];
                            i = i.update(t, 0, void 0, o[0], o[1]);
                          }
                          return i;
                        })(t, f, e, i);
                      var l = t && t === this.ownerID,
                        p = l ? f : z(f);
                      return (
                        h
                          ? a
                            ? c === s - 1
                              ? p.pop()
                              : (p[c] = p.pop())
                            : (p[c] = [e, i])
                          : p.push([e, i]),
                        l ? ((this.entries = p), this) : new Nt(t, p)
                      );
                    }
                  }),
                  ($t.prototype.get = function (t, n, r, e) {
                    void 0 === n && (n = xt(r));
                    var i = 1 << ((0 === t ? n : n >>> t) & d),
                      u = this.bitmap;
                    return 0 == (u & i)
                      ? e
                      : this.nodes[fn(u & (i - 1))].get(t + v, n, r, e);
                  }),
                  ($t.prototype.update = function (t, n, r, e, i, u, o) {
                    void 0 === r && (r = xt(e));
                    var a = (0 === n ? r : r >>> n) & d,
                      f = 1 << a,
                      c = this.bitmap,
                      s = 0 != (c & f);
                    if (!s && i === g) return this;
                    var h = fn(c & (f - 1)),
                      l = this.nodes,
                      p = s ? l[h] : void 0,
                      _ = tn(p, t, n + v, r, e, i, u, o);
                    if (_ === p) return this;
                    if (!s && _ && l.length >= hn)
                      return (function (t, n, r, e, i) {
                        for (
                          var u = 0, o = new Array(y), a = 0;
                          0 !== r;
                          a++, r >>>= 1
                        )
                          o[a] = 1 & r ? n[u++] : void 0;
                        return (o[e] = i), new Ft(t, u + 1, o);
                      })(t, l, c, a, _);
                    if (s && !_ && 2 === l.length && nn(l[1 ^ h]))
                      return l[1 ^ h];
                    if (s && _ && 1 === l.length && nn(_)) return _;
                    var w = t && t === this.ownerID,
                      m = s ? (_ ? c : c ^ f) : c | f,
                      b = s
                        ? _
                          ? cn(l, h, _, w)
                          : (function (t, n, r) {
                              var e = t.length - 1;
                              if (r && n === e) return t.pop(), t;
                              for (
                                var i = new Array(e), u = 0, o = 0;
                                o < e;
                                o++
                              )
                                o === n && (u = 1), (i[o] = t[o + u]);
                              return i;
                            })(l, h, w)
                        : (function (t, n, r, e) {
                            var i = t.length + 1;
                            if (e && n + 1 === i) return (t[n] = r), t;
                            for (var u = new Array(i), o = 0, a = 0; a < i; a++)
                              a === n
                                ? ((u[a] = r), (o = -1))
                                : (u[a] = t[a + o]);
                            return u;
                          })(l, h, _, w);
                    return w
                      ? ((this.bitmap = m), (this.nodes = b), this)
                      : new $t(t, m, b);
                  }),
                  (Ft.prototype.get = function (t, n, r, e) {
                    void 0 === n && (n = xt(r));
                    var i = (0 === t ? n : n >>> t) & d,
                      u = this.nodes[i];
                    return u ? u.get(t + v, n, r, e) : e;
                  }),
                  (Ft.prototype.update = function (t, n, r, e, i, u, o) {
                    void 0 === r && (r = xt(e));
                    var a = (0 === n ? r : r >>> n) & d,
                      f = i === g,
                      c = this.nodes,
                      s = c[a];
                    if (f && !s) return this;
                    var h = tn(s, t, n + v, r, e, i, u, o);
                    if (h === s) return this;
                    var l = this.count;
                    if (s) {
                      if (!h && --l < ln)
                        return (function (t, n, r, e) {
                          for (
                            var i = 0,
                              u = 0,
                              o = new Array(r),
                              a = 0,
                              f = 1,
                              c = n.length;
                            a < c;
                            a++, f <<= 1
                          ) {
                            var s = n[a];
                            void 0 !== s && a !== e && ((i |= f), (o[u++] = s));
                          }
                          return new $t(t, i, o);
                        })(t, c, l, a);
                    } else l++;
                    var p = t && t === this.ownerID,
                      _ = cn(c, a, h, p);
                    return p
                      ? ((this.count = l), (this.nodes = _), this)
                      : new Ft(t, l, _);
                  }),
                  (Jt.prototype.get = function (t, n, r, e) {
                    for (var i = this.entries, u = 0, o = i.length; u < o; u++)
                      if (_t(r, i[u][0])) return i[u][1];
                    return e;
                  }),
                  (Jt.prototype.update = function (t, n, r, e, i, u, o) {
                    void 0 === r && (r = xt(e));
                    var a = i === g;
                    if (r !== this.keyHash)
                      return a ? this : (S(o), S(u), rn(this, t, n, r, [e, i]));
                    for (
                      var f = this.entries, c = 0, s = f.length;
                      c < s && !_t(e, f[c][0]);
                      c++
                    );
                    var h = c < s;
                    if (h ? f[c][1] === i : a) return this;
                    if ((S(o), (a || !h) && S(u), a && 2 === s))
                      return new Ht(t, this.keyHash, f[1 ^ c]);
                    var l = t && t === this.ownerID,
                      p = l ? f : z(f);
                    return (
                      h
                        ? a
                          ? c === s - 1
                            ? p.pop()
                            : (p[c] = p.pop())
                          : (p[c] = [e, i])
                        : p.push([e, i]),
                      l
                        ? ((this.entries = p), this)
                        : new Jt(t, this.keyHash, p)
                    );
                  }),
                  (Ht.prototype.get = function (t, n, r, e) {
                    return _t(r, this.entry[0]) ? this.entry[1] : e;
                  }),
                  (Ht.prototype.update = function (t, n, r, e, i, u, o) {
                    var a = i === g,
                      f = _t(e, this.entry[0]);
                    return (f ? i === this.entry[1] : a)
                      ? this
                      : (S(o),
                        a
                          ? void S(u)
                          : f
                          ? t && t === this.ownerID
                            ? ((this.entry[1] = i), this)
                            : new Ht(t, this.keyHash, [e, i])
                          : (S(u), rn(this, t, n, xt(e), [e, i])));
                  }),
                  (Nt.prototype.iterate = Jt.prototype.iterate = function (
                    t,
                    n
                  ) {
                    for (
                      var r = this.entries, e = 0, i = r.length - 1;
                      e <= i;
                      e++
                    )
                      if (!1 === t(r[n ? i - e : e])) return !1;
                  }),
                  ($t.prototype.iterate = Ft.prototype.iterate = function (
                    t,
                    n
                  ) {
                    for (
                      var r = this.nodes, e = 0, i = r.length - 1;
                      e <= i;
                      e++
                    ) {
                      var u = r[n ? i - e : e];
                      if (u && !1 === u.iterate(t, n)) return !1;
                    }
                  }),
                  (Ht.prototype.iterate = function (t, n) {
                    return t(this.entry);
                  }),
                  n(Vt, C),
                  (Vt.prototype.next = function () {
                    for (var t = this._type, n = this._stack; n; ) {
                      var r,
                        e = n.node,
                        i = n.index++;
                      if (e.entry) {
                        if (0 === i) return Zt(t, e.entry);
                      } else if (e.entries) {
                        if (i <= (r = e.entries.length - 1))
                          return Zt(t, e.entries[this._reverse ? r - i : i]);
                      } else if (i <= (r = e.nodes.length - 1)) {
                        var u = e.nodes[this._reverse ? r - i : i];
                        if (u) {
                          if (u.entry) return Zt(t, u.entry);
                          n = this._stack = Gt(u, n);
                        }
                        continue;
                      }
                      n = this._stack = this._stack.__prev;
                    }
                    return { value: void 0, done: !0 };
                  });
                var sn = y / 4,
                  hn = y / 2,
                  ln = y / 4;
                function pn(t) {
                  var n = In();
                  if (null == t) return n;
                  if (_n(t)) return t;
                  var r = i(t),
                    e = r.size;
                  return 0 === e
                    ? n
                    : (Ut(e),
                      e > 0 && e < y
                        ? Sn(0, e, v, null, new dn(r.toArray()))
                        : n.withMutations(function (t) {
                            t.setSize(e),
                              r.forEach(function (n, r) {
                                return t.set(r, n);
                              });
                          }));
                }
                function _n(t) {
                  return !(!t || !t[vn]);
                }
                n(pn, bt),
                  (pn.of = function () {
                    return this(arguments);
                  }),
                  (pn.prototype.toString = function () {
                    return this.__toString("List [", "]");
                  }),
                  (pn.prototype.get = function (t, n) {
                    if ((t = O(this, t)) >= 0 && t < this.size) {
                      var r = On(this, (t += this._origin));
                      return r && r.array[t & d];
                    }
                    return n;
                  }),
                  (pn.prototype.set = function (t, n) {
                    return (function (t, n, r) {
                      if ((n = O(t, n)) != n) return t;
                      if (n >= t.size || n < 0)
                        return t.withMutations(function (t) {
                          n < 0
                            ? jn(t, n).set(0, r)
                            : jn(t, 0, n + 1).set(n, r);
                        });
                      n += t._origin;
                      var e = t._tail,
                        i = t._root,
                        u = b(m);
                      return (
                        n >= En(t._capacity)
                          ? (e = zn(e, t.__ownerID, 0, n, r, u))
                          : (i = zn(i, t.__ownerID, t._level, n, r, u)),
                        u.value
                          ? t.__ownerID
                            ? ((t._root = i),
                              (t._tail = e),
                              (t.__hash = void 0),
                              (t.__altered = !0),
                              t)
                            : Sn(t._origin, t._capacity, t._level, i, e)
                          : t
                      );
                    })(this, t, n);
                  }),
                  (pn.prototype.remove = function (t) {
                    return this.has(t)
                      ? 0 === t
                        ? this.shift()
                        : t === this.size - 1
                        ? this.pop()
                        : this.splice(t, 1)
                      : this;
                  }),
                  (pn.prototype.insert = function (t, n) {
                    return this.splice(t, 0, n);
                  }),
                  (pn.prototype.clear = function () {
                    return 0 === this.size
                      ? this
                      : this.__ownerID
                      ? ((this.size = this._origin = this._capacity = 0),
                        (this._level = v),
                        (this._root = this._tail = null),
                        (this.__hash = void 0),
                        (this.__altered = !0),
                        this)
                      : In();
                  }),
                  (pn.prototype.push = function () {
                    var t = arguments,
                      n = this.size;
                    return this.withMutations(function (r) {
                      jn(r, 0, n + t.length);
                      for (var e = 0; e < t.length; e++) r.set(n + e, t[e]);
                    });
                  }),
                  (pn.prototype.pop = function () {
                    return jn(this, 0, -1);
                  }),
                  (pn.prototype.unshift = function () {
                    var t = arguments;
                    return this.withMutations(function (n) {
                      jn(n, -t.length);
                      for (var r = 0; r < t.length; r++) n.set(r, t[r]);
                    });
                  }),
                  (pn.prototype.shift = function () {
                    return jn(this, 1);
                  }),
                  (pn.prototype.merge = function () {
                    return An(this, void 0, arguments);
                  }),
                  (pn.prototype.mergeWith = function (n) {
                    var r = t.call(arguments, 1);
                    return An(this, n, r);
                  }),
                  (pn.prototype.mergeDeep = function () {
                    return An(this, un, arguments);
                  }),
                  (pn.prototype.mergeDeepWith = function (n) {
                    var r = t.call(arguments, 1);
                    return An(this, on(n), r);
                  }),
                  (pn.prototype.setSize = function (t) {
                    return jn(this, 0, t);
                  }),
                  (pn.prototype.slice = function (t, n) {
                    var r = this.size;
                    return A(t, n, r) ? this : jn(this, E(t, r), k(n, r));
                  }),
                  (pn.prototype.__iterator = function (t, n) {
                    var r = 0,
                      e = bn(this, n);
                    return new C(function () {
                      var n = e();
                      return n === mn
                        ? { value: void 0, done: !0 }
                        : W(t, r++, n);
                    });
                  }),
                  (pn.prototype.__iterate = function (t, n) {
                    for (
                      var r, e = 0, i = bn(this, n);
                      (r = i()) !== mn && !1 !== t(r, e++, this);

                    );
                    return e;
                  }),
                  (pn.prototype.__ensureOwner = function (t) {
                    return t === this.__ownerID
                      ? this
                      : t
                      ? Sn(
                          this._origin,
                          this._capacity,
                          this._level,
                          this._root,
                          this._tail,
                          t,
                          this.__hash
                        )
                      : ((this.__ownerID = t), this);
                  }),
                  (pn.isList = _n);
                var vn = "@@__IMMUTABLE_LIST__@@",
                  yn = pn.prototype;
                function dn(t, n) {
                  (this.array = t), (this.ownerID = n);
                }
                (yn[vn] = !0),
                  (yn.delete = yn.remove),
                  (yn.setIn = Pt.setIn),
                  (yn.deleteIn = yn.removeIn = Pt.removeIn),
                  (yn.update = Pt.update),
                  (yn.updateIn = Pt.updateIn),
                  (yn.mergeIn = Pt.mergeIn),
                  (yn.mergeDeepIn = Pt.mergeDeepIn),
                  (yn.withMutations = Pt.withMutations),
                  (yn.asMutable = Pt.asMutable),
                  (yn.asImmutable = Pt.asImmutable),
                  (yn.wasAltered = Pt.wasAltered),
                  (dn.prototype.removeBefore = function (t, n, r) {
                    if (r === n ? 1 << n : 0 === this.array.length) return this;
                    var e = (r >>> n) & d;
                    if (e >= this.array.length) return new dn([], t);
                    var i,
                      u = 0 === e;
                    if (n > 0) {
                      var o = this.array[e];
                      if ((i = o && o.removeBefore(t, n - v, r)) === o && u)
                        return this;
                    }
                    if (u && !i) return this;
                    var a = xn(this, t);
                    if (!u) for (var f = 0; f < e; f++) a.array[f] = void 0;
                    return i && (a.array[e] = i), a;
                  }),
                  (dn.prototype.removeAfter = function (t, n, r) {
                    if (r === (n ? 1 << n : 0) || 0 === this.array.length)
                      return this;
                    var e,
                      i = ((r - 1) >>> n) & d;
                    if (i >= this.array.length) return this;
                    if (n > 0) {
                      var u = this.array[i];
                      if (
                        (e = u && u.removeAfter(t, n - v, r)) === u &&
                        i === this.array.length - 1
                      )
                        return this;
                    }
                    var o = xn(this, t);
                    return o.array.splice(i + 1), e && (o.array[i] = e), o;
                  });
                var gn,
                  wn,
                  mn = {};
                function bn(t, n) {
                  var r = t._origin,
                    e = t._capacity,
                    i = En(e),
                    u = t._tail;
                  return o(t._root, t._level, 0);
                  function o(t, a, f) {
                    return 0 === a
                      ? (function (t, o) {
                          var a = o === i ? u && u.array : t && t.array,
                            f = o > r ? 0 : r - o,
                            c = e - o;
                          return (
                            c > y && (c = y),
                            function () {
                              if (f === c) return mn;
                              var t = n ? --c : f++;
                              return a && a[t];
                            }
                          );
                        })(t, f)
                      : (function (t, i, u) {
                          var a,
                            f = t && t.array,
                            c = u > r ? 0 : (r - u) >> i,
                            s = 1 + ((e - u) >> i);
                          return (
                            s > y && (s = y),
                            function () {
                              for (;;) {
                                if (a) {
                                  var t = a();
                                  if (t !== mn) return t;
                                  a = null;
                                }
                                if (c === s) return mn;
                                var r = n ? --s : c++;
                                a = o(f && f[r], i - v, u + (r << i));
                              }
                            }
                          );
                        })(t, a, f);
                  }
                }
                function Sn(t, n, r, e, i, u, o) {
                  var a = Object.create(yn);
                  return (
                    (a.size = n - t),
                    (a._origin = t),
                    (a._capacity = n),
                    (a._level = r),
                    (a._root = e),
                    (a._tail = i),
                    (a.__ownerID = u),
                    (a.__hash = o),
                    (a.__altered = !1),
                    a
                  );
                }
                function In() {
                  return gn || (gn = Sn(0, 0, v));
                }
                function zn(t, n, r, e, i, u) {
                  var o,
                    a = (e >>> r) & d,
                    f = t && a < t.array.length;
                  if (!f && void 0 === i) return t;
                  if (r > 0) {
                    var c = t && t.array[a],
                      s = zn(c, n, r - v, e, i, u);
                    return s === c ? t : (((o = xn(t, n)).array[a] = s), o);
                  }
                  return f && t.array[a] === i
                    ? t
                    : (S(u),
                      (o = xn(t, n)),
                      void 0 === i && a === o.array.length - 1
                        ? o.array.pop()
                        : (o.array[a] = i),
                      o);
                }
                function xn(t, n) {
                  return n && t && n === t.ownerID
                    ? t
                    : new dn(t ? t.array.slice() : [], n);
                }
                function On(t, n) {
                  if (n >= En(t._capacity)) return t._tail;
                  if (n < 1 << (t._level + v)) {
                    for (var r = t._root, e = t._level; r && e > 0; )
                      (r = r.array[(n >>> e) & d]), (e -= v);
                    return r;
                  }
                }
                function jn(t, n, r) {
                  void 0 !== n && (n |= 0), void 0 !== r && (r |= 0);
                  var e = t.__ownerID || new I(),
                    i = t._origin,
                    u = t._capacity,
                    o = i + n,
                    a = void 0 === r ? u : r < 0 ? u + r : i + r;
                  if (o === i && a === u) return t;
                  if (o >= a) return t.clear();
                  for (var f = t._level, c = t._root, s = 0; o + s < 0; )
                    (c = new dn(c && c.array.length ? [void 0, c] : [], e)),
                      (s += 1 << (f += v));
                  s && ((o += s), (i += s), (a += s), (u += s));
                  for (var h = En(u), l = En(a); l >= 1 << (f + v); )
                    (c = new dn(c && c.array.length ? [c] : [], e)), (f += v);
                  var p = t._tail,
                    _ = l < h ? On(t, a - 1) : l > h ? new dn([], e) : p;
                  if (p && l > h && o < u && p.array.length) {
                    for (var y = (c = xn(c, e)), g = f; g > v; g -= v) {
                      var w = (h >>> g) & d;
                      y = y.array[w] = xn(y.array[w], e);
                    }
                    y.array[(h >>> v) & d] = p;
                  }
                  if ((a < u && (_ = _ && _.removeAfter(e, 0, a)), o >= l))
                    (o -= l),
                      (a -= l),
                      (f = v),
                      (c = null),
                      (_ = _ && _.removeBefore(e, 0, o));
                  else if (o > i || l < h) {
                    for (s = 0; c; ) {
                      var m = (o >>> f) & d;
                      if ((m !== l >>> f) & d) break;
                      m && (s += (1 << f) * m), (f -= v), (c = c.array[m]);
                    }
                    c && o > i && (c = c.removeBefore(e, f, o - s)),
                      c && l < h && (c = c.removeAfter(e, f, l - s)),
                      s && ((o -= s), (a -= s));
                  }
                  return t.__ownerID
                    ? ((t.size = a - o),
                      (t._origin = o),
                      (t._capacity = a),
                      (t._level = f),
                      (t._root = c),
                      (t._tail = _),
                      (t.__hash = void 0),
                      (t.__altered = !0),
                      t)
                    : Sn(o, a, f, c, _);
                }
                function An(t, n, r) {
                  for (var e = [], u = 0, a = 0; a < r.length; a++) {
                    var f = r[a],
                      c = i(f);
                    c.size > u && (u = c.size),
                      o(f) ||
                        (c = c.map(function (t) {
                          return ht(t);
                        })),
                      e.push(c);
                  }
                  return u > t.size && (t = t.setSize(u)), an(t, n, e);
                }
                function En(t) {
                  return t < y ? 0 : ((t - 1) >>> v) << v;
                }
                function kn(t) {
                  return null == t
                    ? qn()
                    : Mn(t)
                    ? t
                    : qn().withMutations(function (n) {
                        var r = e(t);
                        Ut(r.size),
                          r.forEach(function (t, r) {
                            return n.set(r, t);
                          });
                      });
                }
                function Mn(t) {
                  return Wt(t) && s(t);
                }
                function Dn(t, n, r, e) {
                  var i = Object.create(kn.prototype);
                  return (
                    (i.size = t ? t.size : 0),
                    (i._map = t),
                    (i._list = n),
                    (i.__ownerID = r),
                    (i.__hash = e),
                    i
                  );
                }
                function qn() {
                  return wn || (wn = Dn(Xt(), In()));
                }
                function Rn(t, n, r) {
                  var e,
                    i,
                    u = t._map,
                    o = t._list,
                    a = u.get(n),
                    f = void 0 !== a;
                  if (r === g) {
                    if (!f) return t;
                    o.size >= y && o.size >= 2 * u.size
                      ? ((e = (i = o.filter(function (t, n) {
                          return void 0 !== t && a !== n;
                        }))
                          .toKeyedSeq()
                          .map(function (t) {
                            return t[0];
                          })
                          .flip()
                          .toMap()),
                        t.__ownerID &&
                          (e.__ownerID = i.__ownerID = t.__ownerID))
                      : ((e = u.remove(n)),
                        (i = a === o.size - 1 ? o.pop() : o.set(a, void 0)));
                  } else if (f) {
                    if (r === o.get(a)[1]) return t;
                    (e = u), (i = o.set(a, [n, r]));
                  } else (e = u.set(n, o.size)), (i = o.set(o.size, [n, r]));
                  return t.__ownerID
                    ? ((t.size = e.size),
                      (t._map = e),
                      (t._list = i),
                      (t.__hash = void 0),
                      t)
                    : Dn(e, i);
                }
                function Ln(t, n) {
                  (this._iter = t), (this._useKeys = n), (this.size = t.size);
                }
                function Tn(t) {
                  (this._iter = t), (this.size = t.size);
                }
                function Un(t) {
                  (this._iter = t), (this.size = t.size);
                }
                function Cn(t) {
                  (this._iter = t), (this.size = t.size);
                }
                function Wn(t) {
                  var n = nr(t);
                  return (
                    (n._iter = t),
                    (n.size = t.size),
                    (n.flip = function () {
                      return t;
                    }),
                    (n.reverse = function () {
                      var n = t.reverse.apply(this);
                      return (
                        (n.flip = function () {
                          return t.reverse();
                        }),
                        n
                      );
                    }),
                    (n.has = function (n) {
                      return t.includes(n);
                    }),
                    (n.includes = function (n) {
                      return t.has(n);
                    }),
                    (n.cacheResult = rr),
                    (n.__iterateUncached = function (n, r) {
                      var e = this;
                      return t.__iterate(function (t, r) {
                        return !1 !== n(r, t, e);
                      }, r);
                    }),
                    (n.__iteratorUncached = function (n, r) {
                      if (n === R) {
                        var e = t.__iterator(n, r);
                        return new C(function () {
                          var t = e.next();
                          if (!t.done) {
                            var n = t.value[0];
                            (t.value[0] = t.value[1]), (t.value[1] = n);
                          }
                          return t;
                        });
                      }
                      return t.__iterator(n === q ? D : q, r);
                    }),
                    n
                  );
                }
                function Bn(t, n, r) {
                  var e = nr(t);
                  return (
                    (e.size = t.size),
                    (e.has = function (n) {
                      return t.has(n);
                    }),
                    (e.get = function (e, i) {
                      var u = t.get(e, g);
                      return u === g ? i : n.call(r, u, e, t);
                    }),
                    (e.__iterateUncached = function (e, i) {
                      var u = this;
                      return t.__iterate(function (t, i, o) {
                        return !1 !== e(n.call(r, t, i, o), i, u);
                      }, i);
                    }),
                    (e.__iteratorUncached = function (e, i) {
                      var u = t.__iterator(R, i);
                      return new C(function () {
                        var i = u.next();
                        if (i.done) return i;
                        var o = i.value,
                          a = o[0];
                        return W(e, a, n.call(r, o[1], a, t), i);
                      });
                    }),
                    e
                  );
                }
                function Kn(t, n) {
                  var r = nr(t);
                  return (
                    (r._iter = t),
                    (r.size = t.size),
                    (r.reverse = function () {
                      return t;
                    }),
                    t.flip &&
                      (r.flip = function () {
                        var n = Wn(t);
                        return (
                          (n.reverse = function () {
                            return t.flip();
                          }),
                          n
                        );
                      }),
                    (r.get = function (r, e) {
                      return t.get(n ? r : -1 - r, e);
                    }),
                    (r.has = function (r) {
                      return t.has(n ? r : -1 - r);
                    }),
                    (r.includes = function (n) {
                      return t.includes(n);
                    }),
                    (r.cacheResult = rr),
                    (r.__iterate = function (n, r) {
                      var e = this;
                      return t.__iterate(function (t, r) {
                        return n(t, r, e);
                      }, !r);
                    }),
                    (r.__iterator = function (n, r) {
                      return t.__iterator(n, !r);
                    }),
                    r
                  );
                }
                function Pn(t, n, r, e) {
                  var i = nr(t);
                  return (
                    e &&
                      ((i.has = function (e) {
                        var i = t.get(e, g);
                        return i !== g && !!n.call(r, i, e, t);
                      }),
                      (i.get = function (e, i) {
                        var u = t.get(e, g);
                        return u !== g && n.call(r, u, e, t) ? u : i;
                      })),
                    (i.__iterateUncached = function (i, u) {
                      var o = this,
                        a = 0;
                      return (
                        t.__iterate(function (t, u, f) {
                          if (n.call(r, t, u, f))
                            return a++, i(t, e ? u : a - 1, o);
                        }, u),
                        a
                      );
                    }),
                    (i.__iteratorUncached = function (i, u) {
                      var o = t.__iterator(R, u),
                        a = 0;
                      return new C(function () {
                        for (;;) {
                          var u = o.next();
                          if (u.done) return u;
                          var f = u.value,
                            c = f[0],
                            s = f[1];
                          if (n.call(r, s, c, t))
                            return W(i, e ? c : a++, s, u);
                        }
                      });
                    }),
                    i
                  );
                }
                function Nn(t, n, r, e) {
                  var i = t.size;
                  if (
                    (void 0 !== n && (n |= 0),
                    void 0 !== r && (r === 1 / 0 ? (r = i) : (r |= 0)),
                    A(n, r, i))
                  )
                    return t;
                  var u = E(n, i),
                    o = k(r, i);
                  if (u != u || o != o)
                    return Nn(t.toSeq().cacheResult(), n, r, e);
                  var a,
                    f = o - u;
                  f == f && (a = f < 0 ? 0 : f);
                  var c = nr(t);
                  return (
                    (c.size = 0 === a ? a : (t.size && a) || void 0),
                    !e &&
                      it(t) &&
                      a >= 0 &&
                      (c.get = function (n, r) {
                        return (n = O(this, n)) >= 0 && n < a
                          ? t.get(n + u, r)
                          : r;
                      }),
                    (c.__iterateUncached = function (n, r) {
                      var i = this;
                      if (0 === a) return 0;
                      if (r) return this.cacheResult().__iterate(n, r);
                      var o = 0,
                        f = !0,
                        c = 0;
                      return (
                        t.__iterate(function (t, r) {
                          if (!f || !(f = o++ < u))
                            return (
                              c++, !1 !== n(t, e ? r : c - 1, i) && c !== a
                            );
                        }),
                        c
                      );
                    }),
                    (c.__iteratorUncached = function (n, r) {
                      if (0 !== a && r)
                        return this.cacheResult().__iterator(n, r);
                      var i = 0 !== a && t.__iterator(n, r),
                        o = 0,
                        f = 0;
                      return new C(function () {
                        for (; o++ < u; ) i.next();
                        if (++f > a) return { value: void 0, done: !0 };
                        var t = i.next();
                        return e || n === q
                          ? t
                          : W(n, f - 1, n === D ? void 0 : t.value[1], t);
                      });
                    }),
                    c
                  );
                }
                function $n(t, n, r, e) {
                  var i = nr(t);
                  return (
                    (i.__iterateUncached = function (i, u) {
                      var o = this;
                      if (u) return this.cacheResult().__iterate(i, u);
                      var a = !0,
                        f = 0;
                      return (
                        t.__iterate(function (t, u, c) {
                          if (!a || !(a = n.call(r, t, u, c)))
                            return f++, i(t, e ? u : f - 1, o);
                        }),
                        f
                      );
                    }),
                    (i.__iteratorUncached = function (i, u) {
                      var o = this;
                      if (u) return this.cacheResult().__iterator(i, u);
                      var a = t.__iterator(R, u),
                        f = !0,
                        c = 0;
                      return new C(function () {
                        var t, u, s;
                        do {
                          if ((t = a.next()).done)
                            return e || i === q
                              ? t
                              : W(i, c++, i === D ? void 0 : t.value[1], t);
                          var h = t.value;
                          (u = h[0]), (s = h[1]), f && (f = n.call(r, s, u, o));
                        } while (f);
                        return i === R ? t : W(i, u, s, t);
                      });
                    }),
                    i
                  );
                }
                function Fn(t, n) {
                  var r = a(t),
                    i = [t]
                      .concat(n)
                      .map(function (t) {
                        return (
                          o(t)
                            ? r && (t = e(t))
                            : (t = r ? ot(t) : at(Array.isArray(t) ? t : [t])),
                          t
                        );
                      })
                      .filter(function (t) {
                        return 0 !== t.size;
                      });
                  if (0 === i.length) return t;
                  if (1 === i.length) {
                    var u = i[0];
                    if (u === t || (r && a(u)) || (f(t) && f(u))) return u;
                  }
                  var c = new tt(i);
                  return (
                    r ? (c = c.toKeyedSeq()) : f(t) || (c = c.toSetSeq()),
                    ((c = c.flatten(!0)).size = i.reduce(function (t, n) {
                      if (void 0 !== t) {
                        var r = n.size;
                        if (void 0 !== r) return t + r;
                      }
                    }, 0)),
                    c
                  );
                }
                function Jn(t, n, r) {
                  var e = nr(t);
                  return (
                    (e.__iterateUncached = function (e, i) {
                      var u = 0,
                        a = !1;
                      return (
                        (function t(f, c) {
                          var s = this;
                          f.__iterate(function (i, f) {
                            return (
                              (!n || c < n) && o(i)
                                ? t(i, c + 1)
                                : !1 === e(i, r ? f : u++, s) && (a = !0),
                              !a
                            );
                          }, i);
                        })(t, 0),
                        u
                      );
                    }),
                    (e.__iteratorUncached = function (e, i) {
                      var u = t.__iterator(e, i),
                        a = [],
                        f = 0;
                      return new C(function () {
                        for (; u; ) {
                          var t = u.next();
                          if (!1 === t.done) {
                            var c = t.value;
                            if (
                              (e === R && (c = c[1]),
                              (n && !(a.length < n)) || !o(c))
                            )
                              return r ? t : W(e, f++, c, t);
                            a.push(u), (u = c.__iterator(e, i));
                          } else u = a.pop();
                        }
                        return { value: void 0, done: !0 };
                      });
                    }),
                    e
                  );
                }
                function Hn(t, n, r) {
                  n || (n = er);
                  var e = a(t),
                    i = 0,
                    u = t
                      .toSeq()
                      .map(function (n, e) {
                        return [e, n, i++, r ? r(n, e, t) : n];
                      })
                      .toArray();
                  return (
                    u
                      .sort(function (t, r) {
                        return n(t[3], r[3]) || t[2] - r[2];
                      })
                      .forEach(
                        e
                          ? function (t, n) {
                              u[n].length = 2;
                            }
                          : function (t, n) {
                              u[n] = t[1];
                            }
                      ),
                    e ? H(u) : f(t) ? V(u) : Z(u)
                  );
                }
                function Vn(t, n, r) {
                  if ((n || (n = er), r)) {
                    var e = t
                      .toSeq()
                      .map(function (n, e) {
                        return [n, r(n, e, t)];
                      })
                      .reduce(function (t, r) {
                        return Zn(n, t[1], r[1]) ? r : t;
                      });
                    return e && e[0];
                  }
                  return t.reduce(function (t, r) {
                    return Zn(n, t, r) ? r : t;
                  });
                }
                function Zn(t, n, r) {
                  var e = t(r, n);
                  return (0 === e && r !== n && (null == r || r != r)) || e > 0;
                }
                function Gn(t, n, e) {
                  var i = nr(t);
                  return (
                    (i.size = new tt(e)
                      .map(function (t) {
                        return t.size;
                      })
                      .min()),
                    (i.__iterate = function (t, n) {
                      for (
                        var r, e = this.__iterator(q, n), i = 0;
                        !(r = e.next()).done && !1 !== t(r.value, i++, this);

                      );
                      return i;
                    }),
                    (i.__iteratorUncached = function (t, i) {
                      var u = e.map(function (t) {
                          return (t = r(t)), N(i ? t.reverse() : t);
                        }),
                        o = 0,
                        a = !1;
                      return new C(function () {
                        var r;
                        return (
                          a ||
                            ((r = u.map(function (t) {
                              return t.next();
                            })),
                            (a = r.some(function (t) {
                              return t.done;
                            }))),
                          a
                            ? { value: void 0, done: !0 }
                            : W(
                                t,
                                o++,
                                n.apply(
                                  null,
                                  r.map(function (t) {
                                    return t.value;
                                  })
                                )
                              )
                        );
                      });
                    }),
                    i
                  );
                }
                function Yn(t, n) {
                  return it(t) ? n : t.constructor(n);
                }
                function Xn(t) {
                  if (t !== Object(t))
                    throw new TypeError("Expected [K, V] tuple: " + t);
                }
                function Qn(t) {
                  return Ut(t.size), x(t);
                }
                function tr(t) {
                  return a(t) ? e : f(t) ? i : u;
                }
                function nr(t) {
                  return Object.create((a(t) ? H : f(t) ? V : Z).prototype);
                }
                function rr() {
                  return this._iter.cacheResult
                    ? (this._iter.cacheResult(),
                      (this.size = this._iter.size),
                      this)
                    : J.prototype.cacheResult.call(this);
                }
                function er(t, n) {
                  return t > n ? 1 : t < n ? -1 : 0;
                }
                function ir(t) {
                  var n = N(t);
                  if (!n) {
                    if (!F(t))
                      throw new TypeError(
                        "Expected iterable or array-like: " + t
                      );
                    n = N(r(t));
                  }
                  return n;
                }
                function ur(t, n) {
                  var r,
                    e = function (u) {
                      if (u instanceof e) return u;
                      if (!(this instanceof e)) return new e(u);
                      if (!r) {
                        r = !0;
                        var o = Object.keys(t);
                        !(function (t, n) {
                          try {
                            n.forEach(cr.bind(void 0, t));
                          } catch (t) {}
                        })(i, o),
                          (i.size = o.length),
                          (i._name = n),
                          (i._keys = o),
                          (i._defaultValues = t);
                      }
                      this._map = Ct(u);
                    },
                    i = (e.prototype = Object.create(or));
                  return (i.constructor = e), e;
                }
                n(kn, Ct),
                  (kn.of = function () {
                    return this(arguments);
                  }),
                  (kn.prototype.toString = function () {
                    return this.__toString("OrderedMap {", "}");
                  }),
                  (kn.prototype.get = function (t, n) {
                    var r = this._map.get(t);
                    return void 0 !== r ? this._list.get(r)[1] : n;
                  }),
                  (kn.prototype.clear = function () {
                    return 0 === this.size
                      ? this
                      : this.__ownerID
                      ? ((this.size = 0),
                        this._map.clear(),
                        this._list.clear(),
                        this)
                      : qn();
                  }),
                  (kn.prototype.set = function (t, n) {
                    return Rn(this, t, n);
                  }),
                  (kn.prototype.remove = function (t) {
                    return Rn(this, t, g);
                  }),
                  (kn.prototype.wasAltered = function () {
                    return this._map.wasAltered() || this._list.wasAltered();
                  }),
                  (kn.prototype.__iterate = function (t, n) {
                    var r = this;
                    return this._list.__iterate(function (n) {
                      return n && t(n[1], n[0], r);
                    }, n);
                  }),
                  (kn.prototype.__iterator = function (t, n) {
                    return this._list.fromEntrySeq().__iterator(t, n);
                  }),
                  (kn.prototype.__ensureOwner = function (t) {
                    if (t === this.__ownerID) return this;
                    var n = this._map.__ensureOwner(t),
                      r = this._list.__ensureOwner(t);
                    return t
                      ? Dn(n, r, t, this.__hash)
                      : ((this.__ownerID = t),
                        (this._map = n),
                        (this._list = r),
                        this);
                  }),
                  (kn.isOrderedMap = Mn),
                  (kn.prototype[_] = !0),
                  (kn.prototype.delete = kn.prototype.remove),
                  n(Ln, H),
                  (Ln.prototype.get = function (t, n) {
                    return this._iter.get(t, n);
                  }),
                  (Ln.prototype.has = function (t) {
                    return this._iter.has(t);
                  }),
                  (Ln.prototype.valueSeq = function () {
                    return this._iter.valueSeq();
                  }),
                  (Ln.prototype.reverse = function () {
                    var t = this,
                      n = Kn(this, !0);
                    return (
                      this._useKeys ||
                        (n.valueSeq = function () {
                          return t._iter.toSeq().reverse();
                        }),
                      n
                    );
                  }),
                  (Ln.prototype.map = function (t, n) {
                    var r = this,
                      e = Bn(this, t, n);
                    return (
                      this._useKeys ||
                        (e.valueSeq = function () {
                          return r._iter.toSeq().map(t, n);
                        }),
                      e
                    );
                  }),
                  (Ln.prototype.__iterate = function (t, n) {
                    var r,
                      e = this;
                    return this._iter.__iterate(
                      this._useKeys
                        ? function (n, r) {
                            return t(n, r, e);
                          }
                        : ((r = n ? Qn(this) : 0),
                          function (i) {
                            return t(i, n ? --r : r++, e);
                          }),
                      n
                    );
                  }),
                  (Ln.prototype.__iterator = function (t, n) {
                    if (this._useKeys) return this._iter.__iterator(t, n);
                    var r = this._iter.__iterator(q, n),
                      e = n ? Qn(this) : 0;
                    return new C(function () {
                      var i = r.next();
                      return i.done ? i : W(t, n ? --e : e++, i.value, i);
                    });
                  }),
                  (Ln.prototype[_] = !0),
                  n(Tn, V),
                  (Tn.prototype.includes = function (t) {
                    return this._iter.includes(t);
                  }),
                  (Tn.prototype.__iterate = function (t, n) {
                    var r = this,
                      e = 0;
                    return this._iter.__iterate(function (n) {
                      return t(n, e++, r);
                    }, n);
                  }),
                  (Tn.prototype.__iterator = function (t, n) {
                    var r = this._iter.__iterator(q, n),
                      e = 0;
                    return new C(function () {
                      var n = r.next();
                      return n.done ? n : W(t, e++, n.value, n);
                    });
                  }),
                  n(Un, Z),
                  (Un.prototype.has = function (t) {
                    return this._iter.includes(t);
                  }),
                  (Un.prototype.__iterate = function (t, n) {
                    var r = this;
                    return this._iter.__iterate(function (n) {
                      return t(n, n, r);
                    }, n);
                  }),
                  (Un.prototype.__iterator = function (t, n) {
                    var r = this._iter.__iterator(q, n);
                    return new C(function () {
                      var n = r.next();
                      return n.done ? n : W(t, n.value, n.value, n);
                    });
                  }),
                  n(Cn, H),
                  (Cn.prototype.entrySeq = function () {
                    return this._iter.toSeq();
                  }),
                  (Cn.prototype.__iterate = function (t, n) {
                    var r = this;
                    return this._iter.__iterate(function (n) {
                      if (n) {
                        Xn(n);
                        var e = o(n);
                        return t(e ? n.get(1) : n[1], e ? n.get(0) : n[0], r);
                      }
                    }, n);
                  }),
                  (Cn.prototype.__iterator = function (t, n) {
                    var r = this._iter.__iterator(q, n);
                    return new C(function () {
                      for (;;) {
                        var n = r.next();
                        if (n.done) return n;
                        var e = n.value;
                        if (e) {
                          Xn(e);
                          var i = o(e);
                          return W(
                            t,
                            i ? e.get(0) : e[0],
                            i ? e.get(1) : e[1],
                            n
                          );
                        }
                      }
                    });
                  }),
                  (Tn.prototype.cacheResult = Ln.prototype.cacheResult = Un.prototype.cacheResult = Cn.prototype.cacheResult = rr),
                  n(ur, mt),
                  (ur.prototype.toString = function () {
                    return this.__toString(fr(this) + " {", "}");
                  }),
                  (ur.prototype.has = function (t) {
                    return this._defaultValues.hasOwnProperty(t);
                  }),
                  (ur.prototype.get = function (t, n) {
                    if (!this.has(t)) return n;
                    var r = this._defaultValues[t];
                    return this._map ? this._map.get(t, r) : r;
                  }),
                  (ur.prototype.clear = function () {
                    if (this.__ownerID)
                      return this._map && this._map.clear(), this;
                    var t = this.constructor;
                    return t._empty || (t._empty = ar(this, Xt()));
                  }),
                  (ur.prototype.set = function (t, n) {
                    if (!this.has(t))
                      throw new Error(
                        'Cannot set unknown key "' + t + '" on ' + fr(this)
                      );
                    if (
                      this._map &&
                      !this._map.has(t) &&
                      n === this._defaultValues[t]
                    )
                      return this;
                    var r = this._map && this._map.set(t, n);
                    return this.__ownerID || r === this._map
                      ? this
                      : ar(this, r);
                  }),
                  (ur.prototype.remove = function (t) {
                    if (!this.has(t)) return this;
                    var n = this._map && this._map.remove(t);
                    return this.__ownerID || n === this._map
                      ? this
                      : ar(this, n);
                  }),
                  (ur.prototype.wasAltered = function () {
                    return this._map.wasAltered();
                  }),
                  (ur.prototype.__iterator = function (t, n) {
                    var r = this;
                    return e(this._defaultValues)
                      .map(function (t, n) {
                        return r.get(n);
                      })
                      .__iterator(t, n);
                  }),
                  (ur.prototype.__iterate = function (t, n) {
                    var r = this;
                    return e(this._defaultValues)
                      .map(function (t, n) {
                        return r.get(n);
                      })
                      .__iterate(t, n);
                  }),
                  (ur.prototype.__ensureOwner = function (t) {
                    if (t === this.__ownerID) return this;
                    var n = this._map && this._map.__ensureOwner(t);
                    return t
                      ? ar(this, n, t)
                      : ((this.__ownerID = t), (this._map = n), this);
                  });
                var or = ur.prototype;
                function ar(t, n, r) {
                  var e = Object.create(Object.getPrototypeOf(t));
                  return (e._map = n), (e.__ownerID = r), e;
                }
                function fr(t) {
                  return t._name || t.constructor.name || "Record";
                }
                function cr(t, n) {
                  Object.defineProperty(t, n, {
                    get: function () {
                      return this.get(n);
                    },
                    set: function (t) {
                      dt(this.__ownerID, "Cannot set on an immutable record."),
                        this.set(n, t);
                    },
                  });
                }
                function sr(t) {
                  return null == t
                    ? dr()
                    : hr(t) && !s(t)
                    ? t
                    : dr().withMutations(function (n) {
                        var r = u(t);
                        Ut(r.size),
                          r.forEach(function (t) {
                            return n.add(t);
                          });
                      });
                }
                function hr(t) {
                  return !(!t || !t[pr]);
                }
                (or.delete = or.remove),
                  (or.deleteIn = or.removeIn = Pt.removeIn),
                  (or.merge = Pt.merge),
                  (or.mergeWith = Pt.mergeWith),
                  (or.mergeIn = Pt.mergeIn),
                  (or.mergeDeep = Pt.mergeDeep),
                  (or.mergeDeepWith = Pt.mergeDeepWith),
                  (or.mergeDeepIn = Pt.mergeDeepIn),
                  (or.setIn = Pt.setIn),
                  (or.update = Pt.update),
                  (or.updateIn = Pt.updateIn),
                  (or.withMutations = Pt.withMutations),
                  (or.asMutable = Pt.asMutable),
                  (or.asImmutable = Pt.asImmutable),
                  n(sr, St),
                  (sr.of = function () {
                    return this(arguments);
                  }),
                  (sr.fromKeys = function (t) {
                    return this(e(t).keySeq());
                  }),
                  (sr.prototype.toString = function () {
                    return this.__toString("Set {", "}");
                  }),
                  (sr.prototype.has = function (t) {
                    return this._map.has(t);
                  }),
                  (sr.prototype.add = function (t) {
                    return vr(this, this._map.set(t, !0));
                  }),
                  (sr.prototype.remove = function (t) {
                    return vr(this, this._map.remove(t));
                  }),
                  (sr.prototype.clear = function () {
                    return vr(this, this._map.clear());
                  }),
                  (sr.prototype.union = function () {
                    var n = t.call(arguments, 0);
                    return 0 ===
                      (n = n.filter(function (t) {
                        return 0 !== t.size;
                      })).length
                      ? this
                      : 0 !== this.size || this.__ownerID || 1 !== n.length
                      ? this.withMutations(function (t) {
                          for (var r = 0; r < n.length; r++)
                            u(n[r]).forEach(function (n) {
                              return t.add(n);
                            });
                        })
                      : this.constructor(n[0]);
                  }),
                  (sr.prototype.intersect = function () {
                    var n = t.call(arguments, 0);
                    if (0 === n.length) return this;
                    n = n.map(function (t) {
                      return u(t);
                    });
                    var r = this;
                    return this.withMutations(function (t) {
                      r.forEach(function (r) {
                        n.every(function (t) {
                          return t.includes(r);
                        }) || t.remove(r);
                      });
                    });
                  }),
                  (sr.prototype.subtract = function () {
                    var n = t.call(arguments, 0);
                    if (0 === n.length) return this;
                    n = n.map(function (t) {
                      return u(t);
                    });
                    var r = this;
                    return this.withMutations(function (t) {
                      r.forEach(function (r) {
                        n.some(function (t) {
                          return t.includes(r);
                        }) && t.remove(r);
                      });
                    });
                  }),
                  (sr.prototype.merge = function () {
                    return this.union.apply(this, arguments);
                  }),
                  (sr.prototype.mergeWith = function (n) {
                    var r = t.call(arguments, 1);
                    return this.union.apply(this, r);
                  }),
                  (sr.prototype.sort = function (t) {
                    return gr(Hn(this, t));
                  }),
                  (sr.prototype.sortBy = function (t, n) {
                    return gr(Hn(this, n, t));
                  }),
                  (sr.prototype.wasAltered = function () {
                    return this._map.wasAltered();
                  }),
                  (sr.prototype.__iterate = function (t, n) {
                    var r = this;
                    return this._map.__iterate(function (n, e) {
                      return t(e, e, r);
                    }, n);
                  }),
                  (sr.prototype.__iterator = function (t, n) {
                    return this._map
                      .map(function (t, n) {
                        return n;
                      })
                      .__iterator(t, n);
                  }),
                  (sr.prototype.__ensureOwner = function (t) {
                    if (t === this.__ownerID) return this;
                    var n = this._map.__ensureOwner(t);
                    return t
                      ? this.__make(n, t)
                      : ((this.__ownerID = t), (this._map = n), this);
                  }),
                  (sr.isSet = hr);
                var lr,
                  pr = "@@__IMMUTABLE_SET__@@",
                  _r = sr.prototype;
                function vr(t, n) {
                  return t.__ownerID
                    ? ((t.size = n.size), (t._map = n), t)
                    : n === t._map
                    ? t
                    : 0 === n.size
                    ? t.__empty()
                    : t.__make(n);
                }
                function yr(t, n) {
                  var r = Object.create(_r);
                  return (
                    (r.size = t ? t.size : 0),
                    (r._map = t),
                    (r.__ownerID = n),
                    r
                  );
                }
                function dr() {
                  return lr || (lr = yr(Xt()));
                }
                function gr(t) {
                  return null == t
                    ? Ir()
                    : wr(t)
                    ? t
                    : Ir().withMutations(function (n) {
                        var r = u(t);
                        Ut(r.size),
                          r.forEach(function (t) {
                            return n.add(t);
                          });
                      });
                }
                function wr(t) {
                  return hr(t) && s(t);
                }
                (_r[pr] = !0),
                  (_r.delete = _r.remove),
                  (_r.mergeDeep = _r.merge),
                  (_r.mergeDeepWith = _r.mergeWith),
                  (_r.withMutations = Pt.withMutations),
                  (_r.asMutable = Pt.asMutable),
                  (_r.asImmutable = Pt.asImmutable),
                  (_r.__empty = dr),
                  (_r.__make = yr),
                  n(gr, sr),
                  (gr.of = function () {
                    return this(arguments);
                  }),
                  (gr.fromKeys = function (t) {
                    return this(e(t).keySeq());
                  }),
                  (gr.prototype.toString = function () {
                    return this.__toString("OrderedSet {", "}");
                  }),
                  (gr.isOrderedSet = wr);
                var mr,
                  br = gr.prototype;
                function Sr(t, n) {
                  var r = Object.create(br);
                  return (
                    (r.size = t ? t.size : 0),
                    (r._map = t),
                    (r.__ownerID = n),
                    r
                  );
                }
                function Ir() {
                  return mr || (mr = Sr(qn()));
                }
                function zr(t) {
                  return null == t ? kr() : xr(t) ? t : kr().unshiftAll(t);
                }
                function xr(t) {
                  return !(!t || !t[jr]);
                }
                (br[_] = !0),
                  (br.__empty = Ir),
                  (br.__make = Sr),
                  n(zr, bt),
                  (zr.of = function () {
                    return this(arguments);
                  }),
                  (zr.prototype.toString = function () {
                    return this.__toString("Stack [", "]");
                  }),
                  (zr.prototype.get = function (t, n) {
                    var r = this._head;
                    for (t = O(this, t); r && t--; ) r = r.next;
                    return r ? r.value : n;
                  }),
                  (zr.prototype.peek = function () {
                    return this._head && this._head.value;
                  }),
                  (zr.prototype.push = function () {
                    if (0 === arguments.length) return this;
                    for (
                      var t = this.size + arguments.length,
                        n = this._head,
                        r = arguments.length - 1;
                      r >= 0;
                      r--
                    )
                      n = { value: arguments[r], next: n };
                    return this.__ownerID
                      ? ((this.size = t),
                        (this._head = n),
                        (this.__hash = void 0),
                        (this.__altered = !0),
                        this)
                      : Er(t, n);
                  }),
                  (zr.prototype.pushAll = function (t) {
                    if (0 === (t = i(t)).size) return this;
                    Ut(t.size);
                    var n = this.size,
                      r = this._head;
                    return (
                      t.reverse().forEach(function (t) {
                        n++, (r = { value: t, next: r });
                      }),
                      this.__ownerID
                        ? ((this.size = n),
                          (this._head = r),
                          (this.__hash = void 0),
                          (this.__altered = !0),
                          this)
                        : Er(n, r)
                    );
                  }),
                  (zr.prototype.pop = function () {
                    return this.slice(1);
                  }),
                  (zr.prototype.unshift = function () {
                    return this.push.apply(this, arguments);
                  }),
                  (zr.prototype.unshiftAll = function (t) {
                    return this.pushAll(t);
                  }),
                  (zr.prototype.shift = function () {
                    return this.pop.apply(this, arguments);
                  }),
                  (zr.prototype.clear = function () {
                    return 0 === this.size
                      ? this
                      : this.__ownerID
                      ? ((this.size = 0),
                        (this._head = void 0),
                        (this.__hash = void 0),
                        (this.__altered = !0),
                        this)
                      : kr();
                  }),
                  (zr.prototype.slice = function (t, n) {
                    if (A(t, n, this.size)) return this;
                    var r = E(t, this.size);
                    if (k(n, this.size) !== this.size)
                      return bt.prototype.slice.call(this, t, n);
                    for (var e = this.size - r, i = this._head; r--; )
                      i = i.next;
                    return this.__ownerID
                      ? ((this.size = e),
                        (this._head = i),
                        (this.__hash = void 0),
                        (this.__altered = !0),
                        this)
                      : Er(e, i);
                  }),
                  (zr.prototype.__ensureOwner = function (t) {
                    return t === this.__ownerID
                      ? this
                      : t
                      ? Er(this.size, this._head, t, this.__hash)
                      : ((this.__ownerID = t), (this.__altered = !1), this);
                  }),
                  (zr.prototype.__iterate = function (t, n) {
                    if (n) return this.reverse().__iterate(t);
                    for (
                      var r = 0, e = this._head;
                      e && !1 !== t(e.value, r++, this);

                    )
                      e = e.next;
                    return r;
                  }),
                  (zr.prototype.__iterator = function (t, n) {
                    if (n) return this.reverse().__iterator(t);
                    var r = 0,
                      e = this._head;
                    return new C(function () {
                      if (e) {
                        var n = e.value;
                        return (e = e.next), W(t, r++, n);
                      }
                      return { value: void 0, done: !0 };
                    });
                  }),
                  (zr.isStack = xr);
                var Or,
                  jr = "@@__IMMUTABLE_STACK__@@",
                  Ar = zr.prototype;
                function Er(t, n, r, e) {
                  var i = Object.create(Ar);
                  return (
                    (i.size = t),
                    (i._head = n),
                    (i.__ownerID = r),
                    (i.__hash = e),
                    (i.__altered = !1),
                    i
                  );
                }
                function kr() {
                  return Or || (Or = Er(0));
                }
                function Mr(t, n) {
                  var r = function (r) {
                    t.prototype[r] = n[r];
                  };
                  return (
                    Object.keys(n).forEach(r),
                    Object.getOwnPropertySymbols &&
                      Object.getOwnPropertySymbols(n).forEach(r),
                    t
                  );
                }
                (Ar[jr] = !0),
                  (Ar.withMutations = Pt.withMutations),
                  (Ar.asMutable = Pt.asMutable),
                  (Ar.asImmutable = Pt.asImmutable),
                  (Ar.wasAltered = Pt.wasAltered),
                  (r.Iterator = C),
                  Mr(r, {
                    toArray: function () {
                      Ut(this.size);
                      var t = new Array(this.size || 0);
                      return (
                        this.valueSeq().__iterate(function (n, r) {
                          t[r] = n;
                        }),
                        t
                      );
                    },
                    toIndexedSeq: function () {
                      return new Tn(this);
                    },
                    toJS: function () {
                      return this.toSeq()
                        .map(function (t) {
                          return t && "function" == typeof t.toJS
                            ? t.toJS()
                            : t;
                        })
                        .__toJS();
                    },
                    toJSON: function () {
                      return this.toSeq()
                        .map(function (t) {
                          return t && "function" == typeof t.toJSON
                            ? t.toJSON()
                            : t;
                        })
                        .__toJS();
                    },
                    toKeyedSeq: function () {
                      return new Ln(this, !0);
                    },
                    toMap: function () {
                      return Ct(this.toKeyedSeq());
                    },
                    toObject: function () {
                      Ut(this.size);
                      var t = {};
                      return (
                        this.__iterate(function (n, r) {
                          t[r] = n;
                        }),
                        t
                      );
                    },
                    toOrderedMap: function () {
                      return kn(this.toKeyedSeq());
                    },
                    toOrderedSet: function () {
                      return gr(a(this) ? this.valueSeq() : this);
                    },
                    toSet: function () {
                      return sr(a(this) ? this.valueSeq() : this);
                    },
                    toSetSeq: function () {
                      return new Un(this);
                    },
                    toSeq: function () {
                      return f(this)
                        ? this.toIndexedSeq()
                        : a(this)
                        ? this.toKeyedSeq()
                        : this.toSetSeq();
                    },
                    toStack: function () {
                      return zr(a(this) ? this.valueSeq() : this);
                    },
                    toList: function () {
                      return pn(a(this) ? this.valueSeq() : this);
                    },
                    toString: function () {
                      return "[Iterable]";
                    },
                    __toString: function (t, n) {
                      return 0 === this.size
                        ? t + n
                        : t +
                            " " +
                            this.toSeq().map(this.__toStringMapper).join(", ") +
                            " " +
                            n;
                    },
                    concat: function () {
                      var n = t.call(arguments, 0);
                      return Yn(this, Fn(this, n));
                    },
                    includes: function (t) {
                      return this.some(function (n) {
                        return _t(n, t);
                      });
                    },
                    entries: function () {
                      return this.__iterator(R);
                    },
                    every: function (t, n) {
                      Ut(this.size);
                      var r = !0;
                      return (
                        this.__iterate(function (e, i, u) {
                          if (!t.call(n, e, i, u)) return (r = !1), !1;
                        }),
                        r
                      );
                    },
                    filter: function (t, n) {
                      return Yn(this, Pn(this, t, n, !0));
                    },
                    find: function (t, n, r) {
                      var e = this.findEntry(t, n);
                      return e ? e[1] : r;
                    },
                    forEach: function (t, n) {
                      return Ut(this.size), this.__iterate(n ? t.bind(n) : t);
                    },
                    join: function (t) {
                      Ut(this.size), (t = void 0 !== t ? "" + t : ",");
                      var n = "",
                        r = !0;
                      return (
                        this.__iterate(function (e) {
                          r ? (r = !1) : (n += t),
                            (n += null != e ? e.toString() : "");
                        }),
                        n
                      );
                    },
                    keys: function () {
                      return this.__iterator(D);
                    },
                    map: function (t, n) {
                      return Yn(this, Bn(this, t, n));
                    },
                    reduce: function (t, n, r) {
                      var e, i;
                      return (
                        Ut(this.size),
                        arguments.length < 2 ? (i = !0) : (e = n),
                        this.__iterate(function (n, u, o) {
                          i ? ((i = !1), (e = n)) : (e = t.call(r, e, n, u, o));
                        }),
                        e
                      );
                    },
                    reduceRight: function (t, n, r) {
                      var e = this.toKeyedSeq().reverse();
                      return e.reduce.apply(e, arguments);
                    },
                    reverse: function () {
                      return Yn(this, Kn(this, !0));
                    },
                    slice: function (t, n) {
                      return Yn(this, Nn(this, t, n, !0));
                    },
                    some: function (t, n) {
                      return !this.every(Tr(t), n);
                    },
                    sort: function (t) {
                      return Yn(this, Hn(this, t));
                    },
                    values: function () {
                      return this.__iterator(q);
                    },
                    butLast: function () {
                      return this.slice(0, -1);
                    },
                    isEmpty: function () {
                      return void 0 !== this.size
                        ? 0 === this.size
                        : !this.some(function () {
                            return !0;
                          });
                    },
                    count: function (t, n) {
                      return x(t ? this.toSeq().filter(t, n) : this);
                    },
                    countBy: function (t, n) {
                      return (function (t, n, r) {
                        var e = Ct().asMutable();
                        return (
                          t.__iterate(function (i, u) {
                            e.update(n.call(r, i, u, t), 0, function (t) {
                              return t + 1;
                            });
                          }),
                          e.asImmutable()
                        );
                      })(this, t, n);
                    },
                    equals: function (t) {
                      return vt(this, t);
                    },
                    entrySeq: function () {
                      var t = this;
                      if (t._cache) return new tt(t._cache);
                      var n = t.toSeq().map(Lr).toIndexedSeq();
                      return (
                        (n.fromEntrySeq = function () {
                          return t.toSeq();
                        }),
                        n
                      );
                    },
                    filterNot: function (t, n) {
                      return this.filter(Tr(t), n);
                    },
                    findEntry: function (t, n, r) {
                      var e = r;
                      return (
                        this.__iterate(function (r, i, u) {
                          if (t.call(n, r, i, u)) return (e = [i, r]), !1;
                        }),
                        e
                      );
                    },
                    findKey: function (t, n) {
                      var r = this.findEntry(t, n);
                      return r && r[0];
                    },
                    findLast: function (t, n, r) {
                      return this.toKeyedSeq().reverse().find(t, n, r);
                    },
                    findLastEntry: function (t, n, r) {
                      return this.toKeyedSeq().reverse().findEntry(t, n, r);
                    },
                    findLastKey: function (t, n) {
                      return this.toKeyedSeq().reverse().findKey(t, n);
                    },
                    first: function () {
                      return this.find(j);
                    },
                    flatMap: function (t, n) {
                      return Yn(
                        this,
                        (function (t, n, r) {
                          var e = tr(t);
                          return t
                            .toSeq()
                            .map(function (i, u) {
                              return e(n.call(r, i, u, t));
                            })
                            .flatten(!0);
                        })(this, t, n)
                      );
                    },
                    flatten: function (t) {
                      return Yn(this, Jn(this, t, !0));
                    },
                    fromEntrySeq: function () {
                      return new Cn(this);
                    },
                    get: function (t, n) {
                      return this.find(
                        function (n, r) {
                          return _t(r, t);
                        },
                        void 0,
                        n
                      );
                    },
                    getIn: function (t, n) {
                      for (var r, e = this, i = ir(t); !(r = i.next()).done; ) {
                        var u = r.value;
                        if ((e = e && e.get ? e.get(u, g) : g) === g) return n;
                      }
                      return e;
                    },
                    groupBy: function (t, n) {
                      return (function (t, n, r) {
                        var e = a(t),
                          i = (s(t) ? kn() : Ct()).asMutable();
                        t.__iterate(function (u, o) {
                          i.update(n.call(r, u, o, t), function (t) {
                            return (t = t || []).push(e ? [o, u] : u), t;
                          });
                        });
                        var u = tr(t);
                        return i.map(function (n) {
                          return Yn(t, u(n));
                        });
                      })(this, t, n);
                    },
                    has: function (t) {
                      return this.get(t, g) !== g;
                    },
                    hasIn: function (t) {
                      return this.getIn(t, g) !== g;
                    },
                    isSubset: function (t) {
                      return (
                        (t = "function" == typeof t.includes ? t : r(t)),
                        this.every(function (n) {
                          return t.includes(n);
                        })
                      );
                    },
                    isSuperset: function (t) {
                      return (t =
                        "function" == typeof t.isSubset ? t : r(t)).isSubset(
                        this
                      );
                    },
                    keyOf: function (t) {
                      return this.findKey(function (n) {
                        return _t(n, t);
                      });
                    },
                    keySeq: function () {
                      return this.toSeq().map(Rr).toIndexedSeq();
                    },
                    last: function () {
                      return this.toSeq().reverse().first();
                    },
                    lastKeyOf: function (t) {
                      return this.toKeyedSeq().reverse().keyOf(t);
                    },
                    max: function (t) {
                      return Vn(this, t);
                    },
                    maxBy: function (t, n) {
                      return Vn(this, n, t);
                    },
                    min: function (t) {
                      return Vn(this, t ? Ur(t) : Br);
                    },
                    minBy: function (t, n) {
                      return Vn(this, n ? Ur(n) : Br, t);
                    },
                    rest: function () {
                      return this.slice(1);
                    },
                    skip: function (t) {
                      return this.slice(Math.max(0, t));
                    },
                    skipLast: function (t) {
                      return Yn(this, this.toSeq().reverse().skip(t).reverse());
                    },
                    skipWhile: function (t, n) {
                      return Yn(this, $n(this, t, n, !0));
                    },
                    skipUntil: function (t, n) {
                      return this.skipWhile(Tr(t), n);
                    },
                    sortBy: function (t, n) {
                      return Yn(this, Hn(this, n, t));
                    },
                    take: function (t) {
                      return this.slice(0, Math.max(0, t));
                    },
                    takeLast: function (t) {
                      return Yn(this, this.toSeq().reverse().take(t).reverse());
                    },
                    takeWhile: function (t, n) {
                      return Yn(
                        this,
                        (function (t, n, r) {
                          var e = nr(t);
                          return (
                            (e.__iterateUncached = function (e, i) {
                              var u = this;
                              if (i) return this.cacheResult().__iterate(e, i);
                              var o = 0;
                              return (
                                t.__iterate(function (t, i, a) {
                                  return (
                                    n.call(r, t, i, a) && ++o && e(t, i, u)
                                  );
                                }),
                                o
                              );
                            }),
                            (e.__iteratorUncached = function (e, i) {
                              var u = this;
                              if (i) return this.cacheResult().__iterator(e, i);
                              var o = t.__iterator(R, i),
                                a = !0;
                              return new C(function () {
                                if (!a) return { value: void 0, done: !0 };
                                var t = o.next();
                                if (t.done) return t;
                                var i = t.value,
                                  f = i[0],
                                  c = i[1];
                                return n.call(r, c, f, u)
                                  ? e === R
                                    ? t
                                    : W(e, f, c, t)
                                  : ((a = !1), { value: void 0, done: !0 });
                              });
                            }),
                            e
                          );
                        })(this, t, n)
                      );
                    },
                    takeUntil: function (t, n) {
                      return this.takeWhile(Tr(t), n);
                    },
                    valueSeq: function () {
                      return this.toIndexedSeq();
                    },
                    hashCode: function () {
                      return (
                        this.__hash ||
                        (this.__hash = (function (t) {
                          if (t.size === 1 / 0) return 0;
                          var n = s(t),
                            r = a(t),
                            e = n ? 1 : 0;
                          return (function (t, n) {
                            return (
                              (n = It(n, 3432918353)),
                              (n = It((n << 15) | (n >>> -15), 461845907)),
                              (n = It((n << 13) | (n >>> -13), 5)),
                              (n = It(
                                (n = ((n + 3864292196) | 0) ^ t) ^ (n >>> 16),
                                2246822507
                              )),
                              (n = zt(
                                (n = It(n ^ (n >>> 13), 3266489909)) ^
                                  (n >>> 16)
                              ))
                            );
                          })(
                            t.__iterate(
                              r
                                ? n
                                  ? function (t, n) {
                                      e = (31 * e + Kr(xt(t), xt(n))) | 0;
                                    }
                                  : function (t, n) {
                                      e = (e + Kr(xt(t), xt(n))) | 0;
                                    }
                                : n
                                ? function (t) {
                                    e = (31 * e + xt(t)) | 0;
                                  }
                                : function (t) {
                                    e = (e + xt(t)) | 0;
                                  }
                            ),
                            e
                          );
                        })(this))
                      );
                    },
                  });
                var Dr = r.prototype;
                (Dr[h] = !0),
                  (Dr[U] = Dr.values),
                  (Dr.__toJS = Dr.toArray),
                  (Dr.__toStringMapper = Cr),
                  (Dr.inspect = Dr.toSource = function () {
                    return this.toString();
                  }),
                  (Dr.chain = Dr.flatMap),
                  (Dr.contains = Dr.includes),
                  Mr(e, {
                    flip: function () {
                      return Yn(this, Wn(this));
                    },
                    mapEntries: function (t, n) {
                      var r = this,
                        e = 0;
                      return Yn(
                        this,
                        this.toSeq()
                          .map(function (i, u) {
                            return t.call(n, [u, i], e++, r);
                          })
                          .fromEntrySeq()
                      );
                    },
                    mapKeys: function (t, n) {
                      var r = this;
                      return Yn(
                        this,
                        this.toSeq()
                          .flip()
                          .map(function (e, i) {
                            return t.call(n, e, i, r);
                          })
                          .flip()
                      );
                    },
                  });
                var qr = e.prototype;
                function Rr(t, n) {
                  return n;
                }
                function Lr(t, n) {
                  return [n, t];
                }
                function Tr(t) {
                  return function () {
                    return !t.apply(this, arguments);
                  };
                }
                function Ur(t) {
                  return function () {
                    return -t.apply(this, arguments);
                  };
                }
                function Cr(t) {
                  return "string" == typeof t ? JSON.stringify(t) : String(t);
                }
                function Wr() {
                  return z(arguments);
                }
                function Br(t, n) {
                  return t < n ? 1 : t > n ? -1 : 0;
                }
                function Kr(t, n) {
                  return (t ^ (n + 2654435769 + (t << 6) + (t >> 2))) | 0;
                }
                return (
                  (qr[l] = !0),
                  (qr[U] = Dr.entries),
                  (qr.__toJS = Dr.toObject),
                  (qr.__toStringMapper = function (t, n) {
                    return JSON.stringify(n) + ": " + Cr(t);
                  }),
                  Mr(i, {
                    toKeyedSeq: function () {
                      return new Ln(this, !1);
                    },
                    filter: function (t, n) {
                      return Yn(this, Pn(this, t, n, !1));
                    },
                    findIndex: function (t, n) {
                      var r = this.findEntry(t, n);
                      return r ? r[0] : -1;
                    },
                    indexOf: function (t) {
                      var n = this.keyOf(t);
                      return void 0 === n ? -1 : n;
                    },
                    lastIndexOf: function (t) {
                      var n = this.lastKeyOf(t);
                      return void 0 === n ? -1 : n;
                    },
                    reverse: function () {
                      return Yn(this, Kn(this, !1));
                    },
                    slice: function (t, n) {
                      return Yn(this, Nn(this, t, n, !1));
                    },
                    splice: function (t, n) {
                      var r = arguments.length;
                      if (
                        ((n = Math.max(0 | n, 0)), 0 === r || (2 === r && !n))
                      )
                        return this;
                      t = E(t, t < 0 ? this.count() : this.size);
                      var e = this.slice(0, t);
                      return Yn(
                        this,
                        1 === r
                          ? e
                          : e.concat(z(arguments, 2), this.slice(t + n))
                      );
                    },
                    findLastIndex: function (t, n) {
                      var r = this.findLastEntry(t, n);
                      return r ? r[0] : -1;
                    },
                    first: function () {
                      return this.get(0);
                    },
                    flatten: function (t) {
                      return Yn(this, Jn(this, t, !1));
                    },
                    get: function (t, n) {
                      return (t = O(this, t)) < 0 ||
                        this.size === 1 / 0 ||
                        (void 0 !== this.size && t > this.size)
                        ? n
                        : this.find(
                            function (n, r) {
                              return r === t;
                            },
                            void 0,
                            n
                          );
                    },
                    has: function (t) {
                      return (
                        (t = O(this, t)) >= 0 &&
                        (void 0 !== this.size
                          ? this.size === 1 / 0 || t < this.size
                          : -1 !== this.indexOf(t))
                      );
                    },
                    interpose: function (t) {
                      return Yn(
                        this,
                        (function (t, n) {
                          var r = nr(t);
                          return (
                            (r.size = t.size && 2 * t.size - 1),
                            (r.__iterateUncached = function (r, e) {
                              var i = this,
                                u = 0;
                              return (
                                t.__iterate(function (t, e) {
                                  return (
                                    (!u || !1 !== r(n, u++, i)) &&
                                    !1 !== r(t, u++, i)
                                  );
                                }, e),
                                u
                              );
                            }),
                            (r.__iteratorUncached = function (r, e) {
                              var i,
                                u = t.__iterator(q, e),
                                o = 0;
                              return new C(function () {
                                return (!i || o % 2) && (i = u.next()).done
                                  ? i
                                  : o % 2
                                  ? W(r, o++, n)
                                  : W(r, o++, i.value, i);
                              });
                            }),
                            r
                          );
                        })(this, t)
                      );
                    },
                    interleave: function () {
                      var t = [this].concat(z(arguments)),
                        n = Gn(this.toSeq(), V.of, t),
                        r = n.flatten(!0);
                      return (
                        n.size && (r.size = n.size * t.length), Yn(this, r)
                      );
                    },
                    keySeq: function () {
                      return gt(0, this.size);
                    },
                    last: function () {
                      return this.get(-1);
                    },
                    skipWhile: function (t, n) {
                      return Yn(this, $n(this, t, n, !1));
                    },
                    zip: function () {
                      var t = [this].concat(z(arguments));
                      return Yn(this, Gn(this, Wr, t));
                    },
                    zipWith: function (t) {
                      var n = z(arguments);
                      return (n[0] = this), Yn(this, Gn(this, t, n));
                    },
                  }),
                  (i.prototype[p] = !0),
                  (i.prototype[_] = !0),
                  Mr(u, {
                    get: function (t, n) {
                      return this.has(t) ? t : n;
                    },
                    includes: function (t) {
                      return this.has(t);
                    },
                    keySeq: function () {
                      return this.valueSeq();
                    },
                  }),
                  (u.prototype.has = Dr.includes),
                  (u.prototype.contains = u.prototype.includes),
                  Mr(H, e.prototype),
                  Mr(V, i.prototype),
                  Mr(Z, u.prototype),
                  Mr(mt, e.prototype),
                  Mr(bt, i.prototype),
                  Mr(St, u.prototype),
                  {
                    Iterable: r,
                    Seq: J,
                    Collection: wt,
                    Map: Ct,
                    OrderedMap: kn,
                    List: pn,
                    Stack: zr,
                    Set: sr,
                    OrderedSet: gr,
                    Record: ur,
                    Range: gt,
                    Repeat: yt,
                    is: _t,
                    fromJS: ht,
                  }
                );
              })();
            },
            function (t, n, r) {
              t.exports = r(5);
            },
            function (t, n) {
              var r;
              r = (function () {
                return this;
              })();
              try {
                r = r || new Function("return this")();
              } catch (t) {
                "object" == typeof window && (r = window);
              }
              t.exports = r;
            },
            function (t, n) {
              t.exports = function (t) {
                return (
                  t.webpackPolyfill ||
                    ((t.deprecate = function () {}),
                    (t.paths = []),
                    t.children || (t.children = []),
                    Object.defineProperty(t, "loaded", {
                      enumerable: !0,
                      get: function () {
                        return t.l;
                      },
                    }),
                    Object.defineProperty(t, "id", {
                      enumerable: !0,
                      get: function () {
                        return t.i;
                      },
                    }),
                    (t.webpackPolyfill = 1)),
                  t
                );
              };
            },
            function (t, n, r) {
              "use strict";
              r.r(n);
              var e = r(1),
                i = r(0);
              function u(t) {
                return (u =
                  "function" == typeof Symbol &&
                  "symbol" == typeof Symbol.iterator
                    ? function (t) {
                        return typeof t;
                      }
                    : function (t) {
                        return t &&
                          "function" == typeof Symbol &&
                          t.constructor === Symbol &&
                          t !== Symbol.prototype
                          ? "symbol"
                          : typeof t;
                      })(t);
              }
              function o(t, n) {
                if (!(t instanceof n))
                  throw new TypeError("Cannot call a class as a function");
              }
              function a(t, n) {
                return !n || ("object" !== u(n) && "function" != typeof n)
                  ? (function (t) {
                      if (void 0 === t)
                        throw new ReferenceError(
                          "this hasn't been initialised - super() hasn't been called"
                        );
                      return t;
                    })(t)
                  : n;
              }
              function f(t) {
                return (f = Object.setPrototypeOf
                  ? Object.getPrototypeOf
                  : function (t) {
                      return t.__proto__ || Object.getPrototypeOf(t);
                    })(t);
              }
              function c(t, n) {
                if ("function" != typeof n && null !== n)
                  throw new TypeError(
                    "Super expression must either be null or a function"
                  );
                (t.prototype = Object.create(n && n.prototype, {
                  constructor: { value: t, writable: !0, configurable: !0 },
                })),
                  n && s(t, n);
              }
              function s(t, n) {
                return (s =
                  Object.setPrototypeOf ||
                  function (t, n) {
                    return (t.__proto__ = n), t;
                  })(t, n);
              }
              var h = "black",
                l = "white",
                p = null,
                _ = (function (t) {
                  function n() {
                    var t =
                      arguments.length > 0 && void 0 !== arguments[0]
                        ? arguments[0]
                        : 19;
                    o(this, n);
                    for (
                      var r = arguments.length,
                        i = new Array(r > 1 ? r - 1 : 0),
                        u = 1;
                      u < r;
                      u++
                    )
                      i[u - 1] = arguments[u];
                    return a(
                      this,
                      f(n).call(this, {
                        dimensions: t,
                        moves: e.Map.of.apply(e.Map, i),
                      })
                    );
                  }
                  return c(n, t), n;
                })(
                  Object(e.Record)(
                    { dimensions: 19, moves: Object(e.Map)() },
                    "Board"
                  )
                ),
                v = (function (t) {
                  function n(t, r) {
                    return o(this, n), a(this, f(n).call(this, { x: t, y: r }));
                  }
                  return c(n, t), n;
                })(Object(e.Record)({ x: 0, y: 0 }, "Coordinate")),
                y = new v(4, 4),
                d = new v(6, 6),
                g = new v(9, 9);
              function w(t, n) {
                if (t.dimensions !== n.dimensions)
                  throw "board sizes do not match";
                var r = Object(e.Set)(
                    t.moves.entrySeq().map(function (t) {
                      return Object(e.List)(t);
                    })
                  ),
                  i = Object(e.Set)(
                    n.moves.entrySeq().map(function (t) {
                      return Object(e.List)(t);
                    })
                  );
                return r.subtract(i);
              }
              function m(t, n, r) {
                var u = void 0 === r ? t.moves.get(n, p) : r;
                return (function (t, n) {
                  var r = n.x,
                    u = n.y,
                    o = function (n) {
                      return Object(i.inRange)(n, t.dimensions);
                    };
                  return e.Set.of(
                    new v(r, u + 1),
                    new v(r, u - 1),
                    new v(r + 1, u),
                    new v(r - 1, u)
                  ).filter(function (t) {
                    return t.every(o);
                  });
                })(t, n).filter(function (n) {
                  return t.moves.get(n, p) === u;
                });
              }
              function b(t, n) {
                for (var r = Object(e.Set)(), i = e.Set.of(n); !i.isEmpty(); ) {
                  var u = i.first(),
                    o = m(t, u);
                  (r = r.add(u)), (i = i.rest().union(o.subtract(r)));
                }
                return r;
              }
              function S(t) {
                return t === h ? l : t === l ? h : p;
              }
              function I(t, n) {
                return b(t, n).reduce(function (n, r) {
                  return n.union(m(t, r, p));
                }, Object(e.Set)());
              }
              function z(t, n) {
                return I(t, n).size;
              }
              function x(t, n, r) {
                var e = z(t.setIn(["moves", n], r), n) > 0,
                  i = m(t, n, S(r)).some(function (n) {
                    return 1 === z(t, n);
                  });
                return e || i;
              }
              function O(t, n) {
                return t.setIn(
                  ["moves"],
                  n.reduce(function (t, n) {
                    return t.delete(n);
                  }, t.moves)
                );
              }
              function j(t, n, r) {
                if (!x(t, n, r)) throw "Not a valid position";
                if (t.moves.has(n)) throw "There is already a stone there";
                var i = m(t, n, S(r)).reduce(function (n, r) {
                  return n.union(1 === z(t, r) ? b(t, r) : Object(e.Set)());
                }, Object(e.Set)());
                return O(t, i).setIn(["moves", n], r);
              }
              function A(t, n, r) {
                var e =
                    arguments.length > 3 &&
                    void 0 !== arguments[3] &&
                    arguments[3],
                  i = t.moves.get(n, p);
                if (e || S(i) !== r) return t.setIn(["moves", n], r);
                throw "There is already a stone there.  Pass force=true to override.";
              }
              function E(t, n, r) {
                var e =
                  arguments.length > 3 &&
                  void 0 !== arguments[3] &&
                  arguments[3];
                return n.reduce(function (t, n) {
                  return A(t, n, r, e);
                }, t);
              }
              function k(t, n) {
                return (
                  (function (t) {
                    if (Array.isArray(t)) return t;
                  })(t) ||
                  (function (t, n) {
                    if (
                      !(
                        Symbol.iterator in Object(t) ||
                        "[object Arguments]" ===
                          Object.prototype.toString.call(t)
                      )
                    )
                      return;
                    var r = [],
                      e = !0,
                      i = !1,
                      u = void 0;
                    try {
                      for (
                        var o, a = t[Symbol.iterator]();
                        !(e = (o = a.next()).done) &&
                        (r.push(o.value), !n || r.length !== n);
                        e = !0
                      );
                    } catch (t) {
                      (i = !0), (u = t);
                    } finally {
                      try {
                        e || null == a.return || a.return();
                      } finally {
                        if (i) throw u;
                      }
                    }
                    return r;
                  })(t, n) ||
                  (function () {
                    throw new TypeError(
                      "Invalid attempt to destructure non-iterable instance"
                    );
                  })()
                );
              }
              var M = ";",
                D = "(",
                q = ")";
              function R(t) {
                var n = /^[a-zA-Z]+/,
                  r = t[0];
                switch (r) {
                  case D:
                  case q:
                  case M:
                    return [r, t.substr(1)];
                  default:
                    if (null === t.match(n)) throw "Invalid SGF";
                    var e = t.match(n)[0],
                      u = t.substr(e.length).trim(),
                      o = u.match(/[^\\]\]/);
                    if (!Object(i.startsWith)(u, "[") || null === o)
                      throw "Invalid SGF";
                    return [
                      [
                        e,
                        u
                          .substr(1, o.index)
                          .replace(/\\\\/g, "@@BACKSLASH@@")
                          .replace(/\\/g, "")
                          .replace("@@BACKSLASH@@", "\\"),
                      ],
                      u.substr(o.index + 2),
                    ];
                }
              }
              n.default = {
                BLACK: h,
                Board: _,
                Coordinate: v,
                EMPTY: p,
                WHITE: l,
                TENGEN_9: y,
                TENGEN_13: d,
                TENGEN_19: g,
                addMove: j,
                constructBoard: function (t) {
                  var n =
                      arguments.length > 1 && void 0 !== arguments[1]
                        ? arguments[1]
                        : null,
                    r =
                      arguments.length > 2 && void 0 !== arguments[2]
                        ? arguments[2]
                        : h;
                  n || (n = new _());
                  var e = S(r);
                  return t.reduce(function (t, n, u) {
                    var o = "Coordinate" === n.constructor.name,
                      a = Object(i.hasIn)(n, "x") && Object(i.hasIn)(n, "y");
                    if (!o && !a)
                      throw "You must pass coordinates or coordinate-like objects.";
                    return j(t, o ? n : new v(n.x, n.y), u % 2 == 0 ? r : e);
                  }, n);
                },
                difference: w,
                followupKo: function (t, n, r) {
                  if (!x(t, n, r)) return null;
                  var e = j(t, n, r),
                    i = w(t, e);
                  if (0 === i.size || i.size > 1) return null;
                  var u = i.first(),
                    o = u.get(0),
                    a = u.get(1);
                  if (x(e, o, a)) {
                    var f = w(e, j(e, o, a));
                    if (1 === f.size) if (f.first().get(0).equals(n)) return o;
                  }
                  return null;
                },
                group: b,
                handicapBoard: function (t, n) {
                  if (9 !== t && 13 !== t && 19 !== t)
                    throw "Only 9, 13, 19 allowed - use placeStone for non standard sizes";
                  if (!Object(i.inRange)(n, 0, 10) || !Object(i.isInteger)(n))
                    throw "Handicap must be an integer between 0 and 9";
                  var r = {
                      9: [
                        new v(2, 2),
                        new v(6, 6),
                        new v(2, 6),
                        new v(6, 2),
                        new v(6, 4),
                        new v(2, 4),
                        new v(4, 2),
                        new v(4, 6),
                      ],
                      13: [
                        new v(3, 3),
                        new v(9, 9),
                        new v(3, 9),
                        new v(9, 3),
                        new v(9, 6),
                        new v(3, 6),
                        new v(6, 3),
                        new v(6, 9),
                      ],
                      19: [
                        new v(3, 3),
                        new v(15, 15),
                        new v(15, 3),
                        new v(3, 15),
                        new v(15, 9),
                        new v(3, 9),
                        new v(9, 3),
                        new v(9, 15),
                      ],
                    }[t],
                    e = { 9: y, 13: d, 19: g }[t],
                    u = new _(t);
                  return E(
                    u,
                    n < 5
                      ? Object(i.take)(r, n)
                      : 5 === n
                      ? Object(i.concat)(Object(i.take)(r, 4), e)
                      : 6 === n
                      ? Object(i.take)(r, 6)
                      : 8 === n
                      ? r
                      : Object(i.concat)(Object(i.take)(r, n - 1), e),
                    h
                  );
                },
                isLegalMove: x,
                liberties: I,
                libertyCount: z,
                oppositeColor: S,
                placeStone: A,
                placeStones: E,
                removeStone: function (t, n) {
                  return t.set("moves", t.moves.delete(n));
                },
                removeStones: O,
                coordinateToSgfPoint: function (t) {
                  return (
                    String.fromCharCode(97 + t.x) +
                    String.fromCharCode(97 + t.y)
                  );
                },
                sgfPointToCoordinate: function (t) {
                  if (Object(i.isString)(t) && 2 === t.length)
                    return new v(t.charCodeAt(0) - 97, t.charCodeAt(1) - 97);
                  throw TypeError("Must pass a string of length 2");
                },
                sgfToJS: function (t) {
                  for (
                    var n = null,
                      r = [],
                      e = (function (t) {
                        for (var n = [], r = null, e = 0; e < t.length; e++) {
                          var u = t[e];
                          switch (u) {
                            case D:
                            case q:
                              null !== r &&
                                (n.push(Object(i.fromPairs)(r)), (r = null)),
                                n.push(u);
                              break;
                            case M:
                              null !== r &&
                                (n.push(Object(i.fromPairs)(r)), (r = null)),
                                (r = []);
                              break;
                            default:
                              r.push(u);
                          }
                        }
                        return n;
                      })(
                        (function (t) {
                          var n = [],
                            r = t;
                          for (; r; ) {
                            var e = k(R(Object(i.trimStart)(r)), 2),
                              u = e[0],
                              o = e[1];
                            n.push(u), (r = o);
                          }
                          return n;
                        })(t)
                      ),
                      u = 0;
                    u < e.length;
                    u++
                  ) {
                    var o = e[u],
                      a = Object(i.last)(r);
                    switch (o) {
                      case D:
                        var f = [];
                        null === n && (n = f),
                          r.push(f),
                          a &&
                            (Object(i.isArray)(Object(i.last)(a))
                              ? Object(i.last)(a).push(f)
                              : a.push([f]));
                        break;
                      case q:
                        r.pop();
                        break;
                      default:
                        a.push(o);
                    }
                  }
                  if (r.length > 0) throw "broken thing with too few ENDs";
                  return n;
                },
                toAsciiBoard: function (t) {
                  for (var n = t.dimensions, r = "", e = 0; e < n; e++) {
                    for (var i = 0; i < n; i++) {
                      switch (t.moves.get(new v(e, i), p)) {
                        case h:
                          r += "O";
                          break;
                        case l:
                          r += "X";
                          break;
                        case p:
                          r += "+";
                      }
                    }
                    r += "\n";
                  }
                  return r;
                },
              };
            },
          ]);
        });
      },
      {},
    ],
    3: [
      function (require, module, exports) {
        /**
         * Copyright (c) 2014-present, Facebook, Inc.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         */

        (function (global, factory) {
          typeof exports === "object" && typeof module !== "undefined"
            ? factory(exports)
            : typeof define === "function" && define.amd
            ? define(["exports"], factory)
            : factory((global.Immutable = {}));
        })(this, function (exports) {
          "use strict";

          // Used for setting prototype methods that IE8 chokes on.
          var DELETE = "delete";

          // Constants describing the size of trie nodes.
          var SHIFT = 5; // Resulted in best performance after ______?
          var SIZE = 1 << SHIFT;
          var MASK = SIZE - 1;

          // A consistent shared value representing "not set" which equals nothing other
          // than itself, and nothing that could be provided externally.
          var NOT_SET = {};

          // Boolean references, Rough equivalent of `bool &`.
          function MakeRef() {
            return { value: false };
          }

          function SetRef(ref) {
            if (ref) {
              ref.value = true;
            }
          }

          // A function which returns a value representing an "owner" for transient writes
          // to tries. The return value will only ever equal itself, and will not equal
          // the return of any subsequent call of this function.
          function OwnerID() {}

          function ensureSize(iter) {
            if (iter.size === undefined) {
              iter.size = iter.__iterate(returnTrue);
            }
            return iter.size;
          }

          function wrapIndex(iter, index) {
            // This implements "is array index" which the ECMAString spec defines as:
            //
            //     A String property name P is an array index if and only if
            //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal
            //     to 2^32−1.
            //
            // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects
            if (typeof index !== "number") {
              var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32
              if ("" + uint32Index !== index || uint32Index === 4294967295) {
                return NaN;
              }
              index = uint32Index;
            }
            return index < 0 ? ensureSize(iter) + index : index;
          }

          function returnTrue() {
            return true;
          }

          function wholeSlice(begin, end, size) {
            return (
              ((begin === 0 && !isNeg(begin)) ||
                (size !== undefined && begin <= -size)) &&
              (end === undefined || (size !== undefined && end >= size))
            );
          }

          function resolveBegin(begin, size) {
            return resolveIndex(begin, size, 0);
          }

          function resolveEnd(end, size) {
            return resolveIndex(end, size, size);
          }

          function resolveIndex(index, size, defaultIndex) {
            // Sanitize indices using this shorthand for ToInt32(argument)
            // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
            return index === undefined
              ? defaultIndex
              : isNeg(index)
              ? size === Infinity
                ? size
                : Math.max(0, size + index) | 0
              : size === undefined || size === index
              ? index
              : Math.min(size, index) | 0;
          }

          function isNeg(value) {
            // Account for -0 which is negative, but not less than 0.
            return value < 0 || (value === 0 && 1 / value === -Infinity);
          }

          // Note: value is unchanged to not break immutable-devtools.
          var IS_COLLECTION_SYMBOL = "@@__IMMUTABLE_ITERABLE__@@";

          function isCollection(maybeCollection) {
            return Boolean(
              maybeCollection && maybeCollection[IS_COLLECTION_SYMBOL]
            );
          }

          var IS_KEYED_SYMBOL = "@@__IMMUTABLE_KEYED__@@";

          function isKeyed(maybeKeyed) {
            return Boolean(maybeKeyed && maybeKeyed[IS_KEYED_SYMBOL]);
          }

          var IS_INDEXED_SYMBOL = "@@__IMMUTABLE_INDEXED__@@";

          function isIndexed(maybeIndexed) {
            return Boolean(maybeIndexed && maybeIndexed[IS_INDEXED_SYMBOL]);
          }

          function isAssociative(maybeAssociative) {
            return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);
          }

          var Collection = function Collection(value) {
            return isCollection(value) ? value : Seq(value);
          };

          var KeyedCollection = /*@__PURE__*/ (function (Collection) {
            function KeyedCollection(value) {
              return isKeyed(value) ? value : KeyedSeq(value);
            }

            if (Collection) KeyedCollection.__proto__ = Collection;
            KeyedCollection.prototype = Object.create(
              Collection && Collection.prototype
            );
            KeyedCollection.prototype.constructor = KeyedCollection;

            return KeyedCollection;
          })(Collection);

          var IndexedCollection = /*@__PURE__*/ (function (Collection) {
            function IndexedCollection(value) {
              return isIndexed(value) ? value : IndexedSeq(value);
            }

            if (Collection) IndexedCollection.__proto__ = Collection;
            IndexedCollection.prototype = Object.create(
              Collection && Collection.prototype
            );
            IndexedCollection.prototype.constructor = IndexedCollection;

            return IndexedCollection;
          })(Collection);

          var SetCollection = /*@__PURE__*/ (function (Collection) {
            function SetCollection(value) {
              return isCollection(value) && !isAssociative(value)
                ? value
                : SetSeq(value);
            }

            if (Collection) SetCollection.__proto__ = Collection;
            SetCollection.prototype = Object.create(
              Collection && Collection.prototype
            );
            SetCollection.prototype.constructor = SetCollection;

            return SetCollection;
          })(Collection);

          Collection.Keyed = KeyedCollection;
          Collection.Indexed = IndexedCollection;
          Collection.Set = SetCollection;

          var IS_SEQ_SYMBOL = "@@__IMMUTABLE_SEQ__@@";

          function isSeq(maybeSeq) {
            return Boolean(maybeSeq && maybeSeq[IS_SEQ_SYMBOL]);
          }

          var IS_RECORD_SYMBOL = "@@__IMMUTABLE_RECORD__@@";

          function isRecord(maybeRecord) {
            return Boolean(maybeRecord && maybeRecord[IS_RECORD_SYMBOL]);
          }

          function isImmutable(maybeImmutable) {
            return isCollection(maybeImmutable) || isRecord(maybeImmutable);
          }

          var IS_ORDERED_SYMBOL = "@@__IMMUTABLE_ORDERED__@@";

          function isOrdered(maybeOrdered) {
            return Boolean(maybeOrdered && maybeOrdered[IS_ORDERED_SYMBOL]);
          }

          var ITERATE_KEYS = 0;
          var ITERATE_VALUES = 1;
          var ITERATE_ENTRIES = 2;

          var REAL_ITERATOR_SYMBOL =
            typeof Symbol === "function" && Symbol.iterator;
          var FAUX_ITERATOR_SYMBOL = "@@iterator";

          var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;

          var Iterator = function Iterator(next) {
            this.next = next;
          };

          Iterator.prototype.toString = function toString() {
            return "[Iterator]";
          };

          Iterator.KEYS = ITERATE_KEYS;
          Iterator.VALUES = ITERATE_VALUES;
          Iterator.ENTRIES = ITERATE_ENTRIES;

          Iterator.prototype.inspect = Iterator.prototype.toSource = function () {
            return this.toString();
          };
          Iterator.prototype[ITERATOR_SYMBOL] = function () {
            return this;
          };

          function iteratorValue(type, k, v, iteratorResult) {
            var value = type === 0 ? k : type === 1 ? v : [k, v];
            iteratorResult
              ? (iteratorResult.value = value)
              : (iteratorResult = {
                  value: value,
                  done: false,
                });
            return iteratorResult;
          }

          function iteratorDone() {
            return { value: undefined, done: true };
          }

          function hasIterator(maybeIterable) {
            return !!getIteratorFn(maybeIterable);
          }

          function isIterator(maybeIterator) {
            return maybeIterator && typeof maybeIterator.next === "function";
          }

          function getIterator(iterable) {
            var iteratorFn = getIteratorFn(iterable);
            return iteratorFn && iteratorFn.call(iterable);
          }

          function getIteratorFn(iterable) {
            var iteratorFn =
              iterable &&
              ((REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL]) ||
                iterable[FAUX_ITERATOR_SYMBOL]);
            if (typeof iteratorFn === "function") {
              return iteratorFn;
            }
          }

          var hasOwnProperty = Object.prototype.hasOwnProperty;

          function isArrayLike(value) {
            if (Array.isArray(value) || typeof value === "string") {
              return true;
            }

            return (
              value &&
              typeof value === "object" &&
              Number.isInteger(value.length) &&
              value.length >= 0 &&
              (value.length === 0
                ? // Only {length: 0} is considered Array-like.
                  Object.keys(value).length === 1
                : // An object is only Array-like if it has a property where the last value
                  // in the array-like may be found (which could be undefined).
                  value.hasOwnProperty(value.length - 1))
            );
          }

          var Seq = /*@__PURE__*/ (function (Collection$$1) {
            function Seq(value) {
              return value === null || value === undefined
                ? emptySequence()
                : isImmutable(value)
                ? value.toSeq()
                : seqFromValue(value);
            }

            if (Collection$$1) Seq.__proto__ = Collection$$1;
            Seq.prototype = Object.create(
              Collection$$1 && Collection$$1.prototype
            );
            Seq.prototype.constructor = Seq;

            Seq.prototype.toSeq = function toSeq() {
              return this;
            };

            Seq.prototype.toString = function toString() {
              return this.__toString("Seq {", "}");
            };

            Seq.prototype.cacheResult = function cacheResult() {
              if (!this._cache && this.__iterateUncached) {
                this._cache = this.entrySeq().toArray();
                this.size = this._cache.length;
              }
              return this;
            };

            // abstract __iterateUncached(fn, reverse)

            Seq.prototype.__iterate = function __iterate(fn, reverse) {
              var cache = this._cache;
              if (cache) {
                var size = cache.length;
                var i = 0;
                while (i !== size) {
                  var entry = cache[reverse ? size - ++i : i++];
                  if (fn(entry[1], entry[0], this) === false) {
                    break;
                  }
                }
                return i;
              }
              return this.__iterateUncached(fn, reverse);
            };

            // abstract __iteratorUncached(type, reverse)

            Seq.prototype.__iterator = function __iterator(type, reverse) {
              var cache = this._cache;
              if (cache) {
                var size = cache.length;
                var i = 0;
                return new Iterator(function () {
                  if (i === size) {
                    return iteratorDone();
                  }
                  var entry = cache[reverse ? size - ++i : i++];
                  return iteratorValue(type, entry[0], entry[1]);
                });
              }
              return this.__iteratorUncached(type, reverse);
            };

            return Seq;
          })(Collection);

          var KeyedSeq = /*@__PURE__*/ (function (Seq) {
            function KeyedSeq(value) {
              return value === null || value === undefined
                ? emptySequence().toKeyedSeq()
                : isCollection(value)
                ? isKeyed(value)
                  ? value.toSeq()
                  : value.fromEntrySeq()
                : isRecord(value)
                ? value.toSeq()
                : keyedSeqFromValue(value);
            }

            if (Seq) KeyedSeq.__proto__ = Seq;
            KeyedSeq.prototype = Object.create(Seq && Seq.prototype);
            KeyedSeq.prototype.constructor = KeyedSeq;

            KeyedSeq.prototype.toKeyedSeq = function toKeyedSeq() {
              return this;
            };

            return KeyedSeq;
          })(Seq);

          var IndexedSeq = /*@__PURE__*/ (function (Seq) {
            function IndexedSeq(value) {
              return value === null || value === undefined
                ? emptySequence()
                : isCollection(value)
                ? isKeyed(value)
                  ? value.entrySeq()
                  : value.toIndexedSeq()
                : isRecord(value)
                ? value.toSeq().entrySeq()
                : indexedSeqFromValue(value);
            }

            if (Seq) IndexedSeq.__proto__ = Seq;
            IndexedSeq.prototype = Object.create(Seq && Seq.prototype);
            IndexedSeq.prototype.constructor = IndexedSeq;

            IndexedSeq.of = function of(/*...values*/) {
              return IndexedSeq(arguments);
            };

            IndexedSeq.prototype.toIndexedSeq = function toIndexedSeq() {
              return this;
            };

            IndexedSeq.prototype.toString = function toString() {
              return this.__toString("Seq [", "]");
            };

            return IndexedSeq;
          })(Seq);

          var SetSeq = /*@__PURE__*/ (function (Seq) {
            function SetSeq(value) {
              return (isCollection(value) && !isAssociative(value)
                ? value
                : IndexedSeq(value)
              ).toSetSeq();
            }

            if (Seq) SetSeq.__proto__ = Seq;
            SetSeq.prototype = Object.create(Seq && Seq.prototype);
            SetSeq.prototype.constructor = SetSeq;

            SetSeq.of = function of(/*...values*/) {
              return SetSeq(arguments);
            };

            SetSeq.prototype.toSetSeq = function toSetSeq() {
              return this;
            };

            return SetSeq;
          })(Seq);

          Seq.isSeq = isSeq;
          Seq.Keyed = KeyedSeq;
          Seq.Set = SetSeq;
          Seq.Indexed = IndexedSeq;

          Seq.prototype[IS_SEQ_SYMBOL] = true;

          // #pragma Root Sequences

          var ArraySeq = /*@__PURE__*/ (function (IndexedSeq) {
            function ArraySeq(array) {
              this._array = array;
              this.size = array.length;
            }

            if (IndexedSeq) ArraySeq.__proto__ = IndexedSeq;
            ArraySeq.prototype = Object.create(
              IndexedSeq && IndexedSeq.prototype
            );
            ArraySeq.prototype.constructor = ArraySeq;

            ArraySeq.prototype.get = function get(index, notSetValue) {
              return this.has(index)
                ? this._array[wrapIndex(this, index)]
                : notSetValue;
            };

            ArraySeq.prototype.__iterate = function __iterate(fn, reverse) {
              var array = this._array;
              var size = array.length;
              var i = 0;
              while (i !== size) {
                var ii = reverse ? size - ++i : i++;
                if (fn(array[ii], ii, this) === false) {
                  break;
                }
              }
              return i;
            };

            ArraySeq.prototype.__iterator = function __iterator(type, reverse) {
              var array = this._array;
              var size = array.length;
              var i = 0;
              return new Iterator(function () {
                if (i === size) {
                  return iteratorDone();
                }
                var ii = reverse ? size - ++i : i++;
                return iteratorValue(type, ii, array[ii]);
              });
            };

            return ArraySeq;
          })(IndexedSeq);

          var ObjectSeq = /*@__PURE__*/ (function (KeyedSeq) {
            function ObjectSeq(object) {
              var keys = Object.keys(object);
              this._object = object;
              this._keys = keys;
              this.size = keys.length;
            }

            if (KeyedSeq) ObjectSeq.__proto__ = KeyedSeq;
            ObjectSeq.prototype = Object.create(KeyedSeq && KeyedSeq.prototype);
            ObjectSeq.prototype.constructor = ObjectSeq;

            ObjectSeq.prototype.get = function get(key, notSetValue) {
              if (notSetValue !== undefined && !this.has(key)) {
                return notSetValue;
              }
              return this._object[key];
            };

            ObjectSeq.prototype.has = function has(key) {
              return hasOwnProperty.call(this._object, key);
            };

            ObjectSeq.prototype.__iterate = function __iterate(fn, reverse) {
              var object = this._object;
              var keys = this._keys;
              var size = keys.length;
              var i = 0;
              while (i !== size) {
                var key = keys[reverse ? size - ++i : i++];
                if (fn(object[key], key, this) === false) {
                  break;
                }
              }
              return i;
            };

            ObjectSeq.prototype.__iterator = function __iterator(
              type,
              reverse
            ) {
              var object = this._object;
              var keys = this._keys;
              var size = keys.length;
              var i = 0;
              return new Iterator(function () {
                if (i === size) {
                  return iteratorDone();
                }
                var key = keys[reverse ? size - ++i : i++];
                return iteratorValue(type, key, object[key]);
              });
            };

            return ObjectSeq;
          })(KeyedSeq);
          ObjectSeq.prototype[IS_ORDERED_SYMBOL] = true;

          var CollectionSeq = /*@__PURE__*/ (function (IndexedSeq) {
            function CollectionSeq(collection) {
              this._collection = collection;
              this.size = collection.length || collection.size;
            }

            if (IndexedSeq) CollectionSeq.__proto__ = IndexedSeq;
            CollectionSeq.prototype = Object.create(
              IndexedSeq && IndexedSeq.prototype
            );
            CollectionSeq.prototype.constructor = CollectionSeq;

            CollectionSeq.prototype.__iterateUncached = function __iterateUncached(
              fn,
              reverse
            ) {
              if (reverse) {
                return this.cacheResult().__iterate(fn, reverse);
              }
              var collection = this._collection;
              var iterator = getIterator(collection);
              var iterations = 0;
              if (isIterator(iterator)) {
                var step;
                while (!(step = iterator.next()).done) {
                  if (fn(step.value, iterations++, this) === false) {
                    break;
                  }
                }
              }
              return iterations;
            };

            CollectionSeq.prototype.__iteratorUncached = function __iteratorUncached(
              type,
              reverse
            ) {
              if (reverse) {
                return this.cacheResult().__iterator(type, reverse);
              }
              var collection = this._collection;
              var iterator = getIterator(collection);
              if (!isIterator(iterator)) {
                return new Iterator(iteratorDone);
              }
              var iterations = 0;
              return new Iterator(function () {
                var step = iterator.next();
                return step.done
                  ? step
                  : iteratorValue(type, iterations++, step.value);
              });
            };

            return CollectionSeq;
          })(IndexedSeq);

          // # pragma Helper functions

          var EMPTY_SEQ;

          function emptySequence() {
            return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));
          }

          function keyedSeqFromValue(value) {
            var seq = Array.isArray(value)
              ? new ArraySeq(value)
              : hasIterator(value)
              ? new CollectionSeq(value)
              : undefined;
            if (seq) {
              return seq.fromEntrySeq();
            }
            if (typeof value === "object") {
              return new ObjectSeq(value);
            }
            throw new TypeError(
              "Expected Array or collection object of [k, v] entries, or keyed object: " +
                value
            );
          }

          function indexedSeqFromValue(value) {
            var seq = maybeIndexedSeqFromValue(value);
            if (seq) {
              return seq;
            }
            throw new TypeError(
              "Expected Array or collection object of values: " + value
            );
          }

          function seqFromValue(value) {
            var seq = maybeIndexedSeqFromValue(value);
            if (seq) {
              return seq;
            }
            if (typeof value === "object") {
              return new ObjectSeq(value);
            }
            throw new TypeError(
              "Expected Array or collection object of values, or keyed object: " +
                value
            );
          }

          function maybeIndexedSeqFromValue(value) {
            return isArrayLike(value)
              ? new ArraySeq(value)
              : hasIterator(value)
              ? new CollectionSeq(value)
              : undefined;
          }

          var IS_MAP_SYMBOL = "@@__IMMUTABLE_MAP__@@";

          function isMap(maybeMap) {
            return Boolean(maybeMap && maybeMap[IS_MAP_SYMBOL]);
          }

          function isOrderedMap(maybeOrderedMap) {
            return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);
          }

          function isValueObject(maybeValue) {
            return Boolean(
              maybeValue &&
                typeof maybeValue.equals === "function" &&
                typeof maybeValue.hashCode === "function"
            );
          }

          /**
           * An extension of the "same-value" algorithm as [described for use by ES6 Map
           * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)
           *
           * NaN is considered the same as NaN, however -0 and 0 are considered the same
           * value, which is different from the algorithm described by
           * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).
           *
           * This is extended further to allow Objects to describe the values they
           * represent, by way of `valueOf` or `equals` (and `hashCode`).
           *
           * Note: because of this extension, the key equality of Immutable.Map and the
           * value equality of Immutable.Set will differ from ES6 Map and Set.
           *
           * ### Defining custom values
           *
           * The easiest way to describe the value an object represents is by implementing
           * `valueOf`. For example, `Date` represents a value by returning a unix
           * timestamp for `valueOf`:
           *
           *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...
           *     var date2 = new Date(1234567890000);
           *     date1.valueOf(); // 1234567890000
           *     assert( date1 !== date2 );
           *     assert( Immutable.is( date1, date2 ) );
           *
           * Note: overriding `valueOf` may have other implications if you use this object
           * where JavaScript expects a primitive, such as implicit string coercion.
           *
           * For more complex types, especially collections, implementing `valueOf` may
           * not be performant. An alternative is to implement `equals` and `hashCode`.
           *
           * `equals` takes another object, presumably of similar type, and returns true
           * if it is equal. Equality is symmetrical, so the same result should be
           * returned if this and the argument are flipped.
           *
           *     assert( a.equals(b) === b.equals(a) );
           *
           * `hashCode` returns a 32bit integer number representing the object which will
           * be used to determine how to store the value object in a Map or Set. You must
           * provide both or neither methods, one must not exist without the other.
           *
           * Also, an important relationship between these methods must be upheld: if two
           * values are equal, they *must* return the same hashCode. If the values are not
           * equal, they might have the same hashCode; this is called a hash collision,
           * and while undesirable for performance reasons, it is acceptable.
           *
           *     if (a.equals(b)) {
           *       assert( a.hashCode() === b.hashCode() );
           *     }
           *
           * All Immutable collections are Value Objects: they implement `equals()`
           * and `hashCode()`.
           */
          function is(valueA, valueB) {
            if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
              return true;
            }
            if (!valueA || !valueB) {
              return false;
            }
            if (
              typeof valueA.valueOf === "function" &&
              typeof valueB.valueOf === "function"
            ) {
              valueA = valueA.valueOf();
              valueB = valueB.valueOf();
              if (
                valueA === valueB ||
                (valueA !== valueA && valueB !== valueB)
              ) {
                return true;
              }
              if (!valueA || !valueB) {
                return false;
              }
            }
            return !!(
              isValueObject(valueA) &&
              isValueObject(valueB) &&
              valueA.equals(valueB)
            );
          }

          var imul =
            typeof Math.imul === "function" && Math.imul(0xffffffff, 2) === -2
              ? Math.imul
              : function imul(a, b) {
                  a |= 0; // int
                  b |= 0; // int
                  var c = a & 0xffff;
                  var d = b & 0xffff;
                  // Shift by 0 fixes the sign on the high part.
                  return (
                    (c * d +
                      ((((a >>> 16) * d + c * (b >>> 16)) << 16) >>> 0)) |
                    0
                  ); // int
                };

          // v8 has an optimization for storing 31-bit signed numbers.
          // Values which have either 00 or 11 as the high order bits qualify.
          // This function drops the highest order bit in a signed number, maintaining
          // the sign bit.
          function smi(i32) {
            return ((i32 >>> 1) & 0x40000000) | (i32 & 0xbfffffff);
          }

          var defaultValueOf = Object.prototype.valueOf;

          function hash(o) {
            switch (typeof o) {
              case "boolean":
                // The hash values for built-in constants are a 1 value for each 5-byte
                // shift region expect for the first, which encodes the value. This
                // reduces the odds of a hash collision for these common values.
                return o ? 0x42108421 : 0x42108420;
              case "number":
                return hashNumber(o);
              case "string":
                return o.length > STRING_HASH_CACHE_MIN_STRLEN
                  ? cachedHashString(o)
                  : hashString(o);
              case "object":
              case "function":
                if (o === null) {
                  return 0x42108422;
                }
                if (typeof o.hashCode === "function") {
                  // Drop any high bits from accidentally long hash codes.
                  return smi(o.hashCode(o));
                }
                if (
                  o.valueOf !== defaultValueOf &&
                  typeof o.valueOf === "function"
                ) {
                  o = o.valueOf(o);
                }
                return hashJSObj(o);
              case "undefined":
                return 0x42108423;
              default:
                if (typeof o.toString === "function") {
                  return hashString(o.toString());
                }
                throw new Error(
                  "Value type " + typeof o + " cannot be hashed."
                );
            }
          }

          // Compress arbitrarily large numbers into smi hashes.
          function hashNumber(n) {
            if (n !== n || n === Infinity) {
              return 0;
            }
            var hash = n | 0;
            if (hash !== n) {
              hash ^= n * 0xffffffff;
            }
            while (n > 0xffffffff) {
              n /= 0xffffffff;
              hash ^= n;
            }
            return smi(hash);
          }

          function cachedHashString(string) {
            var hashed = stringHashCache[string];
            if (hashed === undefined) {
              hashed = hashString(string);
              if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
                STRING_HASH_CACHE_SIZE = 0;
                stringHashCache = {};
              }
              STRING_HASH_CACHE_SIZE++;
              stringHashCache[string] = hashed;
            }
            return hashed;
          }

          // http://jsperf.com/hashing-strings
          function hashString(string) {
            // This is the hash from JVM
            // The hash code for a string is computed as
            // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],
            // where s[i] is the ith character of the string and n is the length of
            // the string. We "mod" the result to make it between 0 (inclusive) and 2^31
            // (exclusive) by dropping high bits.
            var hashed = 0;
            for (var ii = 0; ii < string.length; ii++) {
              hashed = (31 * hashed + string.charCodeAt(ii)) | 0;
            }
            return smi(hashed);
          }

          function hashJSObj(obj) {
            var hashed;
            if (usingWeakMap) {
              hashed = weakMap.get(obj);
              if (hashed !== undefined) {
                return hashed;
              }
            }

            hashed = obj[UID_HASH_KEY];
            if (hashed !== undefined) {
              return hashed;
            }

            if (!canDefineProperty) {
              hashed =
                obj.propertyIsEnumerable &&
                obj.propertyIsEnumerable[UID_HASH_KEY];
              if (hashed !== undefined) {
                return hashed;
              }

              hashed = getIENodeHash(obj);
              if (hashed !== undefined) {
                return hashed;
              }
            }

            hashed = ++objHashUID;
            if (objHashUID & 0x40000000) {
              objHashUID = 0;
            }

            if (usingWeakMap) {
              weakMap.set(obj, hashed);
            } else if (
              isExtensible !== undefined &&
              isExtensible(obj) === false
            ) {
              throw new Error(
                "Non-extensible objects are not allowed as keys."
              );
            } else if (canDefineProperty) {
              Object.defineProperty(obj, UID_HASH_KEY, {
                enumerable: false,
                configurable: false,
                writable: false,
                value: hashed,
              });
            } else if (
              obj.propertyIsEnumerable !== undefined &&
              obj.propertyIsEnumerable ===
                obj.constructor.prototype.propertyIsEnumerable
            ) {
              // Since we can't define a non-enumerable property on the object
              // we'll hijack one of the less-used non-enumerable properties to
              // save our hash on it. Since this is a function it will not show up in
              // `JSON.stringify` which is what we want.
              obj.propertyIsEnumerable = function () {
                return this.constructor.prototype.propertyIsEnumerable.apply(
                  this,
                  arguments
                );
              };
              obj.propertyIsEnumerable[UID_HASH_KEY] = hashed;
            } else if (obj.nodeType !== undefined) {
              // At this point we couldn't get the IE `uniqueID` to use as a hash
              // and we couldn't use a non-enumerable property to exploit the
              // dontEnum bug so we simply add the `UID_HASH_KEY` on the node
              // itself.
              obj[UID_HASH_KEY] = hashed;
            } else {
              throw new Error(
                "Unable to set a non-enumerable property on object."
              );
            }

            return hashed;
          }

          // Get references to ES5 object methods.
          var isExtensible = Object.isExtensible;

          // True if Object.defineProperty works as expected. IE8 fails this test.
          var canDefineProperty = (function () {
            try {
              Object.defineProperty({}, "@", {});
              return true;
            } catch (e) {
              return false;
            }
          })();

          // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it
          // and avoid memory leaks from the IE cloneNode bug.
          function getIENodeHash(node) {
            if (node && node.nodeType > 0) {
              switch (node.nodeType) {
                case 1: // Element
                  return node.uniqueID;
                case 9: // Document
                  return node.documentElement && node.documentElement.uniqueID;
              }
            }
          }

          // If possible, use a WeakMap.
          var usingWeakMap = typeof WeakMap === "function";
          var weakMap;
          if (usingWeakMap) {
            weakMap = new WeakMap();
          }

          var objHashUID = 0;

          var UID_HASH_KEY = "__immutablehash__";
          if (typeof Symbol === "function") {
            UID_HASH_KEY = Symbol(UID_HASH_KEY);
          }

          var STRING_HASH_CACHE_MIN_STRLEN = 16;
          var STRING_HASH_CACHE_MAX_SIZE = 255;
          var STRING_HASH_CACHE_SIZE = 0;
          var stringHashCache = {};

          var ToKeyedSequence = /*@__PURE__*/ (function (KeyedSeq$$1) {
            function ToKeyedSequence(indexed, useKeys) {
              this._iter = indexed;
              this._useKeys = useKeys;
              this.size = indexed.size;
            }

            if (KeyedSeq$$1) ToKeyedSequence.__proto__ = KeyedSeq$$1;
            ToKeyedSequence.prototype = Object.create(
              KeyedSeq$$1 && KeyedSeq$$1.prototype
            );
            ToKeyedSequence.prototype.constructor = ToKeyedSequence;

            ToKeyedSequence.prototype.get = function get(key, notSetValue) {
              return this._iter.get(key, notSetValue);
            };

            ToKeyedSequence.prototype.has = function has(key) {
              return this._iter.has(key);
            };

            ToKeyedSequence.prototype.valueSeq = function valueSeq() {
              return this._iter.valueSeq();
            };

            ToKeyedSequence.prototype.reverse = function reverse() {
              var this$1 = this;

              var reversedSequence = reverseFactory(this, true);
              if (!this._useKeys) {
                reversedSequence.valueSeq = function () {
                  return this$1._iter.toSeq().reverse();
                };
              }
              return reversedSequence;
            };

            ToKeyedSequence.prototype.map = function map(mapper, context) {
              var this$1 = this;

              var mappedSequence = mapFactory(this, mapper, context);
              if (!this._useKeys) {
                mappedSequence.valueSeq = function () {
                  return this$1._iter.toSeq().map(mapper, context);
                };
              }
              return mappedSequence;
            };

            ToKeyedSequence.prototype.__iterate = function __iterate(
              fn,
              reverse
            ) {
              var this$1 = this;

              return this._iter.__iterate(function (v, k) {
                return fn(v, k, this$1);
              }, reverse);
            };

            ToKeyedSequence.prototype.__iterator = function __iterator(
              type,
              reverse
            ) {
              return this._iter.__iterator(type, reverse);
            };

            return ToKeyedSequence;
          })(KeyedSeq);
          ToKeyedSequence.prototype[IS_ORDERED_SYMBOL] = true;

          var ToIndexedSequence = /*@__PURE__*/ (function (IndexedSeq$$1) {
            function ToIndexedSequence(iter) {
              this._iter = iter;
              this.size = iter.size;
            }

            if (IndexedSeq$$1) ToIndexedSequence.__proto__ = IndexedSeq$$1;
            ToIndexedSequence.prototype = Object.create(
              IndexedSeq$$1 && IndexedSeq$$1.prototype
            );
            ToIndexedSequence.prototype.constructor = ToIndexedSequence;

            ToIndexedSequence.prototype.includes = function includes(value) {
              return this._iter.includes(value);
            };

            ToIndexedSequence.prototype.__iterate = function __iterate(
              fn,
              reverse
            ) {
              var this$1 = this;

              var i = 0;
              reverse && ensureSize(this);
              return this._iter.__iterate(function (v) {
                return fn(v, reverse ? this$1.size - ++i : i++, this$1);
              }, reverse);
            };

            ToIndexedSequence.prototype.__iterator = function __iterator(
              type,
              reverse
            ) {
              var this$1 = this;

              var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
              var i = 0;
              reverse && ensureSize(this);
              return new Iterator(function () {
                var step = iterator.next();
                return step.done
                  ? step
                  : iteratorValue(
                      type,
                      reverse ? this$1.size - ++i : i++,
                      step.value,
                      step
                    );
              });
            };

            return ToIndexedSequence;
          })(IndexedSeq);

          var ToSetSequence = /*@__PURE__*/ (function (SetSeq$$1) {
            function ToSetSequence(iter) {
              this._iter = iter;
              this.size = iter.size;
            }

            if (SetSeq$$1) ToSetSequence.__proto__ = SetSeq$$1;
            ToSetSequence.prototype = Object.create(
              SetSeq$$1 && SetSeq$$1.prototype
            );
            ToSetSequence.prototype.constructor = ToSetSequence;

            ToSetSequence.prototype.has = function has(key) {
              return this._iter.includes(key);
            };

            ToSetSequence.prototype.__iterate = function __iterate(
              fn,
              reverse
            ) {
              var this$1 = this;

              return this._iter.__iterate(function (v) {
                return fn(v, v, this$1);
              }, reverse);
            };

            ToSetSequence.prototype.__iterator = function __iterator(
              type,
              reverse
            ) {
              var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
              return new Iterator(function () {
                var step = iterator.next();
                return step.done
                  ? step
                  : iteratorValue(type, step.value, step.value, step);
              });
            };

            return ToSetSequence;
          })(SetSeq);

          var FromEntriesSequence = /*@__PURE__*/ (function (KeyedSeq$$1) {
            function FromEntriesSequence(entries) {
              this._iter = entries;
              this.size = entries.size;
            }

            if (KeyedSeq$$1) FromEntriesSequence.__proto__ = KeyedSeq$$1;
            FromEntriesSequence.prototype = Object.create(
              KeyedSeq$$1 && KeyedSeq$$1.prototype
            );
            FromEntriesSequence.prototype.constructor = FromEntriesSequence;

            FromEntriesSequence.prototype.entrySeq = function entrySeq() {
              return this._iter.toSeq();
            };

            FromEntriesSequence.prototype.__iterate = function __iterate(
              fn,
              reverse
            ) {
              var this$1 = this;

              return this._iter.__iterate(function (entry) {
                // Check if entry exists first so array access doesn't throw for holes
                // in the parent iteration.
                if (entry) {
                  validateEntry(entry);
                  var indexedCollection = isCollection(entry);
                  return fn(
                    indexedCollection ? entry.get(1) : entry[1],
                    indexedCollection ? entry.get(0) : entry[0],
                    this$1
                  );
                }
              }, reverse);
            };

            FromEntriesSequence.prototype.__iterator = function __iterator(
              type,
              reverse
            ) {
              var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
              return new Iterator(function () {
                while (true) {
                  var step = iterator.next();
                  if (step.done) {
                    return step;
                  }
                  var entry = step.value;
                  // Check if entry exists first so array access doesn't throw for holes
                  // in the parent iteration.
                  if (entry) {
                    validateEntry(entry);
                    var indexedCollection = isCollection(entry);
                    return iteratorValue(
                      type,
                      indexedCollection ? entry.get(0) : entry[0],
                      indexedCollection ? entry.get(1) : entry[1],
                      step
                    );
                  }
                }
              });
            };

            return FromEntriesSequence;
          })(KeyedSeq);

          ToIndexedSequence.prototype.cacheResult = ToKeyedSequence.prototype.cacheResult = ToSetSequence.prototype.cacheResult = FromEntriesSequence.prototype.cacheResult = cacheResultThrough;

          function flipFactory(collection) {
            var flipSequence = makeSequence(collection);
            flipSequence._iter = collection;
            flipSequence.size = collection.size;
            flipSequence.flip = function () {
              return collection;
            };
            flipSequence.reverse = function () {
              var reversedSequence = collection.reverse.apply(this); // super.reverse()
              reversedSequence.flip = function () {
                return collection.reverse();
              };
              return reversedSequence;
            };
            flipSequence.has = function (key) {
              return collection.includes(key);
            };
            flipSequence.includes = function (key) {
              return collection.has(key);
            };
            flipSequence.cacheResult = cacheResultThrough;
            flipSequence.__iterateUncached = function (fn, reverse) {
              var this$1 = this;

              return collection.__iterate(function (v, k) {
                return fn(k, v, this$1) !== false;
              }, reverse);
            };
            flipSequence.__iteratorUncached = function (type, reverse) {
              if (type === ITERATE_ENTRIES) {
                var iterator = collection.__iterator(type, reverse);
                return new Iterator(function () {
                  var step = iterator.next();
                  if (!step.done) {
                    var k = step.value[0];
                    step.value[0] = step.value[1];
                    step.value[1] = k;
                  }
                  return step;
                });
              }
              return collection.__iterator(
                type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,
                reverse
              );
            };
            return flipSequence;
          }

          function mapFactory(collection, mapper, context) {
            var mappedSequence = makeSequence(collection);
            mappedSequence.size = collection.size;
            mappedSequence.has = function (key) {
              return collection.has(key);
            };
            mappedSequence.get = function (key, notSetValue) {
              var v = collection.get(key, NOT_SET);
              return v === NOT_SET
                ? notSetValue
                : mapper.call(context, v, key, collection);
            };
            mappedSequence.__iterateUncached = function (fn, reverse) {
              var this$1 = this;

              return collection.__iterate(function (v, k, c) {
                return fn(mapper.call(context, v, k, c), k, this$1) !== false;
              }, reverse);
            };
            mappedSequence.__iteratorUncached = function (type, reverse) {
              var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);
              return new Iterator(function () {
                var step = iterator.next();
                if (step.done) {
                  return step;
                }
                var entry = step.value;
                var key = entry[0];
                return iteratorValue(
                  type,
                  key,
                  mapper.call(context, entry[1], key, collection),
                  step
                );
              });
            };
            return mappedSequence;
          }

          function reverseFactory(collection, useKeys) {
            var this$1 = this;

            var reversedSequence = makeSequence(collection);
            reversedSequence._iter = collection;
            reversedSequence.size = collection.size;
            reversedSequence.reverse = function () {
              return collection;
            };
            if (collection.flip) {
              reversedSequence.flip = function () {
                var flipSequence = flipFactory(collection);
                flipSequence.reverse = function () {
                  return collection.flip();
                };
                return flipSequence;
              };
            }
            reversedSequence.get = function (key, notSetValue) {
              return collection.get(useKeys ? key : -1 - key, notSetValue);
            };
            reversedSequence.has = function (key) {
              return collection.has(useKeys ? key : -1 - key);
            };
            reversedSequence.includes = function (value) {
              return collection.includes(value);
            };
            reversedSequence.cacheResult = cacheResultThrough;
            reversedSequence.__iterate = function (fn, reverse) {
              var this$1 = this;

              var i = 0;
              reverse && ensureSize(collection);
              return collection.__iterate(function (v, k) {
                return fn(
                  v,
                  useKeys ? k : reverse ? this$1.size - ++i : i++,
                  this$1
                );
              }, !reverse);
            };
            reversedSequence.__iterator = function (type, reverse) {
              var i = 0;
              reverse && ensureSize(collection);
              var iterator = collection.__iterator(ITERATE_ENTRIES, !reverse);
              return new Iterator(function () {
                var step = iterator.next();
                if (step.done) {
                  return step;
                }
                var entry = step.value;
                return iteratorValue(
                  type,
                  useKeys ? entry[0] : reverse ? this$1.size - ++i : i++,
                  entry[1],
                  step
                );
              });
            };
            return reversedSequence;
          }

          function filterFactory(collection, predicate, context, useKeys) {
            var filterSequence = makeSequence(collection);
            if (useKeys) {
              filterSequence.has = function (key) {
                var v = collection.get(key, NOT_SET);
                return (
                  v !== NOT_SET && !!predicate.call(context, v, key, collection)
                );
              };
              filterSequence.get = function (key, notSetValue) {
                var v = collection.get(key, NOT_SET);
                return v !== NOT_SET &&
                  predicate.call(context, v, key, collection)
                  ? v
                  : notSetValue;
              };
            }
            filterSequence.__iterateUncached = function (fn, reverse) {
              var this$1 = this;

              var iterations = 0;
              collection.__iterate(function (v, k, c) {
                if (predicate.call(context, v, k, c)) {
                  iterations++;
                  return fn(v, useKeys ? k : iterations - 1, this$1);
                }
              }, reverse);
              return iterations;
            };
            filterSequence.__iteratorUncached = function (type, reverse) {
              var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);
              var iterations = 0;
              return new Iterator(function () {
                while (true) {
                  var step = iterator.next();
                  if (step.done) {
                    return step;
                  }
                  var entry = step.value;
                  var key = entry[0];
                  var value = entry[1];
                  if (predicate.call(context, value, key, collection)) {
                    return iteratorValue(
                      type,
                      useKeys ? key : iterations++,
                      value,
                      step
                    );
                  }
                }
              });
            };
            return filterSequence;
          }

          function countByFactory(collection, grouper, context) {
            var groups = Map().asMutable();
            collection.__iterate(function (v, k) {
              groups.update(
                grouper.call(context, v, k, collection),
                0,
                function (a) {
                  return a + 1;
                }
              );
            });
            return groups.asImmutable();
          }

          function groupByFactory(collection, grouper, context) {
            var isKeyedIter = isKeyed(collection);
            var groups = (isOrdered(collection)
              ? OrderedMap()
              : Map()
            ).asMutable();
            collection.__iterate(function (v, k) {
              groups.update(grouper.call(context, v, k, collection), function (
                a
              ) {
                return (a = a || []), a.push(isKeyedIter ? [k, v] : v), a;
              });
            });
            var coerce = collectionClass(collection);
            return groups
              .map(function (arr) {
                return reify(collection, coerce(arr));
              })
              .asImmutable();
          }

          function sliceFactory(collection, begin, end, useKeys) {
            var originalSize = collection.size;

            if (wholeSlice(begin, end, originalSize)) {
              return collection;
            }

            var resolvedBegin = resolveBegin(begin, originalSize);
            var resolvedEnd = resolveEnd(end, originalSize);

            // begin or end will be NaN if they were provided as negative numbers and
            // this collection's size is unknown. In that case, cache first so there is
            // a known size and these do not resolve to NaN.
            if (
              resolvedBegin !== resolvedBegin ||
              resolvedEnd !== resolvedEnd
            ) {
              return sliceFactory(
                collection.toSeq().cacheResult(),
                begin,
                end,
                useKeys
              );
            }

            // Note: resolvedEnd is undefined when the original sequence's length is
            // unknown and this slice did not supply an end and should contain all
            // elements after resolvedBegin.
            // In that case, resolvedSize will be NaN and sliceSize will remain undefined.
            var resolvedSize = resolvedEnd - resolvedBegin;
            var sliceSize;
            if (resolvedSize === resolvedSize) {
              sliceSize = resolvedSize < 0 ? 0 : resolvedSize;
            }

            var sliceSeq = makeSequence(collection);

            // If collection.size is undefined, the size of the realized sliceSeq is
            // unknown at this point unless the number of items to slice is 0
            sliceSeq.size =
              sliceSize === 0
                ? sliceSize
                : (collection.size && sliceSize) || undefined;

            if (!useKeys && isSeq(collection) && sliceSize >= 0) {
              sliceSeq.get = function (index, notSetValue) {
                index = wrapIndex(this, index);
                return index >= 0 && index < sliceSize
                  ? collection.get(index + resolvedBegin, notSetValue)
                  : notSetValue;
              };
            }

            sliceSeq.__iterateUncached = function (fn, reverse) {
              var this$1 = this;

              if (sliceSize === 0) {
                return 0;
              }
              if (reverse) {
                return this.cacheResult().__iterate(fn, reverse);
              }
              var skipped = 0;
              var isSkipping = true;
              var iterations = 0;
              collection.__iterate(function (v, k) {
                if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {
                  iterations++;
                  return (
                    fn(v, useKeys ? k : iterations - 1, this$1) !== false &&
                    iterations !== sliceSize
                  );
                }
              });
              return iterations;
            };

            sliceSeq.__iteratorUncached = function (type, reverse) {
              if (sliceSize !== 0 && reverse) {
                return this.cacheResult().__iterator(type, reverse);
              }
              // Don't bother instantiating parent iterator if taking 0.
              if (sliceSize === 0) {
                return new Iterator(iteratorDone);
              }
              var iterator = collection.__iterator(type, reverse);
              var skipped = 0;
              var iterations = 0;
              return new Iterator(function () {
                while (skipped++ < resolvedBegin) {
                  iterator.next();
                }
                if (++iterations > sliceSize) {
                  return iteratorDone();
                }
                var step = iterator.next();
                if (useKeys || type === ITERATE_VALUES || step.done) {
                  return step;
                }
                if (type === ITERATE_KEYS) {
                  return iteratorValue(type, iterations - 1, undefined, step);
                }
                return iteratorValue(type, iterations - 1, step.value[1], step);
              });
            };

            return sliceSeq;
          }

          function takeWhileFactory(collection, predicate, context) {
            var takeSequence = makeSequence(collection);
            takeSequence.__iterateUncached = function (fn, reverse) {
              var this$1 = this;

              if (reverse) {
                return this.cacheResult().__iterate(fn, reverse);
              }
              var iterations = 0;
              collection.__iterate(function (v, k, c) {
                return (
                  predicate.call(context, v, k, c) &&
                  ++iterations &&
                  fn(v, k, this$1)
                );
              });
              return iterations;
            };
            takeSequence.__iteratorUncached = function (type, reverse) {
              var this$1 = this;

              if (reverse) {
                return this.cacheResult().__iterator(type, reverse);
              }
              var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);
              var iterating = true;
              return new Iterator(function () {
                if (!iterating) {
                  return iteratorDone();
                }
                var step = iterator.next();
                if (step.done) {
                  return step;
                }
                var entry = step.value;
                var k = entry[0];
                var v = entry[1];
                if (!predicate.call(context, v, k, this$1)) {
                  iterating = false;
                  return iteratorDone();
                }
                return type === ITERATE_ENTRIES
                  ? step
                  : iteratorValue(type, k, v, step);
              });
            };
            return takeSequence;
          }

          function skipWhileFactory(collection, predicate, context, useKeys) {
            var skipSequence = makeSequence(collection);
            skipSequence.__iterateUncached = function (fn, reverse) {
              var this$1 = this;

              if (reverse) {
                return this.cacheResult().__iterate(fn, reverse);
              }
              var isSkipping = true;
              var iterations = 0;
              collection.__iterate(function (v, k, c) {
                if (
                  !(
                    isSkipping &&
                    (isSkipping = predicate.call(context, v, k, c))
                  )
                ) {
                  iterations++;
                  return fn(v, useKeys ? k : iterations - 1, this$1);
                }
              });
              return iterations;
            };
            skipSequence.__iteratorUncached = function (type, reverse) {
              var this$1 = this;

              if (reverse) {
                return this.cacheResult().__iterator(type, reverse);
              }
              var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);
              var skipping = true;
              var iterations = 0;
              return new Iterator(function () {
                var step;
                var k;
                var v;
                do {
                  step = iterator.next();
                  if (step.done) {
                    if (useKeys || type === ITERATE_VALUES) {
                      return step;
                    }
                    if (type === ITERATE_KEYS) {
                      return iteratorValue(type, iterations++, undefined, step);
                    }
                    return iteratorValue(
                      type,
                      iterations++,
                      step.value[1],
                      step
                    );
                  }
                  var entry = step.value;
                  k = entry[0];
                  v = entry[1];
                  skipping &&
                    (skipping = predicate.call(context, v, k, this$1));
                } while (skipping);
                return type === ITERATE_ENTRIES
                  ? step
                  : iteratorValue(type, k, v, step);
              });
            };
            return skipSequence;
          }

          function concatFactory(collection, values) {
            var isKeyedCollection = isKeyed(collection);
            var iters = [collection]
              .concat(values)
              .map(function (v) {
                if (!isCollection(v)) {
                  v = isKeyedCollection
                    ? keyedSeqFromValue(v)
                    : indexedSeqFromValue(Array.isArray(v) ? v : [v]);
                } else if (isKeyedCollection) {
                  v = KeyedCollection(v);
                }
                return v;
              })
              .filter(function (v) {
                return v.size !== 0;
              });

            if (iters.length === 0) {
              return collection;
            }

            if (iters.length === 1) {
              var singleton = iters[0];
              if (
                singleton === collection ||
                (isKeyedCollection && isKeyed(singleton)) ||
                (isIndexed(collection) && isIndexed(singleton))
              ) {
                return singleton;
              }
            }

            var concatSeq = new ArraySeq(iters);
            if (isKeyedCollection) {
              concatSeq = concatSeq.toKeyedSeq();
            } else if (!isIndexed(collection)) {
              concatSeq = concatSeq.toSetSeq();
            }
            concatSeq = concatSeq.flatten(true);
            concatSeq.size = iters.reduce(function (sum, seq) {
              if (sum !== undefined) {
                var size = seq.size;
                if (size !== undefined) {
                  return sum + size;
                }
              }
            }, 0);
            return concatSeq;
          }

          function flattenFactory(collection, depth, useKeys) {
            var flatSequence = makeSequence(collection);
            flatSequence.__iterateUncached = function (fn, reverse) {
              if (reverse) {
                return this.cacheResult().__iterate(fn, reverse);
              }
              var iterations = 0;
              var stopped = false;
              function flatDeep(iter, currentDepth) {
                iter.__iterate(function (v, k) {
                  if ((!depth || currentDepth < depth) && isCollection(v)) {
                    flatDeep(v, currentDepth + 1);
                  } else {
                    iterations++;
                    if (
                      fn(v, useKeys ? k : iterations - 1, flatSequence) ===
                      false
                    ) {
                      stopped = true;
                    }
                  }
                  return !stopped;
                }, reverse);
              }
              flatDeep(collection, 0);
              return iterations;
            };
            flatSequence.__iteratorUncached = function (type, reverse) {
              if (reverse) {
                return this.cacheResult().__iterator(type, reverse);
              }
              var iterator = collection.__iterator(type, reverse);
              var stack = [];
              var iterations = 0;
              return new Iterator(function () {
                while (iterator) {
                  var step = iterator.next();
                  if (step.done !== false) {
                    iterator = stack.pop();
                    continue;
                  }
                  var v = step.value;
                  if (type === ITERATE_ENTRIES) {
                    v = v[1];
                  }
                  if ((!depth || stack.length < depth) && isCollection(v)) {
                    stack.push(iterator);
                    iterator = v.__iterator(type, reverse);
                  } else {
                    return useKeys
                      ? step
                      : iteratorValue(type, iterations++, v, step);
                  }
                }
                return iteratorDone();
              });
            };
            return flatSequence;
          }

          function flatMapFactory(collection, mapper, context) {
            var coerce = collectionClass(collection);
            return collection
              .toSeq()
              .map(function (v, k) {
                return coerce(mapper.call(context, v, k, collection));
              })
              .flatten(true);
          }

          function interposeFactory(collection, separator) {
            var interposedSequence = makeSequence(collection);
            interposedSequence.size =
              collection.size && collection.size * 2 - 1;
            interposedSequence.__iterateUncached = function (fn, reverse) {
              var this$1 = this;

              var iterations = 0;
              collection.__iterate(function (v) {
                return (
                  (!iterations ||
                    fn(separator, iterations++, this$1) !== false) &&
                  fn(v, iterations++, this$1) !== false
                );
              }, reverse);
              return iterations;
            };
            interposedSequence.__iteratorUncached = function (type, reverse) {
              var iterator = collection.__iterator(ITERATE_VALUES, reverse);
              var iterations = 0;
              var step;
              return new Iterator(function () {
                if (!step || iterations % 2) {
                  step = iterator.next();
                  if (step.done) {
                    return step;
                  }
                }
                return iterations % 2
                  ? iteratorValue(type, iterations++, separator)
                  : iteratorValue(type, iterations++, step.value, step);
              });
            };
            return interposedSequence;
          }

          function sortFactory(collection, comparator, mapper) {
            if (!comparator) {
              comparator = defaultComparator;
            }
            var isKeyedCollection = isKeyed(collection);
            var index = 0;
            var entries = collection
              .toSeq()
              .map(function (v, k) {
                return [k, v, index++, mapper ? mapper(v, k, collection) : v];
              })
              .valueSeq()
              .toArray();
            entries
              .sort(function (a, b) {
                return comparator(a[3], b[3]) || a[2] - b[2];
              })
              .forEach(
                isKeyedCollection
                  ? function (v, i) {
                      entries[i].length = 2;
                    }
                  : function (v, i) {
                      entries[i] = v[1];
                    }
              );
            return isKeyedCollection
              ? KeyedSeq(entries)
              : isIndexed(collection)
              ? IndexedSeq(entries)
              : SetSeq(entries);
          }

          function maxFactory(collection, comparator, mapper) {
            if (!comparator) {
              comparator = defaultComparator;
            }
            if (mapper) {
              var entry = collection
                .toSeq()
                .map(function (v, k) {
                  return [v, mapper(v, k, collection)];
                })
                .reduce(function (a, b) {
                  return maxCompare(comparator, a[1], b[1]) ? b : a;
                });
              return entry && entry[0];
            }
            return collection.reduce(function (a, b) {
              return maxCompare(comparator, a, b) ? b : a;
            });
          }

          function maxCompare(comparator, a, b) {
            var comp = comparator(b, a);
            // b is considered the new max if the comparator declares them equal, but
            // they are not equal and b is in fact a nullish value.
            return (
              (comp === 0 &&
                b !== a &&
                (b === undefined || b === null || b !== b)) ||
              comp > 0
            );
          }

          function zipWithFactory(keyIter, zipper, iters, zipAll) {
            var zipSequence = makeSequence(keyIter);
            var sizes = new ArraySeq(iters).map(function (i) {
              return i.size;
            });
            zipSequence.size = zipAll ? sizes.max() : sizes.min();
            // Note: this a generic base implementation of __iterate in terms of
            // __iterator which may be more generically useful in the future.
            zipSequence.__iterate = function (fn, reverse) {
              /* generic:
      var iterator = this.__iterator(ITERATE_ENTRIES, reverse);
      var step;
      var iterations = 0;
      while (!(step = iterator.next()).done) {
        iterations++;
        if (fn(step.value[1], step.value[0], this) === false) {
          break;
        }
      }
      return iterations;
      */
              // indexed:
              var iterator = this.__iterator(ITERATE_VALUES, reverse);
              var step;
              var iterations = 0;
              while (!(step = iterator.next()).done) {
                if (fn(step.value, iterations++, this) === false) {
                  break;
                }
              }
              return iterations;
            };
            zipSequence.__iteratorUncached = function (type, reverse) {
              var iterators = iters.map(function (i) {
                return (
                  (i = Collection(i)), getIterator(reverse ? i.reverse() : i)
                );
              });
              var iterations = 0;
              var isDone = false;
              return new Iterator(function () {
                var steps;
                if (!isDone) {
                  steps = iterators.map(function (i) {
                    return i.next();
                  });
                  isDone = zipAll
                    ? steps.every(function (s) {
                        return s.done;
                      })
                    : steps.some(function (s) {
                        return s.done;
                      });
                }
                if (isDone) {
                  return iteratorDone();
                }
                return iteratorValue(
                  type,
                  iterations++,
                  zipper.apply(
                    null,
                    steps.map(function (s) {
                      return s.value;
                    })
                  )
                );
              });
            };
            return zipSequence;
          }

          // #pragma Helper Functions

          function reify(iter, seq) {
            return iter === seq
              ? iter
              : isSeq(iter)
              ? seq
              : iter.constructor(seq);
          }

          function validateEntry(entry) {
            if (entry !== Object(entry)) {
              throw new TypeError("Expected [K, V] tuple: " + entry);
            }
          }

          function collectionClass(collection) {
            return isKeyed(collection)
              ? KeyedCollection
              : isIndexed(collection)
              ? IndexedCollection
              : SetCollection;
          }

          function makeSequence(collection) {
            return Object.create(
              (isKeyed(collection)
                ? KeyedSeq
                : isIndexed(collection)
                ? IndexedSeq
                : SetSeq
              ).prototype
            );
          }

          function cacheResultThrough() {
            if (this._iter.cacheResult) {
              this._iter.cacheResult();
              this.size = this._iter.size;
              return this;
            }
            return Seq.prototype.cacheResult.call(this);
          }

          function defaultComparator(a, b) {
            if (a === undefined && b === undefined) {
              return 0;
            }

            if (a === undefined) {
              return 1;
            }

            if (b === undefined) {
              return -1;
            }

            return a > b ? 1 : a < b ? -1 : 0;
          }

          // http://jsperf.com/copy-array-inline
          function arrCopy(arr, offset) {
            offset = offset || 0;
            var len = Math.max(0, arr.length - offset);
            var newArr = new Array(len);
            for (var ii = 0; ii < len; ii++) {
              newArr[ii] = arr[ii + offset];
            }
            return newArr;
          }

          function invariant(condition, error) {
            if (!condition) {
              throw new Error(error);
            }
          }

          function assertNotInfinite(size) {
            invariant(
              size !== Infinity,
              "Cannot perform this action with an infinite size."
            );
          }

          function coerceKeyPath(keyPath) {
            if (isArrayLike(keyPath) && typeof keyPath !== "string") {
              return keyPath;
            }
            if (isOrdered(keyPath)) {
              return keyPath.toArray();
            }
            throw new TypeError(
              "Invalid keyPath: expected Ordered Collection or Array: " +
                keyPath
            );
          }

          function isPlainObj(value) {
            return (
              value &&
              (typeof value.constructor !== "function" ||
                value.constructor.name === "Object")
            );
          }

          /**
           * Returns true if the value is a potentially-persistent data structure, either
           * provided by Immutable.js or a plain Array or Object.
           */
          function isDataStructure(value) {
            return (
              typeof value === "object" &&
              (isImmutable(value) || Array.isArray(value) || isPlainObj(value))
            );
          }

          /**
           * Converts a value to a string, adding quotes if a string was provided.
           */
          function quoteString(value) {
            try {
              return typeof value === "string"
                ? JSON.stringify(value)
                : String(value);
            } catch (_ignoreError) {
              return JSON.stringify(value);
            }
          }

          function has(collection, key) {
            return isImmutable(collection)
              ? collection.has(key)
              : isDataStructure(collection) &&
                  hasOwnProperty.call(collection, key);
          }

          function get(collection, key, notSetValue) {
            return isImmutable(collection)
              ? collection.get(key, notSetValue)
              : !has(collection, key)
              ? notSetValue
              : typeof collection.get === "function"
              ? collection.get(key)
              : collection[key];
          }

          function shallowCopy(from) {
            if (Array.isArray(from)) {
              return arrCopy(from);
            }
            var to = {};
            for (var key in from) {
              if (hasOwnProperty.call(from, key)) {
                to[key] = from[key];
              }
            }
            return to;
          }

          function remove(collection, key) {
            if (!isDataStructure(collection)) {
              throw new TypeError(
                "Cannot update non-data-structure value: " + collection
              );
            }
            if (isImmutable(collection)) {
              if (!collection.remove) {
                throw new TypeError(
                  "Cannot update immutable value without .remove() method: " +
                    collection
                );
              }
              return collection.remove(key);
            }
            if (!hasOwnProperty.call(collection, key)) {
              return collection;
            }
            var collectionCopy = shallowCopy(collection);
            if (Array.isArray(collectionCopy)) {
              collectionCopy.splice(key, 1);
            } else {
              delete collectionCopy[key];
            }
            return collectionCopy;
          }

          function set(collection, key, value) {
            if (!isDataStructure(collection)) {
              throw new TypeError(
                "Cannot update non-data-structure value: " + collection
              );
            }
            if (isImmutable(collection)) {
              if (!collection.set) {
                throw new TypeError(
                  "Cannot update immutable value without .set() method: " +
                    collection
                );
              }
              return collection.set(key, value);
            }
            if (
              hasOwnProperty.call(collection, key) &&
              value === collection[key]
            ) {
              return collection;
            }
            var collectionCopy = shallowCopy(collection);
            collectionCopy[key] = value;
            return collectionCopy;
          }

          function updateIn(collection, keyPath, notSetValue, updater) {
            if (!updater) {
              updater = notSetValue;
              notSetValue = undefined;
            }
            var updatedValue = updateInDeeply(
              isImmutable(collection),
              collection,
              coerceKeyPath(keyPath),
              0,
              notSetValue,
              updater
            );
            return updatedValue === NOT_SET ? notSetValue : updatedValue;
          }

          function updateInDeeply(
            inImmutable,
            existing,
            keyPath,
            i,
            notSetValue,
            updater
          ) {
            var wasNotSet = existing === NOT_SET;
            if (i === keyPath.length) {
              var existingValue = wasNotSet ? notSetValue : existing;
              var newValue = updater(existingValue);
              return newValue === existingValue ? existing : newValue;
            }
            if (!wasNotSet && !isDataStructure(existing)) {
              throw new TypeError(
                "Cannot update within non-data-structure value in path [" +
                  keyPath.slice(0, i).map(quoteString) +
                  "]: " +
                  existing
              );
            }
            var key = keyPath[i];
            var nextExisting = wasNotSet
              ? NOT_SET
              : get(existing, key, NOT_SET);
            var nextUpdated = updateInDeeply(
              nextExisting === NOT_SET
                ? inImmutable
                : isImmutable(nextExisting),
              nextExisting,
              keyPath,
              i + 1,
              notSetValue,
              updater
            );
            return nextUpdated === nextExisting
              ? existing
              : nextUpdated === NOT_SET
              ? remove(existing, key)
              : set(
                  wasNotSet ? (inImmutable ? emptyMap() : {}) : existing,
                  key,
                  nextUpdated
                );
          }

          function setIn(collection, keyPath, value) {
            return updateIn(collection, keyPath, NOT_SET, function () {
              return value;
            });
          }

          function setIn$1(keyPath, v) {
            return setIn(this, keyPath, v);
          }

          function removeIn(collection, keyPath) {
            return updateIn(collection, keyPath, function () {
              return NOT_SET;
            });
          }

          function deleteIn(keyPath) {
            return removeIn(this, keyPath);
          }

          function update(collection, key, notSetValue, updater) {
            return updateIn(collection, [key], notSetValue, updater);
          }

          function update$1(key, notSetValue, updater) {
            return arguments.length === 1
              ? key(this)
              : update(this, key, notSetValue, updater);
          }

          function updateIn$1(keyPath, notSetValue, updater) {
            return updateIn(this, keyPath, notSetValue, updater);
          }

          function merge() {
            var iters = [],
              len = arguments.length;
            while (len--) iters[len] = arguments[len];

            return mergeIntoKeyedWith(this, iters);
          }

          function mergeWith(merger) {
            var iters = [],
              len = arguments.length - 1;
            while (len-- > 0) iters[len] = arguments[len + 1];

            if (typeof merger !== "function") {
              throw new TypeError("Invalid merger function: " + merger);
            }
            return mergeIntoKeyedWith(this, iters, merger);
          }

          function mergeIntoKeyedWith(collection, collections, merger) {
            var iters = [];
            for (var ii = 0; ii < collections.length; ii++) {
              var collection$1 = KeyedCollection(collections[ii]);
              if (collection$1.size !== 0) {
                iters.push(collection$1);
              }
            }
            if (iters.length === 0) {
              return collection;
            }
            if (
              collection.toSeq().size === 0 &&
              !collection.__ownerID &&
              iters.length === 1
            ) {
              return collection.constructor(iters[0]);
            }
            return collection.withMutations(function (collection) {
              var mergeIntoCollection = merger
                ? function (value, key) {
                    update(collection, key, NOT_SET, function (oldVal) {
                      return oldVal === NOT_SET
                        ? value
                        : merger(oldVal, value, key);
                    });
                  }
                : function (value, key) {
                    collection.set(key, value);
                  };
              for (var ii = 0; ii < iters.length; ii++) {
                iters[ii].forEach(mergeIntoCollection);
              }
            });
          }

          function merge$1(collection) {
            var sources = [],
              len = arguments.length - 1;
            while (len-- > 0) sources[len] = arguments[len + 1];

            return mergeWithSources(collection, sources);
          }

          function mergeWith$1(merger, collection) {
            var sources = [],
              len = arguments.length - 2;
            while (len-- > 0) sources[len] = arguments[len + 2];

            return mergeWithSources(collection, sources, merger);
          }

          function mergeDeep(collection) {
            var sources = [],
              len = arguments.length - 1;
            while (len-- > 0) sources[len] = arguments[len + 1];

            return mergeDeepWithSources(collection, sources);
          }

          function mergeDeepWith(merger, collection) {
            var sources = [],
              len = arguments.length - 2;
            while (len-- > 0) sources[len] = arguments[len + 2];

            return mergeDeepWithSources(collection, sources, merger);
          }

          function mergeDeepWithSources(collection, sources, merger) {
            return mergeWithSources(
              collection,
              sources,
              deepMergerWith(merger)
            );
          }

          function mergeWithSources(collection, sources, merger) {
            if (!isDataStructure(collection)) {
              throw new TypeError(
                "Cannot merge into non-data-structure value: " + collection
              );
            }
            if (isImmutable(collection)) {
              return typeof merger === "function" && collection.mergeWith
                ? collection.mergeWith.apply(
                    collection,
                    [merger].concat(sources)
                  )
                : collection.merge
                ? collection.merge.apply(collection, sources)
                : collection.concat.apply(collection, sources);
            }
            var isArray = Array.isArray(collection);
            var merged = collection;
            var Collection$$1 = isArray ? IndexedCollection : KeyedCollection;
            var mergeItem = isArray
              ? function (value) {
                  // Copy on write
                  if (merged === collection) {
                    merged = shallowCopy(merged);
                  }
                  merged.push(value);
                }
              : function (value, key) {
                  var hasVal = hasOwnProperty.call(merged, key);
                  var nextVal =
                    hasVal && merger ? merger(merged[key], value, key) : value;
                  if (!hasVal || nextVal !== merged[key]) {
                    // Copy on write
                    if (merged === collection) {
                      merged = shallowCopy(merged);
                    }
                    merged[key] = nextVal;
                  }
                };
            for (var i = 0; i < sources.length; i++) {
              Collection$$1(sources[i]).forEach(mergeItem);
            }
            return merged;
          }

          function deepMergerWith(merger) {
            function deepMerger(oldValue, newValue, key) {
              return isDataStructure(oldValue) && isDataStructure(newValue)
                ? mergeWithSources(oldValue, [newValue], deepMerger)
                : merger
                ? merger(oldValue, newValue, key)
                : newValue;
            }
            return deepMerger;
          }

          function mergeDeep$1() {
            var iters = [],
              len = arguments.length;
            while (len--) iters[len] = arguments[len];

            return mergeDeepWithSources(this, iters);
          }

          function mergeDeepWith$1(merger) {
            var iters = [],
              len = arguments.length - 1;
            while (len-- > 0) iters[len] = arguments[len + 1];

            return mergeDeepWithSources(this, iters, merger);
          }

          function mergeIn(keyPath) {
            var iters = [],
              len = arguments.length - 1;
            while (len-- > 0) iters[len] = arguments[len + 1];

            return updateIn(this, keyPath, emptyMap(), function (m) {
              return mergeWithSources(m, iters);
            });
          }

          function mergeDeepIn(keyPath) {
            var iters = [],
              len = arguments.length - 1;
            while (len-- > 0) iters[len] = arguments[len + 1];

            return updateIn(this, keyPath, emptyMap(), function (m) {
              return mergeDeepWithSources(m, iters);
            });
          }

          function withMutations(fn) {
            var mutable = this.asMutable();
            fn(mutable);
            return mutable.wasAltered()
              ? mutable.__ensureOwner(this.__ownerID)
              : this;
          }

          function asMutable() {
            return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
          }

          function asImmutable() {
            return this.__ensureOwner();
          }

          function wasAltered() {
            return this.__altered;
          }

          var Map = /*@__PURE__*/ (function (KeyedCollection$$1) {
            function Map(value) {
              return value === null || value === undefined
                ? emptyMap()
                : isMap(value) && !isOrdered(value)
                ? value
                : emptyMap().withMutations(function (map) {
                    var iter = KeyedCollection$$1(value);
                    assertNotInfinite(iter.size);
                    iter.forEach(function (v, k) {
                      return map.set(k, v);
                    });
                  });
            }

            if (KeyedCollection$$1) Map.__proto__ = KeyedCollection$$1;
            Map.prototype = Object.create(
              KeyedCollection$$1 && KeyedCollection$$1.prototype
            );
            Map.prototype.constructor = Map;

            Map.of = function of() {
              var keyValues = [],
                len = arguments.length;
              while (len--) keyValues[len] = arguments[len];

              return emptyMap().withMutations(function (map) {
                for (var i = 0; i < keyValues.length; i += 2) {
                  if (i + 1 >= keyValues.length) {
                    throw new Error("Missing value for key: " + keyValues[i]);
                  }
                  map.set(keyValues[i], keyValues[i + 1]);
                }
              });
            };

            Map.prototype.toString = function toString() {
              return this.__toString("Map {", "}");
            };

            // @pragma Access

            Map.prototype.get = function get(k, notSetValue) {
              return this._root
                ? this._root.get(0, undefined, k, notSetValue)
                : notSetValue;
            };

            // @pragma Modification

            Map.prototype.set = function set(k, v) {
              return updateMap(this, k, v);
            };

            Map.prototype.remove = function remove(k) {
              return updateMap(this, k, NOT_SET);
            };

            Map.prototype.deleteAll = function deleteAll(keys) {
              var collection = Collection(keys);

              if (collection.size === 0) {
                return this;
              }

              return this.withMutations(function (map) {
                collection.forEach(function (key) {
                  return map.remove(key);
                });
              });
            };

            Map.prototype.clear = function clear() {
              if (this.size === 0) {
                return this;
              }
              if (this.__ownerID) {
                this.size = 0;
                this._root = null;
                this.__hash = undefined;
                this.__altered = true;
                return this;
              }
              return emptyMap();
            };

            // @pragma Composition

            Map.prototype.sort = function sort(comparator) {
              // Late binding
              return OrderedMap(sortFactory(this, comparator));
            };

            Map.prototype.sortBy = function sortBy(mapper, comparator) {
              // Late binding
              return OrderedMap(sortFactory(this, comparator, mapper));
            };

            Map.prototype.map = function map(mapper, context) {
              return this.withMutations(function (map) {
                map.forEach(function (value, key) {
                  map.set(key, mapper.call(context, value, key, map));
                });
              });
            };

            // @pragma Mutability

            Map.prototype.__iterator = function __iterator(type, reverse) {
              return new MapIterator(this, type, reverse);
            };

            Map.prototype.__iterate = function __iterate(fn, reverse) {
              var this$1 = this;

              var iterations = 0;
              this._root &&
                this._root.iterate(function (entry) {
                  iterations++;
                  return fn(entry[1], entry[0], this$1);
                }, reverse);
              return iterations;
            };

            Map.prototype.__ensureOwner = function __ensureOwner(ownerID) {
              if (ownerID === this.__ownerID) {
                return this;
              }
              if (!ownerID) {
                if (this.size === 0) {
                  return emptyMap();
                }
                this.__ownerID = ownerID;
                this.__altered = false;
                return this;
              }
              return makeMap(this.size, this._root, ownerID, this.__hash);
            };

            return Map;
          })(KeyedCollection);

          Map.isMap = isMap;

          var MapPrototype = Map.prototype;
          MapPrototype[IS_MAP_SYMBOL] = true;
          MapPrototype[DELETE] = MapPrototype.remove;
          MapPrototype.removeAll = MapPrototype.deleteAll;
          MapPrototype.setIn = setIn$1;
          MapPrototype.removeIn = MapPrototype.deleteIn = deleteIn;
          MapPrototype.update = update$1;
          MapPrototype.updateIn = updateIn$1;
          MapPrototype.merge = MapPrototype.concat = merge;
          MapPrototype.mergeWith = mergeWith;
          MapPrototype.mergeDeep = mergeDeep$1;
          MapPrototype.mergeDeepWith = mergeDeepWith$1;
          MapPrototype.mergeIn = mergeIn;
          MapPrototype.mergeDeepIn = mergeDeepIn;
          MapPrototype.withMutations = withMutations;
          MapPrototype.wasAltered = wasAltered;
          MapPrototype.asImmutable = asImmutable;
          MapPrototype[
            "@@transducer/init"
          ] = MapPrototype.asMutable = asMutable;
          MapPrototype["@@transducer/step"] = function (result, arr) {
            return result.set(arr[0], arr[1]);
          };
          MapPrototype["@@transducer/result"] = function (obj) {
            return obj.asImmutable();
          };

          // #pragma Trie Nodes

          var ArrayMapNode = function ArrayMapNode(ownerID, entries) {
            this.ownerID = ownerID;
            this.entries = entries;
          };

          ArrayMapNode.prototype.get = function get(
            shift,
            keyHash,
            key,
            notSetValue
          ) {
            var entries = this.entries;
            for (var ii = 0, len = entries.length; ii < len; ii++) {
              if (is(key, entries[ii][0])) {
                return entries[ii][1];
              }
            }
            return notSetValue;
          };

          ArrayMapNode.prototype.update = function update(
            ownerID,
            shift,
            keyHash,
            key,
            value,
            didChangeSize,
            didAlter
          ) {
            var removed = value === NOT_SET;

            var entries = this.entries;
            var idx = 0;
            var len = entries.length;
            for (; idx < len; idx++) {
              if (is(key, entries[idx][0])) {
                break;
              }
            }
            var exists = idx < len;

            if (exists ? entries[idx][1] === value : removed) {
              return this;
            }

            SetRef(didAlter);
            (removed || !exists) && SetRef(didChangeSize);

            if (removed && entries.length === 1) {
              return; // undefined
            }

            if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {
              return createNodes(ownerID, entries, key, value);
            }

            var isEditable = ownerID && ownerID === this.ownerID;
            var newEntries = isEditable ? entries : arrCopy(entries);

            if (exists) {
              if (removed) {
                idx === len - 1
                  ? newEntries.pop()
                  : (newEntries[idx] = newEntries.pop());
              } else {
                newEntries[idx] = [key, value];
              }
            } else {
              newEntries.push([key, value]);
            }

            if (isEditable) {
              this.entries = newEntries;
              return this;
            }

            return new ArrayMapNode(ownerID, newEntries);
          };

          var BitmapIndexedNode = function BitmapIndexedNode(
            ownerID,
            bitmap,
            nodes
          ) {
            this.ownerID = ownerID;
            this.bitmap = bitmap;
            this.nodes = nodes;
          };

          BitmapIndexedNode.prototype.get = function get(
            shift,
            keyHash,
            key,
            notSetValue
          ) {
            if (keyHash === undefined) {
              keyHash = hash(key);
            }
            var bit = 1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK);
            var bitmap = this.bitmap;
            return (bitmap & bit) === 0
              ? notSetValue
              : this.nodes[popCount(bitmap & (bit - 1))].get(
                  shift + SHIFT,
                  keyHash,
                  key,
                  notSetValue
                );
          };

          BitmapIndexedNode.prototype.update = function update(
            ownerID,
            shift,
            keyHash,
            key,
            value,
            didChangeSize,
            didAlter
          ) {
            if (keyHash === undefined) {
              keyHash = hash(key);
            }
            var keyHashFrag =
              (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
            var bit = 1 << keyHashFrag;
            var bitmap = this.bitmap;
            var exists = (bitmap & bit) !== 0;

            if (!exists && value === NOT_SET) {
              return this;
            }

            var idx = popCount(bitmap & (bit - 1));
            var nodes = this.nodes;
            var node = exists ? nodes[idx] : undefined;
            var newNode = updateNode(
              node,
              ownerID,
              shift + SHIFT,
              keyHash,
              key,
              value,
              didChangeSize,
              didAlter
            );

            if (newNode === node) {
              return this;
            }

            if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {
              return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);
            }

            if (
              exists &&
              !newNode &&
              nodes.length === 2 &&
              isLeafNode(nodes[idx ^ 1])
            ) {
              return nodes[idx ^ 1];
            }

            if (
              exists &&
              newNode &&
              nodes.length === 1 &&
              isLeafNode(newNode)
            ) {
              return newNode;
            }

            var isEditable = ownerID && ownerID === this.ownerID;
            var newBitmap = exists
              ? newNode
                ? bitmap
                : bitmap ^ bit
              : bitmap | bit;
            var newNodes = exists
              ? newNode
                ? setAt(nodes, idx, newNode, isEditable)
                : spliceOut(nodes, idx, isEditable)
              : spliceIn(nodes, idx, newNode, isEditable);

            if (isEditable) {
              this.bitmap = newBitmap;
              this.nodes = newNodes;
              return this;
            }

            return new BitmapIndexedNode(ownerID, newBitmap, newNodes);
          };

          var HashArrayMapNode = function HashArrayMapNode(
            ownerID,
            count,
            nodes
          ) {
            this.ownerID = ownerID;
            this.count = count;
            this.nodes = nodes;
          };

          HashArrayMapNode.prototype.get = function get(
            shift,
            keyHash,
            key,
            notSetValue
          ) {
            if (keyHash === undefined) {
              keyHash = hash(key);
            }
            var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
            var node = this.nodes[idx];
            return node
              ? node.get(shift + SHIFT, keyHash, key, notSetValue)
              : notSetValue;
          };

          HashArrayMapNode.prototype.update = function update(
            ownerID,
            shift,
            keyHash,
            key,
            value,
            didChangeSize,
            didAlter
          ) {
            if (keyHash === undefined) {
              keyHash = hash(key);
            }
            var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
            var removed = value === NOT_SET;
            var nodes = this.nodes;
            var node = nodes[idx];

            if (removed && !node) {
              return this;
            }

            var newNode = updateNode(
              node,
              ownerID,
              shift + SHIFT,
              keyHash,
              key,
              value,
              didChangeSize,
              didAlter
            );
            if (newNode === node) {
              return this;
            }

            var newCount = this.count;
            if (!node) {
              newCount++;
            } else if (!newNode) {
              newCount--;
              if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {
                return packNodes(ownerID, nodes, newCount, idx);
              }
            }

            var isEditable = ownerID && ownerID === this.ownerID;
            var newNodes = setAt(nodes, idx, newNode, isEditable);

            if (isEditable) {
              this.count = newCount;
              this.nodes = newNodes;
              return this;
            }

            return new HashArrayMapNode(ownerID, newCount, newNodes);
          };

          var HashCollisionNode = function HashCollisionNode(
            ownerID,
            keyHash,
            entries
          ) {
            this.ownerID = ownerID;
            this.keyHash = keyHash;
            this.entries = entries;
          };

          HashCollisionNode.prototype.get = function get(
            shift,
            keyHash,
            key,
            notSetValue
          ) {
            var entries = this.entries;
            for (var ii = 0, len = entries.length; ii < len; ii++) {
              if (is(key, entries[ii][0])) {
                return entries[ii][1];
              }
            }
            return notSetValue;
          };

          HashCollisionNode.prototype.update = function update(
            ownerID,
            shift,
            keyHash,
            key,
            value,
            didChangeSize,
            didAlter
          ) {
            if (keyHash === undefined) {
              keyHash = hash(key);
            }

            var removed = value === NOT_SET;

            if (keyHash !== this.keyHash) {
              if (removed) {
                return this;
              }
              SetRef(didAlter);
              SetRef(didChangeSize);
              return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);
            }

            var entries = this.entries;
            var idx = 0;
            var len = entries.length;
            for (; idx < len; idx++) {
              if (is(key, entries[idx][0])) {
                break;
              }
            }
            var exists = idx < len;

            if (exists ? entries[idx][1] === value : removed) {
              return this;
            }

            SetRef(didAlter);
            (removed || !exists) && SetRef(didChangeSize);

            if (removed && len === 2) {
              return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);
            }

            var isEditable = ownerID && ownerID === this.ownerID;
            var newEntries = isEditable ? entries : arrCopy(entries);

            if (exists) {
              if (removed) {
                idx === len - 1
                  ? newEntries.pop()
                  : (newEntries[idx] = newEntries.pop());
              } else {
                newEntries[idx] = [key, value];
              }
            } else {
              newEntries.push([key, value]);
            }

            if (isEditable) {
              this.entries = newEntries;
              return this;
            }

            return new HashCollisionNode(ownerID, this.keyHash, newEntries);
          };

          var ValueNode = function ValueNode(ownerID, keyHash, entry) {
            this.ownerID = ownerID;
            this.keyHash = keyHash;
            this.entry = entry;
          };

          ValueNode.prototype.get = function get(
            shift,
            keyHash,
            key,
            notSetValue
          ) {
            return is(key, this.entry[0]) ? this.entry[1] : notSetValue;
          };

          ValueNode.prototype.update = function update(
            ownerID,
            shift,
            keyHash,
            key,
            value,
            didChangeSize,
            didAlter
          ) {
            var removed = value === NOT_SET;
            var keyMatch = is(key, this.entry[0]);
            if (keyMatch ? value === this.entry[1] : removed) {
              return this;
            }

            SetRef(didAlter);

            if (removed) {
              SetRef(didChangeSize);
              return; // undefined
            }

            if (keyMatch) {
              if (ownerID && ownerID === this.ownerID) {
                this.entry[1] = value;
                return this;
              }
              return new ValueNode(ownerID, this.keyHash, [key, value]);
            }

            SetRef(didChangeSize);
            return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);
          };

          // #pragma Iterators

          ArrayMapNode.prototype.iterate = HashCollisionNode.prototype.iterate = function (
            fn,
            reverse
          ) {
            var entries = this.entries;
            for (
              var ii = 0, maxIndex = entries.length - 1;
              ii <= maxIndex;
              ii++
            ) {
              if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {
                return false;
              }
            }
          };

          BitmapIndexedNode.prototype.iterate = HashArrayMapNode.prototype.iterate = function (
            fn,
            reverse
          ) {
            var nodes = this.nodes;
            for (
              var ii = 0, maxIndex = nodes.length - 1;
              ii <= maxIndex;
              ii++
            ) {
              var node = nodes[reverse ? maxIndex - ii : ii];
              if (node && node.iterate(fn, reverse) === false) {
                return false;
              }
            }
          };

          // eslint-disable-next-line no-unused-vars
          ValueNode.prototype.iterate = function (fn, reverse) {
            return fn(this.entry);
          };

          var MapIterator = /*@__PURE__*/ (function (Iterator$$1) {
            function MapIterator(map, type, reverse) {
              this._type = type;
              this._reverse = reverse;
              this._stack = map._root && mapIteratorFrame(map._root);
            }

            if (Iterator$$1) MapIterator.__proto__ = Iterator$$1;
            MapIterator.prototype = Object.create(
              Iterator$$1 && Iterator$$1.prototype
            );
            MapIterator.prototype.constructor = MapIterator;

            MapIterator.prototype.next = function next() {
              var type = this._type;
              var stack = this._stack;
              while (stack) {
                var node = stack.node;
                var index = stack.index++;
                var maxIndex = void 0;
                if (node.entry) {
                  if (index === 0) {
                    return mapIteratorValue(type, node.entry);
                  }
                } else if (node.entries) {
                  maxIndex = node.entries.length - 1;
                  if (index <= maxIndex) {
                    return mapIteratorValue(
                      type,
                      node.entries[this._reverse ? maxIndex - index : index]
                    );
                  }
                } else {
                  maxIndex = node.nodes.length - 1;
                  if (index <= maxIndex) {
                    var subNode =
                      node.nodes[this._reverse ? maxIndex - index : index];
                    if (subNode) {
                      if (subNode.entry) {
                        return mapIteratorValue(type, subNode.entry);
                      }
                      stack = this._stack = mapIteratorFrame(subNode, stack);
                    }
                    continue;
                  }
                }
                stack = this._stack = this._stack.__prev;
              }
              return iteratorDone();
            };

            return MapIterator;
          })(Iterator);

          function mapIteratorValue(type, entry) {
            return iteratorValue(type, entry[0], entry[1]);
          }

          function mapIteratorFrame(node, prev) {
            return {
              node: node,
              index: 0,
              __prev: prev,
            };
          }

          function makeMap(size, root, ownerID, hash$$1) {
            var map = Object.create(MapPrototype);
            map.size = size;
            map._root = root;
            map.__ownerID = ownerID;
            map.__hash = hash$$1;
            map.__altered = false;
            return map;
          }

          var EMPTY_MAP;
          function emptyMap() {
            return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
          }

          function updateMap(map, k, v) {
            var newRoot;
            var newSize;
            if (!map._root) {
              if (v === NOT_SET) {
                return map;
              }
              newSize = 1;
              newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);
            } else {
              var didChangeSize = MakeRef();
              var didAlter = MakeRef();
              newRoot = updateNode(
                map._root,
                map.__ownerID,
                0,
                undefined,
                k,
                v,
                didChangeSize,
                didAlter
              );
              if (!didAlter.value) {
                return map;
              }
              newSize =
                map.size + (didChangeSize.value ? (v === NOT_SET ? -1 : 1) : 0);
            }
            if (map.__ownerID) {
              map.size = newSize;
              map._root = newRoot;
              map.__hash = undefined;
              map.__altered = true;
              return map;
            }
            return newRoot ? makeMap(newSize, newRoot) : emptyMap();
          }

          function updateNode(
            node,
            ownerID,
            shift,
            keyHash,
            key,
            value,
            didChangeSize,
            didAlter
          ) {
            if (!node) {
              if (value === NOT_SET) {
                return node;
              }
              SetRef(didAlter);
              SetRef(didChangeSize);
              return new ValueNode(ownerID, keyHash, [key, value]);
            }
            return node.update(
              ownerID,
              shift,
              keyHash,
              key,
              value,
              didChangeSize,
              didAlter
            );
          }

          function isLeafNode(node) {
            return (
              node.constructor === ValueNode ||
              node.constructor === HashCollisionNode
            );
          }

          function mergeIntoNode(node, ownerID, shift, keyHash, entry) {
            if (node.keyHash === keyHash) {
              return new HashCollisionNode(ownerID, keyHash, [
                node.entry,
                entry,
              ]);
            }

            var idx1 =
              (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;
            var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;

            var newNode;
            var nodes =
              idx1 === idx2
                ? [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)]
                : ((newNode = new ValueNode(ownerID, keyHash, entry)),
                  idx1 < idx2 ? [node, newNode] : [newNode, node]);

            return new BitmapIndexedNode(
              ownerID,
              (1 << idx1) | (1 << idx2),
              nodes
            );
          }

          function createNodes(ownerID, entries, key, value) {
            if (!ownerID) {
              ownerID = new OwnerID();
            }
            var node = new ValueNode(ownerID, hash(key), [key, value]);
            for (var ii = 0; ii < entries.length; ii++) {
              var entry = entries[ii];
              node = node.update(ownerID, 0, undefined, entry[0], entry[1]);
            }
            return node;
          }

          function packNodes(ownerID, nodes, count, excluding) {
            var bitmap = 0;
            var packedII = 0;
            var packedNodes = new Array(count);
            for (
              var ii = 0, bit = 1, len = nodes.length;
              ii < len;
              ii++, bit <<= 1
            ) {
              var node = nodes[ii];
              if (node !== undefined && ii !== excluding) {
                bitmap |= bit;
                packedNodes[packedII++] = node;
              }
            }
            return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
          }

          function expandNodes(ownerID, nodes, bitmap, including, node) {
            var count = 0;
            var expandedNodes = new Array(SIZE);
            for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
              expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;
            }
            expandedNodes[including] = node;
            return new HashArrayMapNode(ownerID, count + 1, expandedNodes);
          }

          function popCount(x) {
            x -= (x >> 1) & 0x55555555;
            x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
            x = (x + (x >> 4)) & 0x0f0f0f0f;
            x += x >> 8;
            x += x >> 16;
            return x & 0x7f;
          }

          function setAt(array, idx, val, canEdit) {
            var newArray = canEdit ? array : arrCopy(array);
            newArray[idx] = val;
            return newArray;
          }

          function spliceIn(array, idx, val, canEdit) {
            var newLen = array.length + 1;
            if (canEdit && idx + 1 === newLen) {
              array[idx] = val;
              return array;
            }
            var newArray = new Array(newLen);
            var after = 0;
            for (var ii = 0; ii < newLen; ii++) {
              if (ii === idx) {
                newArray[ii] = val;
                after = -1;
              } else {
                newArray[ii] = array[ii + after];
              }
            }
            return newArray;
          }

          function spliceOut(array, idx, canEdit) {
            var newLen = array.length - 1;
            if (canEdit && idx === newLen) {
              array.pop();
              return array;
            }
            var newArray = new Array(newLen);
            var after = 0;
            for (var ii = 0; ii < newLen; ii++) {
              if (ii === idx) {
                after = 1;
              }
              newArray[ii] = array[ii + after];
            }
            return newArray;
          }

          var MAX_ARRAY_MAP_SIZE = SIZE / 4;
          var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;
          var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;

          var IS_LIST_SYMBOL = "@@__IMMUTABLE_LIST__@@";

          function isList(maybeList) {
            return Boolean(maybeList && maybeList[IS_LIST_SYMBOL]);
          }

          var List = /*@__PURE__*/ (function (IndexedCollection$$1) {
            function List(value) {
              var empty = emptyList();
              if (value === null || value === undefined) {
                return empty;
              }
              if (isList(value)) {
                return value;
              }
              var iter = IndexedCollection$$1(value);
              var size = iter.size;
              if (size === 0) {
                return empty;
              }
              assertNotInfinite(size);
              if (size > 0 && size < SIZE) {
                return makeList(
                  0,
                  size,
                  SHIFT,
                  null,
                  new VNode(iter.toArray())
                );
              }
              return empty.withMutations(function (list) {
                list.setSize(size);
                iter.forEach(function (v, i) {
                  return list.set(i, v);
                });
              });
            }

            if (IndexedCollection$$1) List.__proto__ = IndexedCollection$$1;
            List.prototype = Object.create(
              IndexedCollection$$1 && IndexedCollection$$1.prototype
            );
            List.prototype.constructor = List;

            List.of = function of(/*...values*/) {
              return this(arguments);
            };

            List.prototype.toString = function toString() {
              return this.__toString("List [", "]");
            };

            // @pragma Access

            List.prototype.get = function get(index, notSetValue) {
              index = wrapIndex(this, index);
              if (index >= 0 && index < this.size) {
                index += this._origin;
                var node = listNodeFor(this, index);
                return node && node.array[index & MASK];
              }
              return notSetValue;
            };

            // @pragma Modification

            List.prototype.set = function set(index, value) {
              return updateList(this, index, value);
            };

            List.prototype.remove = function remove(index) {
              return !this.has(index)
                ? this
                : index === 0
                ? this.shift()
                : index === this.size - 1
                ? this.pop()
                : this.splice(index, 1);
            };

            List.prototype.insert = function insert(index, value) {
              return this.splice(index, 0, value);
            };

            List.prototype.clear = function clear() {
              if (this.size === 0) {
                return this;
              }
              if (this.__ownerID) {
                this.size = this._origin = this._capacity = 0;
                this._level = SHIFT;
                this._root = this._tail = null;
                this.__hash = undefined;
                this.__altered = true;
                return this;
              }
              return emptyList();
            };

            List.prototype.push = function push(/*...values*/) {
              var values = arguments;
              var oldSize = this.size;
              return this.withMutations(function (list) {
                setListBounds(list, 0, oldSize + values.length);
                for (var ii = 0; ii < values.length; ii++) {
                  list.set(oldSize + ii, values[ii]);
                }
              });
            };

            List.prototype.pop = function pop() {
              return setListBounds(this, 0, -1);
            };

            List.prototype.unshift = function unshift(/*...values*/) {
              var values = arguments;
              return this.withMutations(function (list) {
                setListBounds(list, -values.length);
                for (var ii = 0; ii < values.length; ii++) {
                  list.set(ii, values[ii]);
                }
              });
            };

            List.prototype.shift = function shift() {
              return setListBounds(this, 1);
            };

            // @pragma Composition

            List.prototype.concat = function concat(/*...collections*/) {
              var arguments$1 = arguments;

              var seqs = [];
              for (var i = 0; i < arguments.length; i++) {
                var argument = arguments$1[i];
                var seq = IndexedCollection$$1(
                  typeof argument !== "string" && hasIterator(argument)
                    ? argument
                    : [argument]
                );
                if (seq.size !== 0) {
                  seqs.push(seq);
                }
              }
              if (seqs.length === 0) {
                return this;
              }
              if (this.size === 0 && !this.__ownerID && seqs.length === 1) {
                return this.constructor(seqs[0]);
              }
              return this.withMutations(function (list) {
                seqs.forEach(function (seq) {
                  return seq.forEach(function (value) {
                    return list.push(value);
                  });
                });
              });
            };

            List.prototype.setSize = function setSize(size) {
              return setListBounds(this, 0, size);
            };

            List.prototype.map = function map(mapper, context) {
              var this$1 = this;

              return this.withMutations(function (list) {
                for (var i = 0; i < this$1.size; i++) {
                  list.set(i, mapper.call(context, list.get(i), i, list));
                }
              });
            };

            // @pragma Iteration

            List.prototype.slice = function slice(begin, end) {
              var size = this.size;
              if (wholeSlice(begin, end, size)) {
                return this;
              }
              return setListBounds(
                this,
                resolveBegin(begin, size),
                resolveEnd(end, size)
              );
            };

            List.prototype.__iterator = function __iterator(type, reverse) {
              var index = reverse ? this.size : 0;
              var values = iterateList(this, reverse);
              return new Iterator(function () {
                var value = values();
                return value === DONE
                  ? iteratorDone()
                  : iteratorValue(type, reverse ? --index : index++, value);
              });
            };

            List.prototype.__iterate = function __iterate(fn, reverse) {
              var index = reverse ? this.size : 0;
              var values = iterateList(this, reverse);
              var value;
              while ((value = values()) !== DONE) {
                if (fn(value, reverse ? --index : index++, this) === false) {
                  break;
                }
              }
              return index;
            };

            List.prototype.__ensureOwner = function __ensureOwner(ownerID) {
              if (ownerID === this.__ownerID) {
                return this;
              }
              if (!ownerID) {
                if (this.size === 0) {
                  return emptyList();
                }
                this.__ownerID = ownerID;
                this.__altered = false;
                return this;
              }
              return makeList(
                this._origin,
                this._capacity,
                this._level,
                this._root,
                this._tail,
                ownerID,
                this.__hash
              );
            };

            return List;
          })(IndexedCollection);

          List.isList = isList;

          var ListPrototype = List.prototype;
          ListPrototype[IS_LIST_SYMBOL] = true;
          ListPrototype[DELETE] = ListPrototype.remove;
          ListPrototype.merge = ListPrototype.concat;
          ListPrototype.setIn = setIn$1;
          ListPrototype.deleteIn = ListPrototype.removeIn = deleteIn;
          ListPrototype.update = update$1;
          ListPrototype.updateIn = updateIn$1;
          ListPrototype.mergeIn = mergeIn;
          ListPrototype.mergeDeepIn = mergeDeepIn;
          ListPrototype.withMutations = withMutations;
          ListPrototype.wasAltered = wasAltered;
          ListPrototype.asImmutable = asImmutable;
          ListPrototype[
            "@@transducer/init"
          ] = ListPrototype.asMutable = asMutable;
          ListPrototype["@@transducer/step"] = function (result, arr) {
            return result.push(arr);
          };
          ListPrototype["@@transducer/result"] = function (obj) {
            return obj.asImmutable();
          };

          var VNode = function VNode(array, ownerID) {
            this.array = array;
            this.ownerID = ownerID;
          };

          // TODO: seems like these methods are very similar

          VNode.prototype.removeBefore = function removeBefore(
            ownerID,
            level,
            index
          ) {
            if (index === level ? 1 << level : this.array.length === 0) {
              return this;
            }
            var originIndex = (index >>> level) & MASK;
            if (originIndex >= this.array.length) {
              return new VNode([], ownerID);
            }
            var removingFirst = originIndex === 0;
            var newChild;
            if (level > 0) {
              var oldChild = this.array[originIndex];
              newChild =
                oldChild &&
                oldChild.removeBefore(ownerID, level - SHIFT, index);
              if (newChild === oldChild && removingFirst) {
                return this;
              }
            }
            if (removingFirst && !newChild) {
              return this;
            }
            var editable = editableVNode(this, ownerID);
            if (!removingFirst) {
              for (var ii = 0; ii < originIndex; ii++) {
                editable.array[ii] = undefined;
              }
            }
            if (newChild) {
              editable.array[originIndex] = newChild;
            }
            return editable;
          };

          VNode.prototype.removeAfter = function removeAfter(
            ownerID,
            level,
            index
          ) {
            if (index === (level ? 1 << level : 0) || this.array.length === 0) {
              return this;
            }
            var sizeIndex = ((index - 1) >>> level) & MASK;
            if (sizeIndex >= this.array.length) {
              return this;
            }

            var newChild;
            if (level > 0) {
              var oldChild = this.array[sizeIndex];
              newChild =
                oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);
              if (
                newChild === oldChild &&
                sizeIndex === this.array.length - 1
              ) {
                return this;
              }
            }

            var editable = editableVNode(this, ownerID);
            editable.array.splice(sizeIndex + 1);
            if (newChild) {
              editable.array[sizeIndex] = newChild;
            }
            return editable;
          };

          var DONE = {};

          function iterateList(list, reverse) {
            var left = list._origin;
            var right = list._capacity;
            var tailPos = getTailOffset(right);
            var tail = list._tail;

            return iterateNodeOrLeaf(list._root, list._level, 0);

            function iterateNodeOrLeaf(node, level, offset) {
              return level === 0
                ? iterateLeaf(node, offset)
                : iterateNode(node, level, offset);
            }

            function iterateLeaf(node, offset) {
              var array =
                offset === tailPos ? tail && tail.array : node && node.array;
              var from = offset > left ? 0 : left - offset;
              var to = right - offset;
              if (to > SIZE) {
                to = SIZE;
              }
              return function () {
                if (from === to) {
                  return DONE;
                }
                var idx = reverse ? --to : from++;
                return array && array[idx];
              };
            }

            function iterateNode(node, level, offset) {
              var values;
              var array = node && node.array;
              var from = offset > left ? 0 : (left - offset) >> level;
              var to = ((right - offset) >> level) + 1;
              if (to > SIZE) {
                to = SIZE;
              }
              return function () {
                while (true) {
                  if (values) {
                    var value = values();
                    if (value !== DONE) {
                      return value;
                    }
                    values = null;
                  }
                  if (from === to) {
                    return DONE;
                  }
                  var idx = reverse ? --to : from++;
                  values = iterateNodeOrLeaf(
                    array && array[idx],
                    level - SHIFT,
                    offset + (idx << level)
                  );
                }
              };
            }
          }

          function makeList(
            origin,
            capacity,
            level,
            root,
            tail,
            ownerID,
            hash
          ) {
            var list = Object.create(ListPrototype);
            list.size = capacity - origin;
            list._origin = origin;
            list._capacity = capacity;
            list._level = level;
            list._root = root;
            list._tail = tail;
            list.__ownerID = ownerID;
            list.__hash = hash;
            list.__altered = false;
            return list;
          }

          var EMPTY_LIST;
          function emptyList() {
            return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));
          }

          function updateList(list, index, value) {
            index = wrapIndex(list, index);

            if (index !== index) {
              return list;
            }

            if (index >= list.size || index < 0) {
              return list.withMutations(function (list) {
                index < 0
                  ? setListBounds(list, index).set(0, value)
                  : setListBounds(list, 0, index + 1).set(index, value);
              });
            }

            index += list._origin;

            var newTail = list._tail;
            var newRoot = list._root;
            var didAlter = MakeRef();
            if (index >= getTailOffset(list._capacity)) {
              newTail = updateVNode(
                newTail,
                list.__ownerID,
                0,
                index,
                value,
                didAlter
              );
            } else {
              newRoot = updateVNode(
                newRoot,
                list.__ownerID,
                list._level,
                index,
                value,
                didAlter
              );
            }

            if (!didAlter.value) {
              return list;
            }

            if (list.__ownerID) {
              list._root = newRoot;
              list._tail = newTail;
              list.__hash = undefined;
              list.__altered = true;
              return list;
            }
            return makeList(
              list._origin,
              list._capacity,
              list._level,
              newRoot,
              newTail
            );
          }

          function updateVNode(node, ownerID, level, index, value, didAlter) {
            var idx = (index >>> level) & MASK;
            var nodeHas = node && idx < node.array.length;
            if (!nodeHas && value === undefined) {
              return node;
            }

            var newNode;

            if (level > 0) {
              var lowerNode = node && node.array[idx];
              var newLowerNode = updateVNode(
                lowerNode,
                ownerID,
                level - SHIFT,
                index,
                value,
                didAlter
              );
              if (newLowerNode === lowerNode) {
                return node;
              }
              newNode = editableVNode(node, ownerID);
              newNode.array[idx] = newLowerNode;
              return newNode;
            }

            if (nodeHas && node.array[idx] === value) {
              return node;
            }

            if (didAlter) {
              SetRef(didAlter);
            }

            newNode = editableVNode(node, ownerID);
            if (value === undefined && idx === newNode.array.length - 1) {
              newNode.array.pop();
            } else {
              newNode.array[idx] = value;
            }
            return newNode;
          }

          function editableVNode(node, ownerID) {
            if (ownerID && node && ownerID === node.ownerID) {
              return node;
            }
            return new VNode(node ? node.array.slice() : [], ownerID);
          }

          function listNodeFor(list, rawIndex) {
            if (rawIndex >= getTailOffset(list._capacity)) {
              return list._tail;
            }
            if (rawIndex < 1 << (list._level + SHIFT)) {
              var node = list._root;
              var level = list._level;
              while (node && level > 0) {
                node = node.array[(rawIndex >>> level) & MASK];
                level -= SHIFT;
              }
              return node;
            }
          }

          function setListBounds(list, begin, end) {
            // Sanitize begin & end using this shorthand for ToInt32(argument)
            // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
            if (begin !== undefined) {
              begin |= 0;
            }
            if (end !== undefined) {
              end |= 0;
            }
            var owner = list.__ownerID || new OwnerID();
            var oldOrigin = list._origin;
            var oldCapacity = list._capacity;
            var newOrigin = oldOrigin + begin;
            var newCapacity =
              end === undefined
                ? oldCapacity
                : end < 0
                ? oldCapacity + end
                : oldOrigin + end;
            if (newOrigin === oldOrigin && newCapacity === oldCapacity) {
              return list;
            }

            // If it's going to end after it starts, it's empty.
            if (newOrigin >= newCapacity) {
              return list.clear();
            }

            var newLevel = list._level;
            var newRoot = list._root;

            // New origin might need creating a higher root.
            var offsetShift = 0;
            while (newOrigin + offsetShift < 0) {
              newRoot = new VNode(
                newRoot && newRoot.array.length ? [undefined, newRoot] : [],
                owner
              );
              newLevel += SHIFT;
              offsetShift += 1 << newLevel;
            }
            if (offsetShift) {
              newOrigin += offsetShift;
              oldOrigin += offsetShift;
              newCapacity += offsetShift;
              oldCapacity += offsetShift;
            }

            var oldTailOffset = getTailOffset(oldCapacity);
            var newTailOffset = getTailOffset(newCapacity);

            // New size might need creating a higher root.
            while (newTailOffset >= 1 << (newLevel + SHIFT)) {
              newRoot = new VNode(
                newRoot && newRoot.array.length ? [newRoot] : [],
                owner
              );
              newLevel += SHIFT;
            }

            // Locate or create the new tail.
            var oldTail = list._tail;
            var newTail =
              newTailOffset < oldTailOffset
                ? listNodeFor(list, newCapacity - 1)
                : newTailOffset > oldTailOffset
                ? new VNode([], owner)
                : oldTail;

            // Merge Tail into tree.
            if (
              oldTail &&
              newTailOffset > oldTailOffset &&
              newOrigin < oldCapacity &&
              oldTail.array.length
            ) {
              newRoot = editableVNode(newRoot, owner);
              var node = newRoot;
              for (var level = newLevel; level > SHIFT; level -= SHIFT) {
                var idx = (oldTailOffset >>> level) & MASK;
                node = node.array[idx] = editableVNode(node.array[idx], owner);
              }
              node.array[(oldTailOffset >>> SHIFT) & MASK] = oldTail;
            }

            // If the size has been reduced, there's a chance the tail needs to be trimmed.
            if (newCapacity < oldCapacity) {
              newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);
            }

            // If the new origin is within the tail, then we do not need a root.
            if (newOrigin >= newTailOffset) {
              newOrigin -= newTailOffset;
              newCapacity -= newTailOffset;
              newLevel = SHIFT;
              newRoot = null;
              newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);

              // Otherwise, if the root has been trimmed, garbage collect.
            } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {
              offsetShift = 0;

              // Identify the new top root node of the subtree of the old root.
              while (newRoot) {
                var beginIndex = (newOrigin >>> newLevel) & MASK;
                if ((beginIndex !== newTailOffset >>> newLevel) & MASK) {
                  break;
                }
                if (beginIndex) {
                  offsetShift += (1 << newLevel) * beginIndex;
                }
                newLevel -= SHIFT;
                newRoot = newRoot.array[beginIndex];
              }

              // Trim the new sides of the new root.
              if (newRoot && newOrigin > oldOrigin) {
                newRoot = newRoot.removeBefore(
                  owner,
                  newLevel,
                  newOrigin - offsetShift
                );
              }
              if (newRoot && newTailOffset < oldTailOffset) {
                newRoot = newRoot.removeAfter(
                  owner,
                  newLevel,
                  newTailOffset - offsetShift
                );
              }
              if (offsetShift) {
                newOrigin -= offsetShift;
                newCapacity -= offsetShift;
              }
            }

            if (list.__ownerID) {
              list.size = newCapacity - newOrigin;
              list._origin = newOrigin;
              list._capacity = newCapacity;
              list._level = newLevel;
              list._root = newRoot;
              list._tail = newTail;
              list.__hash = undefined;
              list.__altered = true;
              return list;
            }
            return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);
          }

          function getTailOffset(size) {
            return size < SIZE ? 0 : ((size - 1) >>> SHIFT) << SHIFT;
          }

          var OrderedMap = /*@__PURE__*/ (function (Map$$1) {
            function OrderedMap(value) {
              return value === null || value === undefined
                ? emptyOrderedMap()
                : isOrderedMap(value)
                ? value
                : emptyOrderedMap().withMutations(function (map) {
                    var iter = KeyedCollection(value);
                    assertNotInfinite(iter.size);
                    iter.forEach(function (v, k) {
                      return map.set(k, v);
                    });
                  });
            }

            if (Map$$1) OrderedMap.__proto__ = Map$$1;
            OrderedMap.prototype = Object.create(Map$$1 && Map$$1.prototype);
            OrderedMap.prototype.constructor = OrderedMap;

            OrderedMap.of = function of(/*...values*/) {
              return this(arguments);
            };

            OrderedMap.prototype.toString = function toString() {
              return this.__toString("OrderedMap {", "}");
            };

            // @pragma Access

            OrderedMap.prototype.get = function get(k, notSetValue) {
              var index = this._map.get(k);
              return index !== undefined
                ? this._list.get(index)[1]
                : notSetValue;
            };

            // @pragma Modification

            OrderedMap.prototype.clear = function clear() {
              if (this.size === 0) {
                return this;
              }
              if (this.__ownerID) {
                this.size = 0;
                this._map.clear();
                this._list.clear();
                return this;
              }
              return emptyOrderedMap();
            };

            OrderedMap.prototype.set = function set(k, v) {
              return updateOrderedMap(this, k, v);
            };

            OrderedMap.prototype.remove = function remove(k) {
              return updateOrderedMap(this, k, NOT_SET);
            };

            OrderedMap.prototype.wasAltered = function wasAltered() {
              return this._map.wasAltered() || this._list.wasAltered();
            };

            OrderedMap.prototype.__iterate = function __iterate(fn, reverse) {
              var this$1 = this;

              return this._list.__iterate(function (entry) {
                return entry && fn(entry[1], entry[0], this$1);
              }, reverse);
            };

            OrderedMap.prototype.__iterator = function __iterator(
              type,
              reverse
            ) {
              return this._list.fromEntrySeq().__iterator(type, reverse);
            };

            OrderedMap.prototype.__ensureOwner = function __ensureOwner(
              ownerID
            ) {
              if (ownerID === this.__ownerID) {
                return this;
              }
              var newMap = this._map.__ensureOwner(ownerID);
              var newList = this._list.__ensureOwner(ownerID);
              if (!ownerID) {
                if (this.size === 0) {
                  return emptyOrderedMap();
                }
                this.__ownerID = ownerID;
                this._map = newMap;
                this._list = newList;
                return this;
              }
              return makeOrderedMap(newMap, newList, ownerID, this.__hash);
            };

            return OrderedMap;
          })(Map);

          OrderedMap.isOrderedMap = isOrderedMap;

          OrderedMap.prototype[IS_ORDERED_SYMBOL] = true;
          OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;

          function makeOrderedMap(map, list, ownerID, hash) {
            var omap = Object.create(OrderedMap.prototype);
            omap.size = map ? map.size : 0;
            omap._map = map;
            omap._list = list;
            omap.__ownerID = ownerID;
            omap.__hash = hash;
            return omap;
          }

          var EMPTY_ORDERED_MAP;
          function emptyOrderedMap() {
            return (
              EMPTY_ORDERED_MAP ||
              (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()))
            );
          }

          function updateOrderedMap(omap, k, v) {
            var map = omap._map;
            var list = omap._list;
            var i = map.get(k);
            var has = i !== undefined;
            var newMap;
            var newList;
            if (v === NOT_SET) {
              // removed
              if (!has) {
                return omap;
              }
              if (list.size >= SIZE && list.size >= map.size * 2) {
                newList = list.filter(function (entry, idx) {
                  return entry !== undefined && i !== idx;
                });
                newMap = newList
                  .toKeyedSeq()
                  .map(function (entry) {
                    return entry[0];
                  })
                  .flip()
                  .toMap();
                if (omap.__ownerID) {
                  newMap.__ownerID = newList.__ownerID = omap.__ownerID;
                }
              } else {
                newMap = map.remove(k);
                newList =
                  i === list.size - 1 ? list.pop() : list.set(i, undefined);
              }
            } else if (has) {
              if (v === list.get(i)[1]) {
                return omap;
              }
              newMap = map;
              newList = list.set(i, [k, v]);
            } else {
              newMap = map.set(k, list.size);
              newList = list.set(list.size, [k, v]);
            }
            if (omap.__ownerID) {
              omap.size = newMap.size;
              omap._map = newMap;
              omap._list = newList;
              omap.__hash = undefined;
              return omap;
            }
            return makeOrderedMap(newMap, newList);
          }

          var IS_STACK_SYMBOL = "@@__IMMUTABLE_STACK__@@";

          function isStack(maybeStack) {
            return Boolean(maybeStack && maybeStack[IS_STACK_SYMBOL]);
          }

          var Stack = /*@__PURE__*/ (function (IndexedCollection$$1) {
            function Stack(value) {
              return value === null || value === undefined
                ? emptyStack()
                : isStack(value)
                ? value
                : emptyStack().pushAll(value);
            }

            if (IndexedCollection$$1) Stack.__proto__ = IndexedCollection$$1;
            Stack.prototype = Object.create(
              IndexedCollection$$1 && IndexedCollection$$1.prototype
            );
            Stack.prototype.constructor = Stack;

            Stack.of = function of(/*...values*/) {
              return this(arguments);
            };

            Stack.prototype.toString = function toString() {
              return this.__toString("Stack [", "]");
            };

            // @pragma Access

            Stack.prototype.get = function get(index, notSetValue) {
              var head = this._head;
              index = wrapIndex(this, index);
              while (head && index--) {
                head = head.next;
              }
              return head ? head.value : notSetValue;
            };

            Stack.prototype.peek = function peek() {
              return this._head && this._head.value;
            };

            // @pragma Modification

            Stack.prototype.push = function push(/*...values*/) {
              var arguments$1 = arguments;

              if (arguments.length === 0) {
                return this;
              }
              var newSize = this.size + arguments.length;
              var head = this._head;
              for (var ii = arguments.length - 1; ii >= 0; ii--) {
                head = {
                  value: arguments$1[ii],
                  next: head,
                };
              }
              if (this.__ownerID) {
                this.size = newSize;
                this._head = head;
                this.__hash = undefined;
                this.__altered = true;
                return this;
              }
              return makeStack(newSize, head);
            };

            Stack.prototype.pushAll = function pushAll(iter) {
              iter = IndexedCollection$$1(iter);
              if (iter.size === 0) {
                return this;
              }
              if (this.size === 0 && isStack(iter)) {
                return iter;
              }
              assertNotInfinite(iter.size);
              var newSize = this.size;
              var head = this._head;
              iter.__iterate(function (value) {
                newSize++;
                head = {
                  value: value,
                  next: head,
                };
              }, /* reverse */ true);
              if (this.__ownerID) {
                this.size = newSize;
                this._head = head;
                this.__hash = undefined;
                this.__altered = true;
                return this;
              }
              return makeStack(newSize, head);
            };

            Stack.prototype.pop = function pop() {
              return this.slice(1);
            };

            Stack.prototype.clear = function clear() {
              if (this.size === 0) {
                return this;
              }
              if (this.__ownerID) {
                this.size = 0;
                this._head = undefined;
                this.__hash = undefined;
                this.__altered = true;
                return this;
              }
              return emptyStack();
            };

            Stack.prototype.slice = function slice(begin, end) {
              if (wholeSlice(begin, end, this.size)) {
                return this;
              }
              var resolvedBegin = resolveBegin(begin, this.size);
              var resolvedEnd = resolveEnd(end, this.size);
              if (resolvedEnd !== this.size) {
                // super.slice(begin, end);
                return IndexedCollection$$1.prototype.slice.call(
                  this,
                  begin,
                  end
                );
              }
              var newSize = this.size - resolvedBegin;
              var head = this._head;
              while (resolvedBegin--) {
                head = head.next;
              }
              if (this.__ownerID) {
                this.size = newSize;
                this._head = head;
                this.__hash = undefined;
                this.__altered = true;
                return this;
              }
              return makeStack(newSize, head);
            };

            // @pragma Mutability

            Stack.prototype.__ensureOwner = function __ensureOwner(ownerID) {
              if (ownerID === this.__ownerID) {
                return this;
              }
              if (!ownerID) {
                if (this.size === 0) {
                  return emptyStack();
                }
                this.__ownerID = ownerID;
                this.__altered = false;
                return this;
              }
              return makeStack(this.size, this._head, ownerID, this.__hash);
            };

            // @pragma Iteration

            Stack.prototype.__iterate = function __iterate(fn, reverse) {
              var this$1 = this;

              if (reverse) {
                return new ArraySeq(this.toArray()).__iterate(function (v, k) {
                  return fn(v, k, this$1);
                }, reverse);
              }
              var iterations = 0;
              var node = this._head;
              while (node) {
                if (fn(node.value, iterations++, this) === false) {
                  break;
                }
                node = node.next;
              }
              return iterations;
            };

            Stack.prototype.__iterator = function __iterator(type, reverse) {
              if (reverse) {
                return new ArraySeq(this.toArray()).__iterator(type, reverse);
              }
              var iterations = 0;
              var node = this._head;
              return new Iterator(function () {
                if (node) {
                  var value = node.value;
                  node = node.next;
                  return iteratorValue(type, iterations++, value);
                }
                return iteratorDone();
              });
            };

            return Stack;
          })(IndexedCollection);

          Stack.isStack = isStack;

          var StackPrototype = Stack.prototype;
          StackPrototype[IS_STACK_SYMBOL] = true;
          StackPrototype.shift = StackPrototype.pop;
          StackPrototype.unshift = StackPrototype.push;
          StackPrototype.unshiftAll = StackPrototype.pushAll;
          StackPrototype.withMutations = withMutations;
          StackPrototype.wasAltered = wasAltered;
          StackPrototype.asImmutable = asImmutable;
          StackPrototype[
            "@@transducer/init"
          ] = StackPrototype.asMutable = asMutable;
          StackPrototype["@@transducer/step"] = function (result, arr) {
            return result.unshift(arr);
          };
          StackPrototype["@@transducer/result"] = function (obj) {
            return obj.asImmutable();
          };

          function makeStack(size, head, ownerID, hash) {
            var map = Object.create(StackPrototype);
            map.size = size;
            map._head = head;
            map.__ownerID = ownerID;
            map.__hash = hash;
            map.__altered = false;
            return map;
          }

          var EMPTY_STACK;
          function emptyStack() {
            return EMPTY_STACK || (EMPTY_STACK = makeStack(0));
          }

          var IS_SET_SYMBOL = "@@__IMMUTABLE_SET__@@";

          function isSet(maybeSet) {
            return Boolean(maybeSet && maybeSet[IS_SET_SYMBOL]);
          }

          function isOrderedSet(maybeOrderedSet) {
            return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);
          }

          function deepEqual(a, b) {
            if (a === b) {
              return true;
            }

            if (
              !isCollection(b) ||
              (a.size !== undefined &&
                b.size !== undefined &&
                a.size !== b.size) ||
              (a.__hash !== undefined &&
                b.__hash !== undefined &&
                a.__hash !== b.__hash) ||
              isKeyed(a) !== isKeyed(b) ||
              isIndexed(a) !== isIndexed(b) ||
              isOrdered(a) !== isOrdered(b)
            ) {
              return false;
            }

            if (a.size === 0 && b.size === 0) {
              return true;
            }

            var notAssociative = !isAssociative(a);

            if (isOrdered(a)) {
              var entries = a.entries();
              return (
                b.every(function (v, k) {
                  var entry = entries.next().value;
                  return (
                    entry &&
                    is(entry[1], v) &&
                    (notAssociative || is(entry[0], k))
                  );
                }) && entries.next().done
              );
            }

            var flipped = false;

            if (a.size === undefined) {
              if (b.size === undefined) {
                if (typeof a.cacheResult === "function") {
                  a.cacheResult();
                }
              } else {
                flipped = true;
                var _ = a;
                a = b;
                b = _;
              }
            }

            var allEqual = true;
            var bSize = b.__iterate(function (v, k) {
              if (
                notAssociative
                  ? !a.has(v)
                  : flipped
                  ? !is(v, a.get(k, NOT_SET))
                  : !is(a.get(k, NOT_SET), v)
              ) {
                allEqual = false;
                return false;
              }
            });

            return allEqual && a.size === bSize;
          }

          /**
           * Contributes additional methods to a constructor
           */
          function mixin(ctor, methods) {
            var keyCopier = function (key) {
              ctor.prototype[key] = methods[key];
            };
            Object.keys(methods).forEach(keyCopier);
            Object.getOwnPropertySymbols &&
              Object.getOwnPropertySymbols(methods).forEach(keyCopier);
            return ctor;
          }

          function toJS(value) {
            if (!value || typeof value !== "object") {
              return value;
            }
            if (!isCollection(value)) {
              if (!isDataStructure(value)) {
                return value;
              }
              value = Seq(value);
            }
            if (isKeyed(value)) {
              var result$1 = {};
              value.__iterate(function (v, k) {
                result$1[k] = toJS(v);
              });
              return result$1;
            }
            var result = [];
            value.__iterate(function (v) {
              result.push(toJS(v));
            });
            return result;
          }

          var Set = /*@__PURE__*/ (function (SetCollection$$1) {
            function Set(value) {
              return value === null || value === undefined
                ? emptySet()
                : isSet(value) && !isOrdered(value)
                ? value
                : emptySet().withMutations(function (set) {
                    var iter = SetCollection$$1(value);
                    assertNotInfinite(iter.size);
                    iter.forEach(function (v) {
                      return set.add(v);
                    });
                  });
            }

            if (SetCollection$$1) Set.__proto__ = SetCollection$$1;
            Set.prototype = Object.create(
              SetCollection$$1 && SetCollection$$1.prototype
            );
            Set.prototype.constructor = Set;

            Set.of = function of(/*...values*/) {
              return this(arguments);
            };

            Set.fromKeys = function fromKeys(value) {
              return this(KeyedCollection(value).keySeq());
            };

            Set.intersect = function intersect(sets) {
              sets = Collection(sets).toArray();
              return sets.length
                ? SetPrototype.intersect.apply(Set(sets.pop()), sets)
                : emptySet();
            };

            Set.union = function union(sets) {
              sets = Collection(sets).toArray();
              return sets.length
                ? SetPrototype.union.apply(Set(sets.pop()), sets)
                : emptySet();
            };

            Set.prototype.toString = function toString() {
              return this.__toString("Set {", "}");
            };

            // @pragma Access

            Set.prototype.has = function has(value) {
              return this._map.has(value);
            };

            // @pragma Modification

            Set.prototype.add = function add(value) {
              return updateSet(this, this._map.set(value, value));
            };

            Set.prototype.remove = function remove(value) {
              return updateSet(this, this._map.remove(value));
            };

            Set.prototype.clear = function clear() {
              return updateSet(this, this._map.clear());
            };

            // @pragma Composition

            Set.prototype.map = function map(mapper, context) {
              var this$1 = this;

              var removes = [];
              var adds = [];
              this.forEach(function (value) {
                var mapped = mapper.call(context, value, value, this$1);
                if (mapped !== value) {
                  removes.push(value);
                  adds.push(mapped);
                }
              });
              return this.withMutations(function (set) {
                removes.forEach(function (value) {
                  return set.remove(value);
                });
                adds.forEach(function (value) {
                  return set.add(value);
                });
              });
            };

            Set.prototype.union = function union() {
              var iters = [],
                len = arguments.length;
              while (len--) iters[len] = arguments[len];

              iters = iters.filter(function (x) {
                return x.size !== 0;
              });
              if (iters.length === 0) {
                return this;
              }
              if (this.size === 0 && !this.__ownerID && iters.length === 1) {
                return this.constructor(iters[0]);
              }
              return this.withMutations(function (set) {
                for (var ii = 0; ii < iters.length; ii++) {
                  SetCollection$$1(iters[ii]).forEach(function (value) {
                    return set.add(value);
                  });
                }
              });
            };

            Set.prototype.intersect = function intersect() {
              var iters = [],
                len = arguments.length;
              while (len--) iters[len] = arguments[len];

              if (iters.length === 0) {
                return this;
              }
              iters = iters.map(function (iter) {
                return SetCollection$$1(iter);
              });
              var toRemove = [];
              this.forEach(function (value) {
                if (
                  !iters.every(function (iter) {
                    return iter.includes(value);
                  })
                ) {
                  toRemove.push(value);
                }
              });
              return this.withMutations(function (set) {
                toRemove.forEach(function (value) {
                  set.remove(value);
                });
              });
            };

            Set.prototype.subtract = function subtract() {
              var iters = [],
                len = arguments.length;
              while (len--) iters[len] = arguments[len];

              if (iters.length === 0) {
                return this;
              }
              iters = iters.map(function (iter) {
                return SetCollection$$1(iter);
              });
              var toRemove = [];
              this.forEach(function (value) {
                if (
                  iters.some(function (iter) {
                    return iter.includes(value);
                  })
                ) {
                  toRemove.push(value);
                }
              });
              return this.withMutations(function (set) {
                toRemove.forEach(function (value) {
                  set.remove(value);
                });
              });
            };

            Set.prototype.sort = function sort(comparator) {
              // Late binding
              return OrderedSet(sortFactory(this, comparator));
            };

            Set.prototype.sortBy = function sortBy(mapper, comparator) {
              // Late binding
              return OrderedSet(sortFactory(this, comparator, mapper));
            };

            Set.prototype.wasAltered = function wasAltered() {
              return this._map.wasAltered();
            };

            Set.prototype.__iterate = function __iterate(fn, reverse) {
              var this$1 = this;

              return this._map.__iterate(function (k) {
                return fn(k, k, this$1);
              }, reverse);
            };

            Set.prototype.__iterator = function __iterator(type, reverse) {
              return this._map.__iterator(type, reverse);
            };

            Set.prototype.__ensureOwner = function __ensureOwner(ownerID) {
              if (ownerID === this.__ownerID) {
                return this;
              }
              var newMap = this._map.__ensureOwner(ownerID);
              if (!ownerID) {
                if (this.size === 0) {
                  return this.__empty();
                }
                this.__ownerID = ownerID;
                this._map = newMap;
                return this;
              }
              return this.__make(newMap, ownerID);
            };

            return Set;
          })(SetCollection);

          Set.isSet = isSet;

          var SetPrototype = Set.prototype;
          SetPrototype[IS_SET_SYMBOL] = true;
          SetPrototype[DELETE] = SetPrototype.remove;
          SetPrototype.merge = SetPrototype.concat = SetPrototype.union;
          SetPrototype.withMutations = withMutations;
          SetPrototype.asImmutable = asImmutable;
          SetPrototype[
            "@@transducer/init"
          ] = SetPrototype.asMutable = asMutable;
          SetPrototype["@@transducer/step"] = function (result, arr) {
            return result.add(arr);
          };
          SetPrototype["@@transducer/result"] = function (obj) {
            return obj.asImmutable();
          };

          SetPrototype.__empty = emptySet;
          SetPrototype.__make = makeSet;

          function updateSet(set, newMap) {
            if (set.__ownerID) {
              set.size = newMap.size;
              set._map = newMap;
              return set;
            }
            return newMap === set._map
              ? set
              : newMap.size === 0
              ? set.__empty()
              : set.__make(newMap);
          }

          function makeSet(map, ownerID) {
            var set = Object.create(SetPrototype);
            set.size = map ? map.size : 0;
            set._map = map;
            set.__ownerID = ownerID;
            return set;
          }

          var EMPTY_SET;
          function emptySet() {
            return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));
          }

          /**
           * Returns a lazy seq of nums from start (inclusive) to end
           * (exclusive), by step, where start defaults to 0, step to 1, and end to
           * infinity. When start is equal to end, returns empty list.
           */
          var Range = /*@__PURE__*/ (function (IndexedSeq$$1) {
            function Range(start, end, step) {
              if (!(this instanceof Range)) {
                return new Range(start, end, step);
              }
              invariant(step !== 0, "Cannot step a Range by 0");
              start = start || 0;
              if (end === undefined) {
                end = Infinity;
              }
              step = step === undefined ? 1 : Math.abs(step);
              if (end < start) {
                step = -step;
              }
              this._start = start;
              this._end = end;
              this._step = step;
              this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);
              if (this.size === 0) {
                if (EMPTY_RANGE) {
                  return EMPTY_RANGE;
                }
                EMPTY_RANGE = this;
              }
            }

            if (IndexedSeq$$1) Range.__proto__ = IndexedSeq$$1;
            Range.prototype = Object.create(
              IndexedSeq$$1 && IndexedSeq$$1.prototype
            );
            Range.prototype.constructor = Range;

            Range.prototype.toString = function toString() {
              if (this.size === 0) {
                return "Range []";
              }
              return (
                "Range [ " +
                this._start +
                "..." +
                this._end +
                (this._step !== 1 ? " by " + this._step : "") +
                " ]"
              );
            };

            Range.prototype.get = function get(index, notSetValue) {
              return this.has(index)
                ? this._start + wrapIndex(this, index) * this._step
                : notSetValue;
            };

            Range.prototype.includes = function includes(searchValue) {
              var possibleIndex = (searchValue - this._start) / this._step;
              return (
                possibleIndex >= 0 &&
                possibleIndex < this.size &&
                possibleIndex === Math.floor(possibleIndex)
              );
            };

            Range.prototype.slice = function slice(begin, end) {
              if (wholeSlice(begin, end, this.size)) {
                return this;
              }
              begin = resolveBegin(begin, this.size);
              end = resolveEnd(end, this.size);
              if (end <= begin) {
                return new Range(0, 0);
              }
              return new Range(
                this.get(begin, this._end),
                this.get(end, this._end),
                this._step
              );
            };

            Range.prototype.indexOf = function indexOf(searchValue) {
              var offsetValue = searchValue - this._start;
              if (offsetValue % this._step === 0) {
                var index = offsetValue / this._step;
                if (index >= 0 && index < this.size) {
                  return index;
                }
              }
              return -1;
            };

            Range.prototype.lastIndexOf = function lastIndexOf(searchValue) {
              return this.indexOf(searchValue);
            };

            Range.prototype.__iterate = function __iterate(fn, reverse) {
              var size = this.size;
              var step = this._step;
              var value = reverse
                ? this._start + (size - 1) * step
                : this._start;
              var i = 0;
              while (i !== size) {
                if (fn(value, reverse ? size - ++i : i++, this) === false) {
                  break;
                }
                value += reverse ? -step : step;
              }
              return i;
            };

            Range.prototype.__iterator = function __iterator(type, reverse) {
              var size = this.size;
              var step = this._step;
              var value = reverse
                ? this._start + (size - 1) * step
                : this._start;
              var i = 0;
              return new Iterator(function () {
                if (i === size) {
                  return iteratorDone();
                }
                var v = value;
                value += reverse ? -step : step;
                return iteratorValue(type, reverse ? size - ++i : i++, v);
              });
            };

            Range.prototype.equals = function equals(other) {
              return other instanceof Range
                ? this._start === other._start &&
                    this._end === other._end &&
                    this._step === other._step
                : deepEqual(this, other);
            };

            return Range;
          })(IndexedSeq);

          var EMPTY_RANGE;

          function getIn(collection, searchKeyPath, notSetValue) {
            var keyPath = coerceKeyPath(searchKeyPath);
            var i = 0;
            while (i !== keyPath.length) {
              collection = get(collection, keyPath[i++], NOT_SET);
              if (collection === NOT_SET) {
                return notSetValue;
              }
            }
            return collection;
          }

          function getIn$1(searchKeyPath, notSetValue) {
            return getIn(this, searchKeyPath, notSetValue);
          }

          function hasIn(collection, keyPath) {
            return getIn(collection, keyPath, NOT_SET) !== NOT_SET;
          }

          function hasIn$1(searchKeyPath) {
            return hasIn(this, searchKeyPath);
          }

          function toObject() {
            assertNotInfinite(this.size);
            var object = {};
            this.__iterate(function (v, k) {
              object[k] = v;
            });
            return object;
          }

          // Note: all of these methods are deprecated.
          Collection.isIterable = isCollection;
          Collection.isKeyed = isKeyed;
          Collection.isIndexed = isIndexed;
          Collection.isAssociative = isAssociative;
          Collection.isOrdered = isOrdered;

          Collection.Iterator = Iterator;

          mixin(Collection, {
            // ### Conversion to other types

            toArray: function toArray() {
              assertNotInfinite(this.size);
              var array = new Array(this.size || 0);
              var useTuples = isKeyed(this);
              var i = 0;
              this.__iterate(function (v, k) {
                // Keyed collections produce an array of tuples.
                array[i++] = useTuples ? [k, v] : v;
              });
              return array;
            },

            toIndexedSeq: function toIndexedSeq() {
              return new ToIndexedSequence(this);
            },

            toJS: function toJS$1() {
              return toJS(this);
            },

            toKeyedSeq: function toKeyedSeq() {
              return new ToKeyedSequence(this, true);
            },

            toMap: function toMap() {
              // Use Late Binding here to solve the circular dependency.
              return Map(this.toKeyedSeq());
            },

            toObject: toObject,

            toOrderedMap: function toOrderedMap() {
              // Use Late Binding here to solve the circular dependency.
              return OrderedMap(this.toKeyedSeq());
            },

            toOrderedSet: function toOrderedSet() {
              // Use Late Binding here to solve the circular dependency.
              return OrderedSet(isKeyed(this) ? this.valueSeq() : this);
            },

            toSet: function toSet() {
              // Use Late Binding here to solve the circular dependency.
              return Set(isKeyed(this) ? this.valueSeq() : this);
            },

            toSetSeq: function toSetSeq() {
              return new ToSetSequence(this);
            },

            toSeq: function toSeq() {
              return isIndexed(this)
                ? this.toIndexedSeq()
                : isKeyed(this)
                ? this.toKeyedSeq()
                : this.toSetSeq();
            },

            toStack: function toStack() {
              // Use Late Binding here to solve the circular dependency.
              return Stack(isKeyed(this) ? this.valueSeq() : this);
            },

            toList: function toList() {
              // Use Late Binding here to solve the circular dependency.
              return List(isKeyed(this) ? this.valueSeq() : this);
            },

            // ### Common JavaScript methods and properties

            toString: function toString() {
              return "[Collection]";
            },

            __toString: function __toString(head, tail) {
              if (this.size === 0) {
                return head + tail;
              }
              return (
                head +
                " " +
                this.toSeq().map(this.__toStringMapper).join(", ") +
                " " +
                tail
              );
            },

            // ### ES6 Collection methods (ES6 Array and Map)

            concat: function concat() {
              var values = [],
                len = arguments.length;
              while (len--) values[len] = arguments[len];

              return reify(this, concatFactory(this, values));
            },

            includes: function includes(searchValue) {
              return this.some(function (value) {
                return is(value, searchValue);
              });
            },

            entries: function entries() {
              return this.__iterator(ITERATE_ENTRIES);
            },

            every: function every(predicate, context) {
              assertNotInfinite(this.size);
              var returnValue = true;
              this.__iterate(function (v, k, c) {
                if (!predicate.call(context, v, k, c)) {
                  returnValue = false;
                  return false;
                }
              });
              return returnValue;
            },

            filter: function filter(predicate, context) {
              return reify(this, filterFactory(this, predicate, context, true));
            },

            find: function find(predicate, context, notSetValue) {
              var entry = this.findEntry(predicate, context);
              return entry ? entry[1] : notSetValue;
            },

            forEach: function forEach(sideEffect, context) {
              assertNotInfinite(this.size);
              return this.__iterate(
                context ? sideEffect.bind(context) : sideEffect
              );
            },

            join: function join(separator) {
              assertNotInfinite(this.size);
              separator = separator !== undefined ? "" + separator : ",";
              var joined = "";
              var isFirst = true;
              this.__iterate(function (v) {
                isFirst ? (isFirst = false) : (joined += separator);
                joined += v !== null && v !== undefined ? v.toString() : "";
              });
              return joined;
            },

            keys: function keys() {
              return this.__iterator(ITERATE_KEYS);
            },

            map: function map(mapper, context) {
              return reify(this, mapFactory(this, mapper, context));
            },

            reduce: function reduce$1(reducer, initialReduction, context) {
              return reduce(
                this,
                reducer,
                initialReduction,
                context,
                arguments.length < 2,
                false
              );
            },

            reduceRight: function reduceRight(
              reducer,
              initialReduction,
              context
            ) {
              return reduce(
                this,
                reducer,
                initialReduction,
                context,
                arguments.length < 2,
                true
              );
            },

            reverse: function reverse() {
              return reify(this, reverseFactory(this, true));
            },

            slice: function slice(begin, end) {
              return reify(this, sliceFactory(this, begin, end, true));
            },

            some: function some(predicate, context) {
              return !this.every(not(predicate), context);
            },

            sort: function sort(comparator) {
              return reify(this, sortFactory(this, comparator));
            },

            values: function values() {
              return this.__iterator(ITERATE_VALUES);
            },

            // ### More sequential methods

            butLast: function butLast() {
              return this.slice(0, -1);
            },

            isEmpty: function isEmpty() {
              return this.size !== undefined
                ? this.size === 0
                : !this.some(function () {
                    return true;
                  });
            },

            count: function count(predicate, context) {
              return ensureSize(
                predicate ? this.toSeq().filter(predicate, context) : this
              );
            },

            countBy: function countBy(grouper, context) {
              return countByFactory(this, grouper, context);
            },

            equals: function equals(other) {
              return deepEqual(this, other);
            },

            entrySeq: function entrySeq() {
              var collection = this;
              if (collection._cache) {
                // We cache as an entries array, so we can just return the cache!
                return new ArraySeq(collection._cache);
              }
              var entriesSequence = collection
                .toSeq()
                .map(entryMapper)
                .toIndexedSeq();
              entriesSequence.fromEntrySeq = function () {
                return collection.toSeq();
              };
              return entriesSequence;
            },

            filterNot: function filterNot(predicate, context) {
              return this.filter(not(predicate), context);
            },

            findEntry: function findEntry(predicate, context, notSetValue) {
              var found = notSetValue;
              this.__iterate(function (v, k, c) {
                if (predicate.call(context, v, k, c)) {
                  found = [k, v];
                  return false;
                }
              });
              return found;
            },

            findKey: function findKey(predicate, context) {
              var entry = this.findEntry(predicate, context);
              return entry && entry[0];
            },

            findLast: function findLast(predicate, context, notSetValue) {
              return this.toKeyedSeq()
                .reverse()
                .find(predicate, context, notSetValue);
            },

            findLastEntry: function findLastEntry(
              predicate,
              context,
              notSetValue
            ) {
              return this.toKeyedSeq()
                .reverse()
                .findEntry(predicate, context, notSetValue);
            },

            findLastKey: function findLastKey(predicate, context) {
              return this.toKeyedSeq().reverse().findKey(predicate, context);
            },

            first: function first(notSetValue) {
              return this.find(returnTrue, null, notSetValue);
            },

            flatMap: function flatMap(mapper, context) {
              return reify(this, flatMapFactory(this, mapper, context));
            },

            flatten: function flatten(depth) {
              return reify(this, flattenFactory(this, depth, true));
            },

            fromEntrySeq: function fromEntrySeq() {
              return new FromEntriesSequence(this);
            },

            get: function get(searchKey, notSetValue) {
              return this.find(
                function (_, key) {
                  return is(key, searchKey);
                },
                undefined,
                notSetValue
              );
            },

            getIn: getIn$1,

            groupBy: function groupBy(grouper, context) {
              return groupByFactory(this, grouper, context);
            },

            has: function has(searchKey) {
              return this.get(searchKey, NOT_SET) !== NOT_SET;
            },

            hasIn: hasIn$1,

            isSubset: function isSubset(iter) {
              iter =
                typeof iter.includes === "function" ? iter : Collection(iter);
              return this.every(function (value) {
                return iter.includes(value);
              });
            },

            isSuperset: function isSuperset(iter) {
              iter =
                typeof iter.isSubset === "function" ? iter : Collection(iter);
              return iter.isSubset(this);
            },

            keyOf: function keyOf(searchValue) {
              return this.findKey(function (value) {
                return is(value, searchValue);
              });
            },

            keySeq: function keySeq() {
              return this.toSeq().map(keyMapper).toIndexedSeq();
            },

            last: function last(notSetValue) {
              return this.toSeq().reverse().first(notSetValue);
            },

            lastKeyOf: function lastKeyOf(searchValue) {
              return this.toKeyedSeq().reverse().keyOf(searchValue);
            },

            max: function max(comparator) {
              return maxFactory(this, comparator);
            },

            maxBy: function maxBy(mapper, comparator) {
              return maxFactory(this, comparator, mapper);
            },

            min: function min(comparator) {
              return maxFactory(
                this,
                comparator ? neg(comparator) : defaultNegComparator
              );
            },

            minBy: function minBy(mapper, comparator) {
              return maxFactory(
                this,
                comparator ? neg(comparator) : defaultNegComparator,
                mapper
              );
            },

            rest: function rest() {
              return this.slice(1);
            },

            skip: function skip(amount) {
              return amount === 0 ? this : this.slice(Math.max(0, amount));
            },

            skipLast: function skipLast(amount) {
              return amount === 0 ? this : this.slice(0, -Math.max(0, amount));
            },

            skipWhile: function skipWhile(predicate, context) {
              return reify(
                this,
                skipWhileFactory(this, predicate, context, true)
              );
            },

            skipUntil: function skipUntil(predicate, context) {
              return this.skipWhile(not(predicate), context);
            },

            sortBy: function sortBy(mapper, comparator) {
              return reify(this, sortFactory(this, comparator, mapper));
            },

            take: function take(amount) {
              return this.slice(0, Math.max(0, amount));
            },

            takeLast: function takeLast(amount) {
              return this.slice(-Math.max(0, amount));
            },

            takeWhile: function takeWhile(predicate, context) {
              return reify(this, takeWhileFactory(this, predicate, context));
            },

            takeUntil: function takeUntil(predicate, context) {
              return this.takeWhile(not(predicate), context);
            },

            update: function update(fn) {
              return fn(this);
            },

            valueSeq: function valueSeq() {
              return this.toIndexedSeq();
            },

            // ### Hashable Object

            hashCode: function hashCode() {
              return this.__hash || (this.__hash = hashCollection(this));
            },

            // ### Internal

            // abstract __iterate(fn, reverse)

            // abstract __iterator(type, reverse)
          });

          var CollectionPrototype = Collection.prototype;
          CollectionPrototype[IS_COLLECTION_SYMBOL] = true;
          CollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.values;
          CollectionPrototype.toJSON = CollectionPrototype.toArray;
          CollectionPrototype.__toStringMapper = quoteString;
          CollectionPrototype.inspect = CollectionPrototype.toSource = function () {
            return this.toString();
          };
          CollectionPrototype.chain = CollectionPrototype.flatMap;
          CollectionPrototype.contains = CollectionPrototype.includes;

          mixin(KeyedCollection, {
            // ### More sequential methods

            flip: function flip() {
              return reify(this, flipFactory(this));
            },

            mapEntries: function mapEntries(mapper, context) {
              var this$1 = this;

              var iterations = 0;
              return reify(
                this,
                this.toSeq()
                  .map(function (v, k) {
                    return mapper.call(context, [k, v], iterations++, this$1);
                  })
                  .fromEntrySeq()
              );
            },

            mapKeys: function mapKeys(mapper, context) {
              var this$1 = this;

              return reify(
                this,
                this.toSeq()
                  .flip()
                  .map(function (k, v) {
                    return mapper.call(context, k, v, this$1);
                  })
                  .flip()
              );
            },
          });

          var KeyedCollectionPrototype = KeyedCollection.prototype;
          KeyedCollectionPrototype[IS_KEYED_SYMBOL] = true;
          KeyedCollectionPrototype[ITERATOR_SYMBOL] =
            CollectionPrototype.entries;
          KeyedCollectionPrototype.toJSON = toObject;
          KeyedCollectionPrototype.__toStringMapper = function (v, k) {
            return quoteString(k) + ": " + quoteString(v);
          };

          mixin(IndexedCollection, {
            // ### Conversion to other types

            toKeyedSeq: function toKeyedSeq() {
              return new ToKeyedSequence(this, false);
            },

            // ### ES6 Collection methods (ES6 Array and Map)

            filter: function filter(predicate, context) {
              return reify(
                this,
                filterFactory(this, predicate, context, false)
              );
            },

            findIndex: function findIndex(predicate, context) {
              var entry = this.findEntry(predicate, context);
              return entry ? entry[0] : -1;
            },

            indexOf: function indexOf(searchValue) {
              var key = this.keyOf(searchValue);
              return key === undefined ? -1 : key;
            },

            lastIndexOf: function lastIndexOf(searchValue) {
              var key = this.lastKeyOf(searchValue);
              return key === undefined ? -1 : key;
            },

            reverse: function reverse() {
              return reify(this, reverseFactory(this, false));
            },

            slice: function slice(begin, end) {
              return reify(this, sliceFactory(this, begin, end, false));
            },

            splice: function splice(index, removeNum /*, ...values*/) {
              var numArgs = arguments.length;
              removeNum = Math.max(removeNum || 0, 0);
              if (numArgs === 0 || (numArgs === 2 && !removeNum)) {
                return this;
              }
              // If index is negative, it should resolve relative to the size of the
              // collection. However size may be expensive to compute if not cached, so
              // only call count() if the number is in fact negative.
              index = resolveBegin(index, index < 0 ? this.count() : this.size);
              var spliced = this.slice(0, index);
              return reify(
                this,
                numArgs === 1
                  ? spliced
                  : spliced.concat(
                      arrCopy(arguments, 2),
                      this.slice(index + removeNum)
                    )
              );
            },

            // ### More collection methods

            findLastIndex: function findLastIndex(predicate, context) {
              var entry = this.findLastEntry(predicate, context);
              return entry ? entry[0] : -1;
            },

            first: function first(notSetValue) {
              return this.get(0, notSetValue);
            },

            flatten: function flatten(depth) {
              return reify(this, flattenFactory(this, depth, false));
            },

            get: function get(index, notSetValue) {
              index = wrapIndex(this, index);
              return index < 0 ||
                this.size === Infinity ||
                (this.size !== undefined && index > this.size)
                ? notSetValue
                : this.find(
                    function (_, key) {
                      return key === index;
                    },
                    undefined,
                    notSetValue
                  );
            },

            has: function has(index) {
              index = wrapIndex(this, index);
              return (
                index >= 0 &&
                (this.size !== undefined
                  ? this.size === Infinity || index < this.size
                  : this.indexOf(index) !== -1)
              );
            },

            interpose: function interpose(separator) {
              return reify(this, interposeFactory(this, separator));
            },

            interleave: function interleave(/*...collections*/) {
              var collections = [this].concat(arrCopy(arguments));
              var zipped = zipWithFactory(
                this.toSeq(),
                IndexedSeq.of,
                collections
              );
              var interleaved = zipped.flatten(true);
              if (zipped.size) {
                interleaved.size = zipped.size * collections.length;
              }
              return reify(this, interleaved);
            },

            keySeq: function keySeq() {
              return Range(0, this.size);
            },

            last: function last(notSetValue) {
              return this.get(-1, notSetValue);
            },

            skipWhile: function skipWhile(predicate, context) {
              return reify(
                this,
                skipWhileFactory(this, predicate, context, false)
              );
            },

            zip: function zip(/*, ...collections */) {
              var collections = [this].concat(arrCopy(arguments));
              return reify(
                this,
                zipWithFactory(this, defaultZipper, collections)
              );
            },

            zipAll: function zipAll(/*, ...collections */) {
              var collections = [this].concat(arrCopy(arguments));
              return reify(
                this,
                zipWithFactory(this, defaultZipper, collections, true)
              );
            },

            zipWith: function zipWith(zipper /*, ...collections */) {
              var collections = arrCopy(arguments);
              collections[0] = this;
              return reify(this, zipWithFactory(this, zipper, collections));
            },
          });

          var IndexedCollectionPrototype = IndexedCollection.prototype;
          IndexedCollectionPrototype[IS_INDEXED_SYMBOL] = true;
          IndexedCollectionPrototype[IS_ORDERED_SYMBOL] = true;

          mixin(SetCollection, {
            // ### ES6 Collection methods (ES6 Array and Map)

            get: function get(value, notSetValue) {
              return this.has(value) ? value : notSetValue;
            },

            includes: function includes(value) {
              return this.has(value);
            },

            // ### More sequential methods

            keySeq: function keySeq() {
              return this.valueSeq();
            },
          });

          SetCollection.prototype.has = CollectionPrototype.includes;
          SetCollection.prototype.contains = SetCollection.prototype.includes;

          // Mixin subclasses

          mixin(KeyedSeq, KeyedCollection.prototype);
          mixin(IndexedSeq, IndexedCollection.prototype);
          mixin(SetSeq, SetCollection.prototype);

          // #pragma Helper functions

          function reduce(
            collection,
            reducer,
            reduction,
            context,
            useFirst,
            reverse
          ) {
            assertNotInfinite(collection.size);
            collection.__iterate(function (v, k, c) {
              if (useFirst) {
                useFirst = false;
                reduction = v;
              } else {
                reduction = reducer.call(context, reduction, v, k, c);
              }
            }, reverse);
            return reduction;
          }

          function keyMapper(v, k) {
            return k;
          }

          function entryMapper(v, k) {
            return [k, v];
          }

          function not(predicate) {
            return function () {
              return !predicate.apply(this, arguments);
            };
          }

          function neg(predicate) {
            return function () {
              return -predicate.apply(this, arguments);
            };
          }

          function defaultZipper() {
            return arrCopy(arguments);
          }

          function defaultNegComparator(a, b) {
            return a < b ? 1 : a > b ? -1 : 0;
          }

          function hashCollection(collection) {
            if (collection.size === Infinity) {
              return 0;
            }
            var ordered = isOrdered(collection);
            var keyed = isKeyed(collection);
            var h = ordered ? 1 : 0;
            var size = collection.__iterate(
              keyed
                ? ordered
                  ? function (v, k) {
                      h = (31 * h + hashMerge(hash(v), hash(k))) | 0;
                    }
                  : function (v, k) {
                      h = (h + hashMerge(hash(v), hash(k))) | 0;
                    }
                : ordered
                ? function (v) {
                    h = (31 * h + hash(v)) | 0;
                  }
                : function (v) {
                    h = (h + hash(v)) | 0;
                  }
            );
            return murmurHashOfSize(size, h);
          }

          function murmurHashOfSize(size, h) {
            h = imul(h, 0xcc9e2d51);
            h = imul((h << 15) | (h >>> -15), 0x1b873593);
            h = imul((h << 13) | (h >>> -13), 5);
            h = ((h + 0xe6546b64) | 0) ^ size;
            h = imul(h ^ (h >>> 16), 0x85ebca6b);
            h = imul(h ^ (h >>> 13), 0xc2b2ae35);
            h = smi(h ^ (h >>> 16));
            return h;
          }

          function hashMerge(a, b) {
            return (a ^ (b + 0x9e3779b9 + (a << 6) + (a >> 2))) | 0; // int
          }

          var OrderedSet = /*@__PURE__*/ (function (Set$$1) {
            function OrderedSet(value) {
              return value === null || value === undefined
                ? emptyOrderedSet()
                : isOrderedSet(value)
                ? value
                : emptyOrderedSet().withMutations(function (set) {
                    var iter = SetCollection(value);
                    assertNotInfinite(iter.size);
                    iter.forEach(function (v) {
                      return set.add(v);
                    });
                  });
            }

            if (Set$$1) OrderedSet.__proto__ = Set$$1;
            OrderedSet.prototype = Object.create(Set$$1 && Set$$1.prototype);
            OrderedSet.prototype.constructor = OrderedSet;

            OrderedSet.of = function of(/*...values*/) {
              return this(arguments);
            };

            OrderedSet.fromKeys = function fromKeys(value) {
              return this(KeyedCollection(value).keySeq());
            };

            OrderedSet.prototype.toString = function toString() {
              return this.__toString("OrderedSet {", "}");
            };

            return OrderedSet;
          })(Set);

          OrderedSet.isOrderedSet = isOrderedSet;

          var OrderedSetPrototype = OrderedSet.prototype;
          OrderedSetPrototype[IS_ORDERED_SYMBOL] = true;
          OrderedSetPrototype.zip = IndexedCollectionPrototype.zip;
          OrderedSetPrototype.zipWith = IndexedCollectionPrototype.zipWith;

          OrderedSetPrototype.__empty = emptyOrderedSet;
          OrderedSetPrototype.__make = makeOrderedSet;

          function makeOrderedSet(map, ownerID) {
            var set = Object.create(OrderedSetPrototype);
            set.size = map ? map.size : 0;
            set._map = map;
            set.__ownerID = ownerID;
            return set;
          }

          var EMPTY_ORDERED_SET;
          function emptyOrderedSet() {
            return (
              EMPTY_ORDERED_SET ||
              (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()))
            );
          }

          var Record = function Record(defaultValues, name) {
            var hasInitialized;

            var RecordType = function Record(values) {
              var this$1 = this;

              if (values instanceof RecordType) {
                return values;
              }
              if (!(this instanceof RecordType)) {
                return new RecordType(values);
              }
              if (!hasInitialized) {
                hasInitialized = true;
                var keys = Object.keys(defaultValues);
                var indices = (RecordTypePrototype._indices = {});
                // Deprecated: left to attempt not to break any external code which
                // relies on a ._name property existing on record instances.
                // Use Record.getDescriptiveName() instead
                RecordTypePrototype._name = name;
                RecordTypePrototype._keys = keys;
                RecordTypePrototype._defaultValues = defaultValues;
                for (var i = 0; i < keys.length; i++) {
                  var propName = keys[i];
                  indices[propName] = i;
                  if (RecordTypePrototype[propName]) {
                    /* eslint-disable no-console */
                    typeof console === "object" &&
                      console.warn &&
                      console.warn(
                        "Cannot define " +
                          recordName(this) +
                          ' with property "' +
                          propName +
                          '" since that property name is part of the Record API.'
                      );
                    /* eslint-enable no-console */
                  } else {
                    setProp(RecordTypePrototype, propName);
                  }
                }
              }
              this.__ownerID = undefined;
              this._values = List().withMutations(function (l) {
                l.setSize(this$1._keys.length);
                KeyedCollection(values).forEach(function (v, k) {
                  l.set(
                    this$1._indices[k],
                    v === this$1._defaultValues[k] ? undefined : v
                  );
                });
              });
            };

            var RecordTypePrototype = (RecordType.prototype = Object.create(
              RecordPrototype
            ));
            RecordTypePrototype.constructor = RecordType;

            if (name) {
              RecordType.displayName = name;
            }

            return RecordType;
          };

          Record.prototype.toString = function toString() {
            var str = recordName(this) + " { ";
            var keys = this._keys;
            var k;
            for (var i = 0, l = keys.length; i !== l; i++) {
              k = keys[i];
              str += (i ? ", " : "") + k + ": " + quoteString(this.get(k));
            }
            return str + " }";
          };

          Record.prototype.equals = function equals(other) {
            return (
              this === other ||
              (other &&
                this._keys === other._keys &&
                recordSeq(this).equals(recordSeq(other)))
            );
          };

          Record.prototype.hashCode = function hashCode() {
            return recordSeq(this).hashCode();
          };

          // @pragma Access

          Record.prototype.has = function has(k) {
            return this._indices.hasOwnProperty(k);
          };

          Record.prototype.get = function get(k, notSetValue) {
            if (!this.has(k)) {
              return notSetValue;
            }
            var index = this._indices[k];
            var value = this._values.get(index);
            return value === undefined ? this._defaultValues[k] : value;
          };

          // @pragma Modification

          Record.prototype.set = function set(k, v) {
            if (this.has(k)) {
              var newValues = this._values.set(
                this._indices[k],
                v === this._defaultValues[k] ? undefined : v
              );
              if (newValues !== this._values && !this.__ownerID) {
                return makeRecord(this, newValues);
              }
            }
            return this;
          };

          Record.prototype.remove = function remove(k) {
            return this.set(k);
          };

          Record.prototype.clear = function clear() {
            var newValues = this._values.clear().setSize(this._keys.length);
            return this.__ownerID ? this : makeRecord(this, newValues);
          };

          Record.prototype.wasAltered = function wasAltered() {
            return this._values.wasAltered();
          };

          Record.prototype.toSeq = function toSeq() {
            return recordSeq(this);
          };

          Record.prototype.toJS = function toJS$1() {
            return toJS(this);
          };

          Record.prototype.entries = function entries() {
            return this.__iterator(ITERATE_ENTRIES);
          };

          Record.prototype.__iterator = function __iterator(type, reverse) {
            return recordSeq(this).__iterator(type, reverse);
          };

          Record.prototype.__iterate = function __iterate(fn, reverse) {
            return recordSeq(this).__iterate(fn, reverse);
          };

          Record.prototype.__ensureOwner = function __ensureOwner(ownerID) {
            if (ownerID === this.__ownerID) {
              return this;
            }
            var newValues = this._values.__ensureOwner(ownerID);
            if (!ownerID) {
              this.__ownerID = ownerID;
              this._values = newValues;
              return this;
            }
            return makeRecord(this, newValues, ownerID);
          };

          Record.isRecord = isRecord;
          Record.getDescriptiveName = recordName;
          var RecordPrototype = Record.prototype;
          RecordPrototype[IS_RECORD_SYMBOL] = true;
          RecordPrototype[DELETE] = RecordPrototype.remove;
          RecordPrototype.deleteIn = RecordPrototype.removeIn = deleteIn;
          RecordPrototype.getIn = getIn$1;
          RecordPrototype.hasIn = CollectionPrototype.hasIn;
          RecordPrototype.merge = merge;
          RecordPrototype.mergeWith = mergeWith;
          RecordPrototype.mergeIn = mergeIn;
          RecordPrototype.mergeDeep = mergeDeep$1;
          RecordPrototype.mergeDeepWith = mergeDeepWith$1;
          RecordPrototype.mergeDeepIn = mergeDeepIn;
          RecordPrototype.setIn = setIn$1;
          RecordPrototype.update = update$1;
          RecordPrototype.updateIn = updateIn$1;
          RecordPrototype.withMutations = withMutations;
          RecordPrototype.asMutable = asMutable;
          RecordPrototype.asImmutable = asImmutable;
          RecordPrototype[ITERATOR_SYMBOL] = RecordPrototype.entries;
          RecordPrototype.toJSON = RecordPrototype.toObject =
            CollectionPrototype.toObject;
          RecordPrototype.inspect = RecordPrototype.toSource = function () {
            return this.toString();
          };

          function makeRecord(likeRecord, values, ownerID) {
            var record = Object.create(Object.getPrototypeOf(likeRecord));
            record._values = values;
            record.__ownerID = ownerID;
            return record;
          }

          function recordName(record) {
            return (
              record.constructor.displayName ||
              record.constructor.name ||
              "Record"
            );
          }

          function recordSeq(record) {
            return keyedSeqFromValue(
              record._keys.map(function (k) {
                return [k, record.get(k)];
              })
            );
          }

          function setProp(prototype, name) {
            try {
              Object.defineProperty(prototype, name, {
                get: function () {
                  return this.get(name);
                },
                set: function (value) {
                  invariant(
                    this.__ownerID,
                    "Cannot set on an immutable record."
                  );
                  this.set(name, value);
                },
              });
            } catch (error) {
              // Object.defineProperty failed. Probably IE8.
            }
          }

          /**
           * Returns a lazy Seq of `value` repeated `times` times. When `times` is
           * undefined, returns an infinite sequence of `value`.
           */
          var Repeat = /*@__PURE__*/ (function (IndexedSeq$$1) {
            function Repeat(value, times) {
              if (!(this instanceof Repeat)) {
                return new Repeat(value, times);
              }
              this._value = value;
              this.size = times === undefined ? Infinity : Math.max(0, times);
              if (this.size === 0) {
                if (EMPTY_REPEAT) {
                  return EMPTY_REPEAT;
                }
                EMPTY_REPEAT = this;
              }
            }

            if (IndexedSeq$$1) Repeat.__proto__ = IndexedSeq$$1;
            Repeat.prototype = Object.create(
              IndexedSeq$$1 && IndexedSeq$$1.prototype
            );
            Repeat.prototype.constructor = Repeat;

            Repeat.prototype.toString = function toString() {
              if (this.size === 0) {
                return "Repeat []";
              }
              return "Repeat [ " + this._value + " " + this.size + " times ]";
            };

            Repeat.prototype.get = function get(index, notSetValue) {
              return this.has(index) ? this._value : notSetValue;
            };

            Repeat.prototype.includes = function includes(searchValue) {
              return is(this._value, searchValue);
            };

            Repeat.prototype.slice = function slice(begin, end) {
              var size = this.size;
              return wholeSlice(begin, end, size)
                ? this
                : new Repeat(
                    this._value,
                    resolveEnd(end, size) - resolveBegin(begin, size)
                  );
            };

            Repeat.prototype.reverse = function reverse() {
              return this;
            };

            Repeat.prototype.indexOf = function indexOf(searchValue) {
              if (is(this._value, searchValue)) {
                return 0;
              }
              return -1;
            };

            Repeat.prototype.lastIndexOf = function lastIndexOf(searchValue) {
              if (is(this._value, searchValue)) {
                return this.size;
              }
              return -1;
            };

            Repeat.prototype.__iterate = function __iterate(fn, reverse) {
              var size = this.size;
              var i = 0;
              while (i !== size) {
                if (
                  fn(this._value, reverse ? size - ++i : i++, this) === false
                ) {
                  break;
                }
              }
              return i;
            };

            Repeat.prototype.__iterator = function __iterator(type, reverse) {
              var this$1 = this;

              var size = this.size;
              var i = 0;
              return new Iterator(function () {
                return i === size
                  ? iteratorDone()
                  : iteratorValue(
                      type,
                      reverse ? size - ++i : i++,
                      this$1._value
                    );
              });
            };

            Repeat.prototype.equals = function equals(other) {
              return other instanceof Repeat
                ? is(this._value, other._value)
                : deepEqual(other);
            };

            return Repeat;
          })(IndexedSeq);

          var EMPTY_REPEAT;

          function fromJS(value, converter) {
            return fromJSWith(
              [],
              converter || defaultConverter,
              value,
              "",
              converter && converter.length > 2 ? [] : undefined,
              { "": value }
            );
          }

          function fromJSWith(
            stack,
            converter,
            value,
            key,
            keyPath,
            parentValue
          ) {
            var toSeq = Array.isArray(value)
              ? IndexedSeq
              : isPlainObj(value)
              ? KeyedSeq
              : null;
            if (toSeq) {
              if (~stack.indexOf(value)) {
                throw new TypeError(
                  "Cannot convert circular structure to Immutable"
                );
              }
              stack.push(value);
              keyPath && key !== "" && keyPath.push(key);
              var converted = converter.call(
                parentValue,
                key,
                toSeq(value).map(function (v, k) {
                  return fromJSWith(stack, converter, v, k, keyPath, value);
                }),
                keyPath && keyPath.slice()
              );
              stack.pop();
              keyPath && keyPath.pop();
              return converted;
            }
            return value;
          }

          function defaultConverter(k, v) {
            return isKeyed(v) ? v.toMap() : v.toList();
          }

          var version = "4.0.0-rc.11";

          var Immutable = {
            version: version,

            Collection: Collection,
            // Note: Iterable is deprecated
            Iterable: Collection,

            Seq: Seq,
            Map: Map,
            OrderedMap: OrderedMap,
            List: List,
            Stack: Stack,
            Set: Set,
            OrderedSet: OrderedSet,

            Record: Record,
            Range: Range,
            Repeat: Repeat,

            is: is,
            fromJS: fromJS,
            hash: hash,

            isImmutable: isImmutable,
            isCollection: isCollection,
            isKeyed: isKeyed,
            isIndexed: isIndexed,
            isAssociative: isAssociative,
            isOrdered: isOrdered,
            isValueObject: isValueObject,
            isSeq: isSeq,
            isList: isList,
            isMap: isMap,
            isOrderedMap: isOrderedMap,
            isStack: isStack,
            isSet: isSet,
            isOrderedSet: isOrderedSet,
            isRecord: isRecord,

            get: get,
            getIn: getIn,
            has: has,
            hasIn: hasIn,
            merge: merge$1,
            mergeDeep: mergeDeep,
            mergeWith: mergeWith$1,
            mergeDeepWith: mergeDeepWith,
            remove: remove,
            removeIn: removeIn,
            set: set,
            setIn: setIn,
            update: update,
            updateIn: updateIn,
          };

          // Note: Iterable is deprecated
          var Iterable = Collection;

          exports.default = Immutable;
          exports.version = version;
          exports.Collection = Collection;
          exports.Iterable = Iterable;
          exports.Seq = Seq;
          exports.Map = Map;
          exports.OrderedMap = OrderedMap;
          exports.List = List;
          exports.Stack = Stack;
          exports.Set = Set;
          exports.OrderedSet = OrderedSet;
          exports.Record = Record;
          exports.Range = Range;
          exports.Repeat = Repeat;
          exports.is = is;
          exports.fromJS = fromJS;
          exports.hash = hash;
          exports.isImmutable = isImmutable;
          exports.isCollection = isCollection;
          exports.isKeyed = isKeyed;
          exports.isIndexed = isIndexed;
          exports.isAssociative = isAssociative;
          exports.isOrdered = isOrdered;
          exports.isValueObject = isValueObject;
          exports.get = get;
          exports.getIn = getIn;
          exports.has = has;
          exports.hasIn = hasIn;
          exports.merge = merge$1;
          exports.mergeDeep = mergeDeep;
          exports.mergeWith = mergeWith$1;
          exports.mergeDeepWith = mergeDeepWith;
          exports.remove = remove;
          exports.removeIn = removeIn;
          exports.set = set;
          exports.setIn = setIn;
          exports.update = update;
          exports.updateIn = updateIn;

          Object.defineProperty(exports, "__esModule", { value: true });
        });
      },
      {},
    ],
    4: [
      function (require, module, exports) {
        (function (global) {
          (function () {
            /**
             * @license
             * Lodash <https://lodash.com/>
             * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
             * Released under MIT license <https://lodash.com/license>
             * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
             * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
             */
            (function () {
              /** Used as a safe reference for `undefined` in pre-ES5 environments. */
              var undefined;

              /** Used as the semantic version number. */
              var VERSION = "4.17.20";

              /** Used as the size to enable large array optimizations. */
              var LARGE_ARRAY_SIZE = 200;

              /** Error message constants. */
              var CORE_ERROR_TEXT =
                  "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.",
                FUNC_ERROR_TEXT = "Expected a function";

              /** Used to stand-in for `undefined` hash values. */
              var HASH_UNDEFINED = "__lodash_hash_undefined__";

              /** Used as the maximum memoize cache size. */
              var MAX_MEMOIZE_SIZE = 500;

              /** Used as the internal argument placeholder. */
              var PLACEHOLDER = "__lodash_placeholder__";

              /** Used to compose bitmasks for cloning. */
              var CLONE_DEEP_FLAG = 1,
                CLONE_FLAT_FLAG = 2,
                CLONE_SYMBOLS_FLAG = 4;

              /** Used to compose bitmasks for value comparisons. */
              var COMPARE_PARTIAL_FLAG = 1,
                COMPARE_UNORDERED_FLAG = 2;

              /** Used to compose bitmasks for function metadata. */
              var WRAP_BIND_FLAG = 1,
                WRAP_BIND_KEY_FLAG = 2,
                WRAP_CURRY_BOUND_FLAG = 4,
                WRAP_CURRY_FLAG = 8,
                WRAP_CURRY_RIGHT_FLAG = 16,
                WRAP_PARTIAL_FLAG = 32,
                WRAP_PARTIAL_RIGHT_FLAG = 64,
                WRAP_ARY_FLAG = 128,
                WRAP_REARG_FLAG = 256,
                WRAP_FLIP_FLAG = 512;

              /** Used as default options for `_.truncate`. */
              var DEFAULT_TRUNC_LENGTH = 30,
                DEFAULT_TRUNC_OMISSION = "...";

              /** Used to detect hot functions by number of calls within a span of milliseconds. */
              var HOT_COUNT = 800,
                HOT_SPAN = 16;

              /** Used to indicate the type of lazy iteratees. */
              var LAZY_FILTER_FLAG = 1,
                LAZY_MAP_FLAG = 2,
                LAZY_WHILE_FLAG = 3;

              /** Used as references for various `Number` constants. */
              var INFINITY = 1 / 0,
                MAX_SAFE_INTEGER = 9007199254740991,
                MAX_INTEGER = 1.7976931348623157e308,
                NAN = 0 / 0;

              /** Used as references for the maximum length and index of an array. */
              var MAX_ARRAY_LENGTH = 4294967295,
                MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
                HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

              /** Used to associate wrap methods with their bit flags. */
              var wrapFlags = [
                ["ary", WRAP_ARY_FLAG],
                ["bind", WRAP_BIND_FLAG],
                ["bindKey", WRAP_BIND_KEY_FLAG],
                ["curry", WRAP_CURRY_FLAG],
                ["curryRight", WRAP_CURRY_RIGHT_FLAG],
                ["flip", WRAP_FLIP_FLAG],
                ["partial", WRAP_PARTIAL_FLAG],
                ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
                ["rearg", WRAP_REARG_FLAG],
              ];

              /** `Object#toString` result references. */
              var argsTag = "[object Arguments]",
                arrayTag = "[object Array]",
                asyncTag = "[object AsyncFunction]",
                boolTag = "[object Boolean]",
                dateTag = "[object Date]",
                domExcTag = "[object DOMException]",
                errorTag = "[object Error]",
                funcTag = "[object Function]",
                genTag = "[object GeneratorFunction]",
                mapTag = "[object Map]",
                numberTag = "[object Number]",
                nullTag = "[object Null]",
                objectTag = "[object Object]",
                promiseTag = "[object Promise]",
                proxyTag = "[object Proxy]",
                regexpTag = "[object RegExp]",
                setTag = "[object Set]",
                stringTag = "[object String]",
                symbolTag = "[object Symbol]",
                undefinedTag = "[object Undefined]",
                weakMapTag = "[object WeakMap]",
                weakSetTag = "[object WeakSet]";

              var arrayBufferTag = "[object ArrayBuffer]",
                dataViewTag = "[object DataView]",
                float32Tag = "[object Float32Array]",
                float64Tag = "[object Float64Array]",
                int8Tag = "[object Int8Array]",
                int16Tag = "[object Int16Array]",
                int32Tag = "[object Int32Array]",
                uint8Tag = "[object Uint8Array]",
                uint8ClampedTag = "[object Uint8ClampedArray]",
                uint16Tag = "[object Uint16Array]",
                uint32Tag = "[object Uint32Array]";

              /** Used to match empty string literals in compiled template source. */
              var reEmptyStringLeading = /\b__p \+= '';/g,
                reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
                reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

              /** Used to match HTML entities and HTML characters. */
              var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
                reUnescapedHtml = /[&<>"']/g,
                reHasEscapedHtml = RegExp(reEscapedHtml.source),
                reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

              /** Used to match template delimiters. */
              var reEscape = /<%-([\s\S]+?)%>/g,
                reEvaluate = /<%([\s\S]+?)%>/g,
                reInterpolate = /<%=([\s\S]+?)%>/g;

              /** Used to match property names within property paths. */
              var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
                reIsPlainProp = /^\w*$/,
                rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

              /**
               * Used to match `RegExp`
               * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
               */
              var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
                reHasRegExpChar = RegExp(reRegExpChar.source);

              /** Used to match leading and trailing whitespace. */
              var reTrim = /^\s+|\s+$/g,
                reTrimStart = /^\s+/,
                reTrimEnd = /\s+$/;

              /** Used to match wrap detail comments. */
              var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
                reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
                reSplitDetails = /,? & /;

              /** Used to match words composed of alphanumeric characters. */
              var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

              /** Used to match backslashes in property paths. */
              var reEscapeChar = /\\(\\)?/g;

              /**
               * Used to match
               * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
               */
              var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

              /** Used to match `RegExp` flags from their coerced string values. */
              var reFlags = /\w*$/;

              /** Used to detect bad signed hexadecimal string values. */
              var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

              /** Used to detect binary string values. */
              var reIsBinary = /^0b[01]+$/i;

              /** Used to detect host constructors (Safari). */
              var reIsHostCtor = /^\[object .+?Constructor\]$/;

              /** Used to detect octal string values. */
              var reIsOctal = /^0o[0-7]+$/i;

              /** Used to detect unsigned integer values. */
              var reIsUint = /^(?:0|[1-9]\d*)$/;

              /** Used to match Latin Unicode letters (excluding mathematical operators). */
              var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

              /** Used to ensure capturing order of template delimiters. */
              var reNoMatch = /($^)/;

              /** Used to match unescaped characters in compiled string literals. */
              var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

              /** Used to compose unicode character classes. */
              var rsAstralRange = "\\ud800-\\udfff",
                rsComboMarksRange = "\\u0300-\\u036f",
                reComboHalfMarksRange = "\\ufe20-\\ufe2f",
                rsComboSymbolsRange = "\\u20d0-\\u20ff",
                rsComboRange =
                  rsComboMarksRange +
                  reComboHalfMarksRange +
                  rsComboSymbolsRange,
                rsDingbatRange = "\\u2700-\\u27bf",
                rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff",
                rsMathOpRange = "\\xac\\xb1\\xd7\\xf7",
                rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf",
                rsPunctuationRange = "\\u2000-\\u206f",
                rsSpaceRange =
                  " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",
                rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde",
                rsVarRange = "\\ufe0e\\ufe0f",
                rsBreakRange =
                  rsMathOpRange +
                  rsNonCharRange +
                  rsPunctuationRange +
                  rsSpaceRange;

              /** Used to compose unicode capture groups. */
              var rsApos = "['\u2019]",
                rsAstral = "[" + rsAstralRange + "]",
                rsBreak = "[" + rsBreakRange + "]",
                rsCombo = "[" + rsComboRange + "]",
                rsDigits = "\\d+",
                rsDingbat = "[" + rsDingbatRange + "]",
                rsLower = "[" + rsLowerRange + "]",
                rsMisc =
                  "[^" +
                  rsAstralRange +
                  rsBreakRange +
                  rsDigits +
                  rsDingbatRange +
                  rsLowerRange +
                  rsUpperRange +
                  "]",
                rsFitz = "\\ud83c[\\udffb-\\udfff]",
                rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")",
                rsNonAstral = "[^" + rsAstralRange + "]",
                rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}",
                rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]",
                rsUpper = "[" + rsUpperRange + "]",
                rsZWJ = "\\u200d";

              /** Used to compose unicode regexes. */
              var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")",
                rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")",
                rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?",
                rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?",
                reOptMod = rsModifier + "?",
                rsOptVar = "[" + rsVarRange + "]?",
                rsOptJoin =
                  "(?:" +
                  rsZWJ +
                  "(?:" +
                  [rsNonAstral, rsRegional, rsSurrPair].join("|") +
                  ")" +
                  rsOptVar +
                  reOptMod +
                  ")*",
                rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])",
                rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])",
                rsSeq = rsOptVar + reOptMod + rsOptJoin,
                rsEmoji =
                  "(?:" +
                  [rsDingbat, rsRegional, rsSurrPair].join("|") +
                  ")" +
                  rsSeq,
                rsSymbol =
                  "(?:" +
                  [
                    rsNonAstral + rsCombo + "?",
                    rsCombo,
                    rsRegional,
                    rsSurrPair,
                    rsAstral,
                  ].join("|") +
                  ")";

              /** Used to match apostrophes. */
              var reApos = RegExp(rsApos, "g");

              /**
               * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
               * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
               */
              var reComboMark = RegExp(rsCombo, "g");

              /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
              var reUnicode = RegExp(
                rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq,
                "g"
              );

              /** Used to match complex or compound words. */
              var reUnicodeWord = RegExp(
                [
                  rsUpper +
                    "?" +
                    rsLower +
                    "+" +
                    rsOptContrLower +
                    "(?=" +
                    [rsBreak, rsUpper, "$"].join("|") +
                    ")",
                  rsMiscUpper +
                    "+" +
                    rsOptContrUpper +
                    "(?=" +
                    [rsBreak, rsUpper + rsMiscLower, "$"].join("|") +
                    ")",
                  rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
                  rsUpper + "+" + rsOptContrUpper,
                  rsOrdUpper,
                  rsOrdLower,
                  rsDigits,
                  rsEmoji,
                ].join("|"),
                "g"
              );

              /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
              var reHasUnicode = RegExp(
                "[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]"
              );

              /** Used to detect strings that need a more robust regexp to match words. */
              var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

              /** Used to assign default `context` object properties. */
              var contextProps = [
                "Array",
                "Buffer",
                "DataView",
                "Date",
                "Error",
                "Float32Array",
                "Float64Array",
                "Function",
                "Int8Array",
                "Int16Array",
                "Int32Array",
                "Map",
                "Math",
                "Object",
                "Promise",
                "RegExp",
                "Set",
                "String",
                "Symbol",
                "TypeError",
                "Uint8Array",
                "Uint8ClampedArray",
                "Uint16Array",
                "Uint32Array",
                "WeakMap",
                "_",
                "clearTimeout",
                "isFinite",
                "parseInt",
                "setTimeout",
              ];

              /** Used to make template sourceURLs easier to identify. */
              var templateCounter = -1;

              /** Used to identify `toStringTag` values of typed arrays. */
              var typedArrayTags = {};
              typedArrayTags[float32Tag] = typedArrayTags[
                float64Tag
              ] = typedArrayTags[int8Tag] = typedArrayTags[
                int16Tag
              ] = typedArrayTags[int32Tag] = typedArrayTags[
                uint8Tag
              ] = typedArrayTags[uint8ClampedTag] = typedArrayTags[
                uint16Tag
              ] = typedArrayTags[uint32Tag] = true;
              typedArrayTags[argsTag] = typedArrayTags[
                arrayTag
              ] = typedArrayTags[arrayBufferTag] = typedArrayTags[
                boolTag
              ] = typedArrayTags[dataViewTag] = typedArrayTags[
                dateTag
              ] = typedArrayTags[errorTag] = typedArrayTags[
                funcTag
              ] = typedArrayTags[mapTag] = typedArrayTags[
                numberTag
              ] = typedArrayTags[objectTag] = typedArrayTags[
                regexpTag
              ] = typedArrayTags[setTag] = typedArrayTags[
                stringTag
              ] = typedArrayTags[weakMapTag] = false;

              /** Used to identify `toStringTag` values supported by `_.clone`. */
              var cloneableTags = {};
              cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[
                arrayBufferTag
              ] = cloneableTags[dataViewTag] = cloneableTags[
                boolTag
              ] = cloneableTags[dateTag] = cloneableTags[
                float32Tag
              ] = cloneableTags[float64Tag] = cloneableTags[
                int8Tag
              ] = cloneableTags[int16Tag] = cloneableTags[
                int32Tag
              ] = cloneableTags[mapTag] = cloneableTags[
                numberTag
              ] = cloneableTags[objectTag] = cloneableTags[
                regexpTag
              ] = cloneableTags[setTag] = cloneableTags[
                stringTag
              ] = cloneableTags[symbolTag] = cloneableTags[
                uint8Tag
              ] = cloneableTags[uint8ClampedTag] = cloneableTags[
                uint16Tag
              ] = cloneableTags[uint32Tag] = true;
              cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[
                weakMapTag
              ] = false;

              /** Used to map Latin Unicode letters to basic Latin letters. */
              var deburredLetters = {
                // Latin-1 Supplement block.
                "\xc0": "A",
                "\xc1": "A",
                "\xc2": "A",
                "\xc3": "A",
                "\xc4": "A",
                "\xc5": "A",
                "\xe0": "a",
                "\xe1": "a",
                "\xe2": "a",
                "\xe3": "a",
                "\xe4": "a",
                "\xe5": "a",
                "\xc7": "C",
                "\xe7": "c",
                "\xd0": "D",
                "\xf0": "d",
                "\xc8": "E",
                "\xc9": "E",
                "\xca": "E",
                "\xcb": "E",
                "\xe8": "e",
                "\xe9": "e",
                "\xea": "e",
                "\xeb": "e",
                "\xcc": "I",
                "\xcd": "I",
                "\xce": "I",
                "\xcf": "I",
                "\xec": "i",
                "\xed": "i",
                "\xee": "i",
                "\xef": "i",
                "\xd1": "N",
                "\xf1": "n",
                "\xd2": "O",
                "\xd3": "O",
                "\xd4": "O",
                "\xd5": "O",
                "\xd6": "O",
                "\xd8": "O",
                "\xf2": "o",
                "\xf3": "o",
                "\xf4": "o",
                "\xf5": "o",
                "\xf6": "o",
                "\xf8": "o",
                "\xd9": "U",
                "\xda": "U",
                "\xdb": "U",
                "\xdc": "U",
                "\xf9": "u",
                "\xfa": "u",
                "\xfb": "u",
                "\xfc": "u",
                "\xdd": "Y",
                "\xfd": "y",
                "\xff": "y",
                "\xc6": "Ae",
                "\xe6": "ae",
                "\xde": "Th",
                "\xfe": "th",
                "\xdf": "ss",
                // Latin Extended-A block.
                "\u0100": "A",
                "\u0102": "A",
                "\u0104": "A",
                "\u0101": "a",
                "\u0103": "a",
                "\u0105": "a",
                "\u0106": "C",
                "\u0108": "C",
                "\u010a": "C",
                "\u010c": "C",
                "\u0107": "c",
                "\u0109": "c",
                "\u010b": "c",
                "\u010d": "c",
                "\u010e": "D",
                "\u0110": "D",
                "\u010f": "d",
                "\u0111": "d",
                "\u0112": "E",
                "\u0114": "E",
                "\u0116": "E",
                "\u0118": "E",
                "\u011a": "E",
                "\u0113": "e",
                "\u0115": "e",
                "\u0117": "e",
                "\u0119": "e",
                "\u011b": "e",
                "\u011c": "G",
                "\u011e": "G",
                "\u0120": "G",
                "\u0122": "G",
                "\u011d": "g",
                "\u011f": "g",
                "\u0121": "g",
                "\u0123": "g",
                "\u0124": "H",
                "\u0126": "H",
                "\u0125": "h",
                "\u0127": "h",
                "\u0128": "I",
                "\u012a": "I",
                "\u012c": "I",
                "\u012e": "I",
                "\u0130": "I",
                "\u0129": "i",
                "\u012b": "i",
                "\u012d": "i",
                "\u012f": "i",
                "\u0131": "i",
                "\u0134": "J",
                "\u0135": "j",
                "\u0136": "K",
                "\u0137": "k",
                "\u0138": "k",
                "\u0139": "L",
                "\u013b": "L",
                "\u013d": "L",
                "\u013f": "L",
                "\u0141": "L",
                "\u013a": "l",
                "\u013c": "l",
                "\u013e": "l",
                "\u0140": "l",
                "\u0142": "l",
                "\u0143": "N",
                "\u0145": "N",
                "\u0147": "N",
                "\u014a": "N",
                "\u0144": "n",
                "\u0146": "n",
                "\u0148": "n",
                "\u014b": "n",
                "\u014c": "O",
                "\u014e": "O",
                "\u0150": "O",
                "\u014d": "o",
                "\u014f": "o",
                "\u0151": "o",
                "\u0154": "R",
                "\u0156": "R",
                "\u0158": "R",
                "\u0155": "r",
                "\u0157": "r",
                "\u0159": "r",
                "\u015a": "S",
                "\u015c": "S",
                "\u015e": "S",
                "\u0160": "S",
                "\u015b": "s",
                "\u015d": "s",
                "\u015f": "s",
                "\u0161": "s",
                "\u0162": "T",
                "\u0164": "T",
                "\u0166": "T",
                "\u0163": "t",
                "\u0165": "t",
                "\u0167": "t",
                "\u0168": "U",
                "\u016a": "U",
                "\u016c": "U",
                "\u016e": "U",
                "\u0170": "U",
                "\u0172": "U",
                "\u0169": "u",
                "\u016b": "u",
                "\u016d": "u",
                "\u016f": "u",
                "\u0171": "u",
                "\u0173": "u",
                "\u0174": "W",
                "\u0175": "w",
                "\u0176": "Y",
                "\u0177": "y",
                "\u0178": "Y",
                "\u0179": "Z",
                "\u017b": "Z",
                "\u017d": "Z",
                "\u017a": "z",
                "\u017c": "z",
                "\u017e": "z",
                "\u0132": "IJ",
                "\u0133": "ij",
                "\u0152": "Oe",
                "\u0153": "oe",
                "\u0149": "'n",
                "\u017f": "s",
              };

              /** Used to map characters to HTML entities. */
              var htmlEscapes = {
                "&": "&amp;",
                "<": "&lt;",
                ">": "&gt;",
                '"': "&quot;",
                "'": "&#39;",
              };

              /** Used to map HTML entities to characters. */
              var htmlUnescapes = {
                "&amp;": "&",
                "&lt;": "<",
                "&gt;": ">",
                "&quot;": '"',
                "&#39;": "'",
              };

              /** Used to escape characters for inclusion in compiled string literals. */
              var stringEscapes = {
                "\\": "\\",
                "'": "'",
                "\n": "n",
                "\r": "r",
                "\u2028": "u2028",
                "\u2029": "u2029",
              };

              /** Built-in method references without a dependency on `root`. */
              var freeParseFloat = parseFloat,
                freeParseInt = parseInt;

              /** Detect free variable `global` from Node.js. */
              var freeGlobal =
                typeof global == "object" &&
                global &&
                global.Object === Object &&
                global;

              /** Detect free variable `self`. */
              var freeSelf =
                typeof self == "object" &&
                self &&
                self.Object === Object &&
                self;

              /** Used as a reference to the global object. */
              var root = freeGlobal || freeSelf || Function("return this")();

              /** Detect free variable `exports`. */
              var freeExports =
                typeof exports == "object" &&
                exports &&
                !exports.nodeType &&
                exports;

              /** Detect free variable `module`. */
              var freeModule =
                freeExports &&
                typeof module == "object" &&
                module &&
                !module.nodeType &&
                module;

              /** Detect the popular CommonJS extension `module.exports`. */
              var moduleExports =
                freeModule && freeModule.exports === freeExports;

              /** Detect free variable `process` from Node.js. */
              var freeProcess = moduleExports && freeGlobal.process;

              /** Used to access faster Node.js helpers. */
              var nodeUtil = (function () {
                try {
                  // Use `util.types` for Node.js 10+.
                  var types =
                    freeModule &&
                    freeModule.require &&
                    freeModule.require("util").types;

                  if (types) {
                    return types;
                  }

                  // Legacy `process.binding('util')` for Node.js < 10.
                  return (
                    freeProcess &&
                    freeProcess.binding &&
                    freeProcess.binding("util")
                  );
                } catch (e) {}
              })();

              /* Node.js helper references. */
              var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,
                nodeIsDate = nodeUtil && nodeUtil.isDate,
                nodeIsMap = nodeUtil && nodeUtil.isMap,
                nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,
                nodeIsSet = nodeUtil && nodeUtil.isSet,
                nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

              /*--------------------------------------------------------------------------*/

              /**
               * A faster alternative to `Function#apply`, this function invokes `func`
               * with the `this` binding of `thisArg` and the arguments of `args`.
               *
               * @private
               * @param {Function} func The function to invoke.
               * @param {*} thisArg The `this` binding of `func`.
               * @param {Array} args The arguments to invoke `func` with.
               * @returns {*} Returns the result of `func`.
               */
              function apply(func, thisArg, args) {
                switch (args.length) {
                  case 0:
                    return func.call(thisArg);
                  case 1:
                    return func.call(thisArg, args[0]);
                  case 2:
                    return func.call(thisArg, args[0], args[1]);
                  case 3:
                    return func.call(thisArg, args[0], args[1], args[2]);
                }
                return func.apply(thisArg, args);
              }

              /**
               * A specialized version of `baseAggregator` for arrays.
               *
               * @private
               * @param {Array} [array] The array to iterate over.
               * @param {Function} setter The function to set `accumulator` values.
               * @param {Function} iteratee The iteratee to transform keys.
               * @param {Object} accumulator The initial aggregated object.
               * @returns {Function} Returns `accumulator`.
               */
              function arrayAggregator(array, setter, iteratee, accumulator) {
                var index = -1,
                  length = array == null ? 0 : array.length;

                while (++index < length) {
                  var value = array[index];
                  setter(accumulator, value, iteratee(value), array);
                }
                return accumulator;
              }

              /**
               * A specialized version of `_.forEach` for arrays without support for
               * iteratee shorthands.
               *
               * @private
               * @param {Array} [array] The array to iterate over.
               * @param {Function} iteratee The function invoked per iteration.
               * @returns {Array} Returns `array`.
               */
              function arrayEach(array, iteratee) {
                var index = -1,
                  length = array == null ? 0 : array.length;

                while (++index < length) {
                  if (iteratee(array[index], index, array) === false) {
                    break;
                  }
                }
                return array;
              }

              /**
               * A specialized version of `_.forEachRight` for arrays without support for
               * iteratee shorthands.
               *
               * @private
               * @param {Array} [array] The array to iterate over.
               * @param {Function} iteratee The function invoked per iteration.
               * @returns {Array} Returns `array`.
               */
              function arrayEachRight(array, iteratee) {
                var length = array == null ? 0 : array.length;

                while (length--) {
                  if (iteratee(array[length], length, array) === false) {
                    break;
                  }
                }
                return array;
              }

              /**
               * A specialized version of `_.every` for arrays without support for
               * iteratee shorthands.
               *
               * @private
               * @param {Array} [array] The array to iterate over.
               * @param {Function} predicate The function invoked per iteration.
               * @returns {boolean} Returns `true` if all elements pass the predicate check,
               *  else `false`.
               */
              function arrayEvery(array, predicate) {
                var index = -1,
                  length = array == null ? 0 : array.length;

                while (++index < length) {
                  if (!predicate(array[index], index, array)) {
                    return false;
                  }
                }
                return true;
              }

              /**
               * A specialized version of `_.filter` for arrays without support for
               * iteratee shorthands.
               *
               * @private
               * @param {Array} [array] The array to iterate over.
               * @param {Function} predicate The function invoked per iteration.
               * @returns {Array} Returns the new filtered array.
               */
              function arrayFilter(array, predicate) {
                var index = -1,
                  length = array == null ? 0 : array.length,
                  resIndex = 0,
                  result = [];

                while (++index < length) {
                  var value = array[index];
                  if (predicate(value, index, array)) {
                    result[resIndex++] = value;
                  }
                }
                return result;
              }

              /**
               * A specialized version of `_.includes` for arrays without support for
               * specifying an index to search from.
               *
               * @private
               * @param {Array} [array] The array to inspect.
               * @param {*} target The value to search for.
               * @returns {boolean} Returns `true` if `target` is found, else `false`.
               */
              function arrayIncludes(array, value) {
                var length = array == null ? 0 : array.length;
                return !!length && baseIndexOf(array, value, 0) > -1;
              }

              /**
               * This function is like `arrayIncludes` except that it accepts a comparator.
               *
               * @private
               * @param {Array} [array] The array to inspect.
               * @param {*} target The value to search for.
               * @param {Function} comparator The comparator invoked per element.
               * @returns {boolean} Returns `true` if `target` is found, else `false`.
               */
              function arrayIncludesWith(array, value, comparator) {
                var index = -1,
                  length = array == null ? 0 : array.length;

                while (++index < length) {
                  if (comparator(value, array[index])) {
                    return true;
                  }
                }
                return false;
              }

              /**
               * A specialized version of `_.map` for arrays without support for iteratee
               * shorthands.
               *
               * @private
               * @param {Array} [array] The array to iterate over.
               * @param {Function} iteratee The function invoked per iteration.
               * @returns {Array} Returns the new mapped array.
               */
              function arrayMap(array, iteratee) {
                var index = -1,
                  length = array == null ? 0 : array.length,
                  result = Array(length);

                while (++index < length) {
                  result[index] = iteratee(array[index], index, array);
                }
                return result;
              }

              /**
               * Appends the elements of `values` to `array`.
               *
               * @private
               * @param {Array} array The array to modify.
               * @param {Array} values The values to append.
               * @returns {Array} Returns `array`.
               */
              function arrayPush(array, values) {
                var index = -1,
                  length = values.length,
                  offset = array.length;

                while (++index < length) {
                  array[offset + index] = values[index];
                }
                return array;
              }

              /**
               * A specialized version of `_.reduce` for arrays without support for
               * iteratee shorthands.
               *
               * @private
               * @param {Array} [array] The array to iterate over.
               * @param {Function} iteratee The function invoked per iteration.
               * @param {*} [accumulator] The initial value.
               * @param {boolean} [initAccum] Specify using the first element of `array` as
               *  the initial value.
               * @returns {*} Returns the accumulated value.
               */
              function arrayReduce(array, iteratee, accumulator, initAccum) {
                var index = -1,
                  length = array == null ? 0 : array.length;

                if (initAccum && length) {
                  accumulator = array[++index];
                }
                while (++index < length) {
                  accumulator = iteratee(
                    accumulator,
                    array[index],
                    index,
                    array
                  );
                }
                return accumulator;
              }

              /**
               * A specialized version of `_.reduceRight` for arrays without support for
               * iteratee shorthands.
               *
               * @private
               * @param {Array} [array] The array to iterate over.
               * @param {Function} iteratee The function invoked per iteration.
               * @param {*} [accumulator] The initial value.
               * @param {boolean} [initAccum] Specify using the last element of `array` as
               *  the initial value.
               * @returns {*} Returns the accumulated value.
               */
              function arrayReduceRight(
                array,
                iteratee,
                accumulator,
                initAccum
              ) {
                var length = array == null ? 0 : array.length;
                if (initAccum && length) {
                  accumulator = array[--length];
                }
                while (length--) {
                  accumulator = iteratee(
                    accumulator,
                    array[length],
                    length,
                    array
                  );
                }
                return accumulator;
              }

              /**
               * A specialized version of `_.some` for arrays without support for iteratee
               * shorthands.
               *
               * @private
               * @param {Array} [array] The array to iterate over.
               * @param {Function} predicate The function invoked per iteration.
               * @returns {boolean} Returns `true` if any element passes the predicate check,
               *  else `false`.
               */
              function arraySome(array, predicate) {
                var index = -1,
                  length = array == null ? 0 : array.length;

                while (++index < length) {
                  if (predicate(array[index], index, array)) {
                    return true;
                  }
                }
                return false;
              }

              /**
               * Gets the size of an ASCII `string`.
               *
               * @private
               * @param {string} string The string inspect.
               * @returns {number} Returns the string size.
               */
              var asciiSize = baseProperty("length");

              /**
               * Converts an ASCII `string` to an array.
               *
               * @private
               * @param {string} string The string to convert.
               * @returns {Array} Returns the converted array.
               */
              function asciiToArray(string) {
                return string.split("");
              }

              /**
               * Splits an ASCII `string` into an array of its words.
               *
               * @private
               * @param {string} The string to inspect.
               * @returns {Array} Returns the words of `string`.
               */
              function asciiWords(string) {
                return string.match(reAsciiWord) || [];
              }

              /**
               * The base implementation of methods like `_.findKey` and `_.findLastKey`,
               * without support for iteratee shorthands, which iterates over `collection`
               * using `eachFunc`.
               *
               * @private
               * @param {Array|Object} collection The collection to inspect.
               * @param {Function} predicate The function invoked per iteration.
               * @param {Function} eachFunc The function to iterate over `collection`.
               * @returns {*} Returns the found element or its key, else `undefined`.
               */
              function baseFindKey(collection, predicate, eachFunc) {
                var result;
                eachFunc(collection, function (value, key, collection) {
                  if (predicate(value, key, collection)) {
                    result = key;
                    return false;
                  }
                });
                return result;
              }

              /**
               * The base implementation of `_.findIndex` and `_.findLastIndex` without
               * support for iteratee shorthands.
               *
               * @private
               * @param {Array} array The array to inspect.
               * @param {Function} predicate The function invoked per iteration.
               * @param {number} fromIndex The index to search from.
               * @param {boolean} [fromRight] Specify iterating from right to left.
               * @returns {number} Returns the index of the matched value, else `-1`.
               */
              function baseFindIndex(array, predicate, fromIndex, fromRight) {
                var length = array.length,
                  index = fromIndex + (fromRight ? 1 : -1);

                while (fromRight ? index-- : ++index < length) {
                  if (predicate(array[index], index, array)) {
                    return index;
                  }
                }
                return -1;
              }

              /**
               * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
               *
               * @private
               * @param {Array} array The array to inspect.
               * @param {*} value The value to search for.
               * @param {number} fromIndex The index to search from.
               * @returns {number} Returns the index of the matched value, else `-1`.
               */
              function baseIndexOf(array, value, fromIndex) {
                return value === value
                  ? strictIndexOf(array, value, fromIndex)
                  : baseFindIndex(array, baseIsNaN, fromIndex);
              }

              /**
               * This function is like `baseIndexOf` except that it accepts a comparator.
               *
               * @private
               * @param {Array} array The array to inspect.
               * @param {*} value The value to search for.
               * @param {number} fromIndex The index to search from.
               * @param {Function} comparator The comparator invoked per element.
               * @returns {number} Returns the index of the matched value, else `-1`.
               */
              function baseIndexOfWith(array, value, fromIndex, comparator) {
                var index = fromIndex - 1,
                  length = array.length;

                while (++index < length) {
                  if (comparator(array[index], value)) {
                    return index;
                  }
                }
                return -1;
              }

              /**
               * The base implementation of `_.isNaN` without support for number objects.
               *
               * @private
               * @param {*} value The value to check.
               * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
               */
              function baseIsNaN(value) {
                return value !== value;
              }

              /**
               * The base implementation of `_.mean` and `_.meanBy` without support for
               * iteratee shorthands.
               *
               * @private
               * @param {Array} array The array to iterate over.
               * @param {Function} iteratee The function invoked per iteration.
               * @returns {number} Returns the mean.
               */
              function baseMean(array, iteratee) {
                var length = array == null ? 0 : array.length;
                return length ? baseSum(array, iteratee) / length : NAN;
              }

              /**
               * The base implementation of `_.property` without support for deep paths.
               *
               * @private
               * @param {string} key The key of the property to get.
               * @returns {Function} Returns the new accessor function.
               */
              function baseProperty(key) {
                return function (object) {
                  return object == null ? undefined : object[key];
                };
              }

              /**
               * The base implementation of `_.propertyOf` without support for deep paths.
               *
               * @private
               * @param {Object} object The object to query.
               * @returns {Function} Returns the new accessor function.
               */
              function basePropertyOf(object) {
                return function (key) {
                  return object == null ? undefined : object[key];
                };
              }

              /**
               * The base implementation of `_.reduce` and `_.reduceRight`, without support
               * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
               *
               * @private
               * @param {Array|Object} collection The collection to iterate over.
               * @param {Function} iteratee The function invoked per iteration.
               * @param {*} accumulator The initial value.
               * @param {boolean} initAccum Specify using the first or last element of
               *  `collection` as the initial value.
               * @param {Function} eachFunc The function to iterate over `collection`.
               * @returns {*} Returns the accumulated value.
               */
              function baseReduce(
                collection,
                iteratee,
                accumulator,
                initAccum,
                eachFunc
              ) {
                eachFunc(collection, function (value, index, collection) {
                  accumulator = initAccum
                    ? ((initAccum = false), value)
                    : iteratee(accumulator, value, index, collection);
                });
                return accumulator;
              }

              /**
               * The base implementation of `_.sortBy` which uses `comparer` to define the
               * sort order of `array` and replaces criteria objects with their corresponding
               * values.
               *
               * @private
               * @param {Array} array The array to sort.
               * @param {Function} comparer The function to define sort order.
               * @returns {Array} Returns `array`.
               */
              function baseSortBy(array, comparer) {
                var length = array.length;

                array.sort(comparer);
                while (length--) {
                  array[length] = array[length].value;
                }
                return array;
              }

              /**
               * The base implementation of `_.sum` and `_.sumBy` without support for
               * iteratee shorthands.
               *
               * @private
               * @param {Array} array The array to iterate over.
               * @param {Function} iteratee The function invoked per iteration.
               * @returns {number} Returns the sum.
               */
              function baseSum(array, iteratee) {
                var result,
                  index = -1,
                  length = array.length;

                while (++index < length) {
                  var current = iteratee(array[index]);
                  if (current !== undefined) {
                    result = result === undefined ? current : result + current;
                  }
                }
                return result;
              }

              /**
               * The base implementation of `_.times` without support for iteratee shorthands
               * or max array length checks.
               *
               * @private
               * @param {number} n The number of times to invoke `iteratee`.
               * @param {Function} iteratee The function invoked per iteration.
               * @returns {Array} Returns the array of results.
               */
              function baseTimes(n, iteratee) {
                var index = -1,
                  result = Array(n);

                while (++index < n) {
                  result[index] = iteratee(index);
                }
                return result;
              }

              /**
               * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
               * of key-value pairs for `object` corresponding to the property names of `props`.
               *
               * @private
               * @param {Object} object The object to query.
               * @param {Array} props The property names to get values for.
               * @returns {Object} Returns the key-value pairs.
               */
              function baseToPairs(object, props) {
                return arrayMap(props, function (key) {
                  return [key, object[key]];
                });
              }

              /**
               * The base implementation of `_.unary` without support for storing metadata.
               *
               * @private
               * @param {Function} func The function to cap arguments for.
               * @returns {Function} Returns the new capped function.
               */
              function baseUnary(func) {
                return function (value) {
                  return func(value);
                };
              }

              /**
               * The base implementation of `_.values` and `_.valuesIn` which creates an
               * array of `object` property values corresponding to the property names
               * of `props`.
               *
               * @private
               * @param {Object} object The object to query.
               * @param {Array} props The property names to get values for.
               * @returns {Object} Returns the array of property values.
               */
              function baseValues(object, props) {
                return arrayMap(props, function (key) {
                  return object[key];
                });
              }

              /**
               * Checks if a `cache` value for `key` exists.
               *
               * @private
               * @param {Object} cache The cache to query.
               * @param {string} key The key of the entry to check.
               * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
               */
              function cacheHas(cache, key) {
                return cache.has(key);
              }

              /**
               * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
               * that is not found in the character symbols.
               *
               * @private
               * @param {Array} strSymbols The string symbols to inspect.
               * @param {Array} chrSymbols The character symbols to find.
               * @returns {number} Returns the index of the first unmatched string symbol.
               */
              function charsStartIndex(strSymbols, chrSymbols) {
                var index = -1,
                  length = strSymbols.length;

                while (
                  ++index < length &&
                  baseIndexOf(chrSymbols, strSymbols[index], 0) > -1
                ) {}
                return index;
              }

              /**
               * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
               * that is not found in the character symbols.
               *
               * @private
               * @param {Array} strSymbols The string symbols to inspect.
               * @param {Array} chrSymbols The character symbols to find.
               * @returns {number} Returns the index of the last unmatched string symbol.
               */
              function charsEndIndex(strSymbols, chrSymbols) {
                var index = strSymbols.length;

                while (
                  index-- &&
                  baseIndexOf(chrSymbols, strSymbols[index], 0) > -1
                ) {}
                return index;
              }

              /**
               * Gets the number of `placeholder` occurrences in `array`.
               *
               * @private
               * @param {Array} array The array to inspect.
               * @param {*} placeholder The placeholder to search for.
               * @returns {number} Returns the placeholder count.
               */
              function countHolders(array, placeholder) {
                var length = array.length,
                  result = 0;

                while (length--) {
                  if (array[length] === placeholder) {
                    ++result;
                  }
                }
                return result;
              }

              /**
               * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
               * letters to basic Latin letters.
               *
               * @private
               * @param {string} letter The matched letter to deburr.
               * @returns {string} Returns the deburred letter.
               */
              var deburrLetter = basePropertyOf(deburredLetters);

              /**
               * Used by `_.escape` to convert characters to HTML entities.
               *
               * @private
               * @param {string} chr The matched character to escape.
               * @returns {string} Returns the escaped character.
               */
              var escapeHtmlChar = basePropertyOf(htmlEscapes);

              /**
               * Used by `_.template` to escape characters for inclusion in compiled string literals.
               *
               * @private
               * @param {string} chr The matched character to escape.
               * @returns {string} Returns the escaped character.
               */
              function escapeStringChar(chr) {
                return "\\" + stringEscapes[chr];
              }

              /**
               * Gets the value at `key` of `object`.
               *
               * @private
               * @param {Object} [object] The object to query.
               * @param {string} key The key of the property to get.
               * @returns {*} Returns the property value.
               */
              function getValue(object, key) {
                return object == null ? undefined : object[key];
              }

              /**
               * Checks if `string` contains Unicode symbols.
               *
               * @private
               * @param {string} string The string to inspect.
               * @returns {boolean} Returns `true` if a symbol is found, else `false`.
               */
              function hasUnicode(string) {
                return reHasUnicode.test(string);
              }

              /**
               * Checks if `string` contains a word composed of Unicode symbols.
               *
               * @private
               * @param {string} string The string to inspect.
               * @returns {boolean} Returns `true` if a word is found, else `false`.
               */
              function hasUnicodeWord(string) {
                return reHasUnicodeWord.test(string);
              }

              /**
               * Converts `iterator` to an array.
               *
               * @private
               * @param {Object} iterator The iterator to convert.
               * @returns {Array} Returns the converted array.
               */
              function iteratorToArray(iterator) {
                var data,
                  result = [];

                while (!(data = iterator.next()).done) {
                  result.push(data.value);
                }
                return result;
              }

              /**
               * Converts `map` to its key-value pairs.
               *
               * @private
               * @param {Object} map The map to convert.
               * @returns {Array} Returns the key-value pairs.
               */
              function mapToArray(map) {
                var index = -1,
                  result = Array(map.size);

                map.forEach(function (value, key) {
                  result[++index] = [key, value];
                });
                return result;
              }

              /**
               * Creates a unary function that invokes `func` with its argument transformed.
               *
               * @private
               * @param {Function} func The function to wrap.
               * @param {Function} transform The argument transform.
               * @returns {Function} Returns the new function.
               */
              function overArg(func, transform) {
                return function (arg) {
                  return func(transform(arg));
                };
              }

              /**
               * Replaces all `placeholder` elements in `array` with an internal placeholder
               * and returns an array of their indexes.
               *
               * @private
               * @param {Array} array The array to modify.
               * @param {*} placeholder The placeholder to replace.
               * @returns {Array} Returns the new array of placeholder indexes.
               */
              function replaceHolders(array, placeholder) {
                var index = -1,
                  length = array.length,
                  resIndex = 0,
                  result = [];

                while (++index < length) {
                  var value = array[index];
                  if (value === placeholder || value === PLACEHOLDER) {
                    array[index] = PLACEHOLDER;
                    result[resIndex++] = index;
                  }
                }
                return result;
              }

              /**
               * Converts `set` to an array of its values.
               *
               * @private
               * @param {Object} set The set to convert.
               * @returns {Array} Returns the values.
               */
              function setToArray(set) {
                var index = -1,
                  result = Array(set.size);

                set.forEach(function (value) {
                  result[++index] = value;
                });
                return result;
              }

              /**
               * Converts `set` to its value-value pairs.
               *
               * @private
               * @param {Object} set The set to convert.
               * @returns {Array} Returns the value-value pairs.
               */
              function setToPairs(set) {
                var index = -1,
                  result = Array(set.size);

                set.forEach(function (value) {
                  result[++index] = [value, value];
                });
                return result;
              }

              /**
               * A specialized version of `_.indexOf` which performs strict equality
               * comparisons of values, i.e. `===`.
               *
               * @private
               * @param {Array} array The array to inspect.
               * @param {*} value The value to search for.
               * @param {number} fromIndex The index to search from.
               * @returns {number} Returns the index of the matched value, else `-1`.
               */
              function strictIndexOf(array, value, fromIndex) {
                var index = fromIndex - 1,
                  length = array.length;

                while (++index < length) {
                  if (array[index] === value) {
                    return index;
                  }
                }
                return -1;
              }

              /**
               * A specialized version of `_.lastIndexOf` which performs strict equality
               * comparisons of values, i.e. `===`.
               *
               * @private
               * @param {Array} array The array to inspect.
               * @param {*} value The value to search for.
               * @param {number} fromIndex The index to search from.
               * @returns {number} Returns the index of the matched value, else `-1`.
               */
              function strictLastIndexOf(array, value, fromIndex) {
                var index = fromIndex + 1;
                while (index--) {
                  if (array[index] === value) {
                    return index;
                  }
                }
                return index;
              }

              /**
               * Gets the number of symbols in `string`.
               *
               * @private
               * @param {string} string The string to inspect.
               * @returns {number} Returns the string size.
               */
              function stringSize(string) {
                return hasUnicode(string)
                  ? unicodeSize(string)
                  : asciiSize(string);
              }

              /**
               * Converts `string` to an array.
               *
               * @private
               * @param {string} string The string to convert.
               * @returns {Array} Returns the converted array.
               */
              function stringToArray(string) {
                return hasUnicode(string)
                  ? unicodeToArray(string)
                  : asciiToArray(string);
              }

              /**
               * Used by `_.unescape` to convert HTML entities to characters.
               *
               * @private
               * @param {string} chr The matched character to unescape.
               * @returns {string} Returns the unescaped character.
               */
              var unescapeHtmlChar = basePropertyOf(htmlUnescapes);

              /**
               * Gets the size of a Unicode `string`.
               *
               * @private
               * @param {string} string The string inspect.
               * @returns {number} Returns the string size.
               */
              function unicodeSize(string) {
                var result = (reUnicode.lastIndex = 0);
                while (reUnicode.test(string)) {
                  ++result;
                }
                return result;
              }

              /**
               * Converts a Unicode `string` to an array.
               *
               * @private
               * @param {string} string The string to convert.
               * @returns {Array} Returns the converted array.
               */
              function unicodeToArray(string) {
                return string.match(reUnicode) || [];
              }

              /**
               * Splits a Unicode `string` into an array of its words.
               *
               * @private
               * @param {string} The string to inspect.
               * @returns {Array} Returns the words of `string`.
               */
              function unicodeWords(string) {
                return string.match(reUnicodeWord) || [];
              }

              /*--------------------------------------------------------------------------*/

              /**
               * Create a new pristine `lodash` function using the `context` object.
               *
               * @static
               * @memberOf _
               * @since 1.1.0
               * @category Util
               * @param {Object} [context=root] The context object.
               * @returns {Function} Returns a new `lodash` function.
               * @example
               *
               * _.mixin({ 'foo': _.constant('foo') });
               *
               * var lodash = _.runInContext();
               * lodash.mixin({ 'bar': lodash.constant('bar') });
               *
               * _.isFunction(_.foo);
               * // => true
               * _.isFunction(_.bar);
               * // => false
               *
               * lodash.isFunction(lodash.foo);
               * // => false
               * lodash.isFunction(lodash.bar);
               * // => true
               *
               * // Create a suped-up `defer` in Node.js.
               * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
               */
              var runInContext = function runInContext(context) {
                context =
                  context == null
                    ? root
                    : _.defaults(
                        root.Object(),
                        context,
                        _.pick(root, contextProps)
                      );

                /** Built-in constructor references. */
                var Array = context.Array,
                  Date = context.Date,
                  Error = context.Error,
                  Function = context.Function,
                  Math = context.Math,
                  Object = context.Object,
                  RegExp = context.RegExp,
                  String = context.String,
                  TypeError = context.TypeError;

                /** Used for built-in method references. */
                var arrayProto = Array.prototype,
                  funcProto = Function.prototype,
                  objectProto = Object.prototype;

                /** Used to detect overreaching core-js shims. */
                var coreJsData = context["__core-js_shared__"];

                /** Used to resolve the decompiled source of functions. */
                var funcToString = funcProto.toString;

                /** Used to check objects for own properties. */
                var hasOwnProperty = objectProto.hasOwnProperty;

                /** Used to generate unique IDs. */
                var idCounter = 0;

                /** Used to detect methods masquerading as native. */
                var maskSrcKey = (function () {
                  var uid = /[^.]+$/.exec(
                    (coreJsData &&
                      coreJsData.keys &&
                      coreJsData.keys.IE_PROTO) ||
                      ""
                  );
                  return uid ? "Symbol(src)_1." + uid : "";
                })();

                /**
                 * Used to resolve the
                 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
                 * of values.
                 */
                var nativeObjectToString = objectProto.toString;

                /** Used to infer the `Object` constructor. */
                var objectCtorString = funcToString.call(Object);

                /** Used to restore the original `_` reference in `_.noConflict`. */
                var oldDash = root._;

                /** Used to detect if a method is native. */
                var reIsNative = RegExp(
                  "^" +
                    funcToString
                      .call(hasOwnProperty)
                      .replace(reRegExpChar, "\\$&")
                      .replace(
                        /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
                        "$1.*?"
                      ) +
                    "$"
                );

                /** Built-in value references. */
                var Buffer = moduleExports ? context.Buffer : undefined,
                  Symbol = context.Symbol,
                  Uint8Array = context.Uint8Array,
                  allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,
                  getPrototype = overArg(Object.getPrototypeOf, Object),
                  objectCreate = Object.create,
                  propertyIsEnumerable = objectProto.propertyIsEnumerable,
                  splice = arrayProto.splice,
                  spreadableSymbol = Symbol
                    ? Symbol.isConcatSpreadable
                    : undefined,
                  symIterator = Symbol ? Symbol.iterator : undefined,
                  symToStringTag = Symbol ? Symbol.toStringTag : undefined;

                var defineProperty = (function () {
                  try {
                    var func = getNative(Object, "defineProperty");
                    func({}, "", {});
                    return func;
                  } catch (e) {}
                })();

                /** Mocked built-ins. */
                var ctxClearTimeout =
                    context.clearTimeout !== root.clearTimeout &&
                    context.clearTimeout,
                  ctxNow = Date && Date.now !== root.Date.now && Date.now,
                  ctxSetTimeout =
                    context.setTimeout !== root.setTimeout &&
                    context.setTimeout;

                /* Built-in method references for those with the same name as other `lodash` methods. */
                var nativeCeil = Math.ceil,
                  nativeFloor = Math.floor,
                  nativeGetSymbols = Object.getOwnPropertySymbols,
                  nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
                  nativeIsFinite = context.isFinite,
                  nativeJoin = arrayProto.join,
                  nativeKeys = overArg(Object.keys, Object),
                  nativeMax = Math.max,
                  nativeMin = Math.min,
                  nativeNow = Date.now,
                  nativeParseInt = context.parseInt,
                  nativeRandom = Math.random,
                  nativeReverse = arrayProto.reverse;

                /* Built-in method references that are verified to be native. */
                var DataView = getNative(context, "DataView"),
                  Map = getNative(context, "Map"),
                  Promise = getNative(context, "Promise"),
                  Set = getNative(context, "Set"),
                  WeakMap = getNative(context, "WeakMap"),
                  nativeCreate = getNative(Object, "create");

                /** Used to store function metadata. */
                var metaMap = WeakMap && new WeakMap();

                /** Used to lookup unminified function names. */
                var realNames = {};

                /** Used to detect maps, sets, and weakmaps. */
                var dataViewCtorString = toSource(DataView),
                  mapCtorString = toSource(Map),
                  promiseCtorString = toSource(Promise),
                  setCtorString = toSource(Set),
                  weakMapCtorString = toSource(WeakMap);

                /** Used to convert symbols to primitives and strings. */
                var symbolProto = Symbol ? Symbol.prototype : undefined,
                  symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
                  symbolToString = symbolProto
                    ? symbolProto.toString
                    : undefined;

                /*------------------------------------------------------------------------*/

                /**
                 * Creates a `lodash` object which wraps `value` to enable implicit method
                 * chain sequences. Methods that operate on and return arrays, collections,
                 * and functions can be chained together. Methods that retrieve a single value
                 * or may return a primitive value will automatically end the chain sequence
                 * and return the unwrapped value. Otherwise, the value must be unwrapped
                 * with `_#value`.
                 *
                 * Explicit chain sequences, which must be unwrapped with `_#value`, may be
                 * enabled using `_.chain`.
                 *
                 * The execution of chained methods is lazy, that is, it's deferred until
                 * `_#value` is implicitly or explicitly called.
                 *
                 * Lazy evaluation allows several methods to support shortcut fusion.
                 * Shortcut fusion is an optimization to merge iteratee calls; this avoids
                 * the creation of intermediate arrays and can greatly reduce the number of
                 * iteratee executions. Sections of a chain sequence qualify for shortcut
                 * fusion if the section is applied to an array and iteratees accept only
                 * one argument. The heuristic for whether a section qualifies for shortcut
                 * fusion is subject to change.
                 *
                 * Chaining is supported in custom builds as long as the `_#value` method is
                 * directly or indirectly included in the build.
                 *
                 * In addition to lodash methods, wrappers have `Array` and `String` methods.
                 *
                 * The wrapper `Array` methods are:
                 * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
                 *
                 * The wrapper `String` methods are:
                 * `replace` and `split`
                 *
                 * The wrapper methods that support shortcut fusion are:
                 * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
                 * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
                 * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
                 *
                 * The chainable wrapper methods are:
                 * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
                 * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
                 * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
                 * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
                 * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
                 * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
                 * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
                 * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
                 * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
                 * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
                 * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
                 * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
                 * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
                 * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
                 * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
                 * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
                 * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
                 * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
                 * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
                 * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
                 * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
                 * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
                 * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
                 * `zipObject`, `zipObjectDeep`, and `zipWith`
                 *
                 * The wrapper methods that are **not** chainable by default are:
                 * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
                 * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
                 * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
                 * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
                 * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
                 * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
                 * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
                 * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
                 * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
                 * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
                 * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
                 * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
                 * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
                 * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
                 * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
                 * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
                 * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
                 * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
                 * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
                 * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
                 * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
                 * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
                 * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
                 * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
                 * `upperFirst`, `value`, and `words`
                 *
                 * @name _
                 * @constructor
                 * @category Seq
                 * @param {*} value The value to wrap in a `lodash` instance.
                 * @returns {Object} Returns the new `lodash` wrapper instance.
                 * @example
                 *
                 * function square(n) {
                 *   return n * n;
                 * }
                 *
                 * var wrapped = _([1, 2, 3]);
                 *
                 * // Returns an unwrapped value.
                 * wrapped.reduce(_.add);
                 * // => 6
                 *
                 * // Returns a wrapped value.
                 * var squares = wrapped.map(square);
                 *
                 * _.isArray(squares);
                 * // => false
                 *
                 * _.isArray(squares.value());
                 * // => true
                 */
                function lodash(value) {
                  if (
                    isObjectLike(value) &&
                    !isArray(value) &&
                    !(value instanceof LazyWrapper)
                  ) {
                    if (value instanceof LodashWrapper) {
                      return value;
                    }
                    if (hasOwnProperty.call(value, "__wrapped__")) {
                      return wrapperClone(value);
                    }
                  }
                  return new LodashWrapper(value);
                }

                /**
                 * The base implementation of `_.create` without support for assigning
                 * properties to the created object.
                 *
                 * @private
                 * @param {Object} proto The object to inherit from.
                 * @returns {Object} Returns the new object.
                 */
                var baseCreate = (function () {
                  function object() {}
                  return function (proto) {
                    if (!isObject(proto)) {
                      return {};
                    }
                    if (objectCreate) {
                      return objectCreate(proto);
                    }
                    object.prototype = proto;
                    var result = new object();
                    object.prototype = undefined;
                    return result;
                  };
                })();

                /**
                 * The function whose prototype chain sequence wrappers inherit from.
                 *
                 * @private
                 */
                function baseLodash() {
                  // No operation performed.
                }

                /**
                 * The base constructor for creating `lodash` wrapper objects.
                 *
                 * @private
                 * @param {*} value The value to wrap.
                 * @param {boolean} [chainAll] Enable explicit method chain sequences.
                 */
                function LodashWrapper(value, chainAll) {
                  this.__wrapped__ = value;
                  this.__actions__ = [];
                  this.__chain__ = !!chainAll;
                  this.__index__ = 0;
                  this.__values__ = undefined;
                }

                /**
                 * By default, the template delimiters used by lodash are like those in
                 * embedded Ruby (ERB) as well as ES2015 template strings. Change the
                 * following template settings to use alternative delimiters.
                 *
                 * @static
                 * @memberOf _
                 * @type {Object}
                 */
                lodash.templateSettings = {
                  /**
                   * Used to detect `data` property values to be HTML-escaped.
                   *
                   * @memberOf _.templateSettings
                   * @type {RegExp}
                   */
                  escape: reEscape,

                  /**
                   * Used to detect code to be evaluated.
                   *
                   * @memberOf _.templateSettings
                   * @type {RegExp}
                   */
                  evaluate: reEvaluate,

                  /**
                   * Used to detect `data` property values to inject.
                   *
                   * @memberOf _.templateSettings
                   * @type {RegExp}
                   */
                  interpolate: reInterpolate,

                  /**
                   * Used to reference the data object in the template text.
                   *
                   * @memberOf _.templateSettings
                   * @type {string}
                   */
                  variable: "",

                  /**
                   * Used to import variables into the compiled template.
                   *
                   * @memberOf _.templateSettings
                   * @type {Object}
                   */
                  imports: {
                    /**
                     * A reference to the `lodash` function.
                     *
                     * @memberOf _.templateSettings.imports
                     * @type {Function}
                     */
                    _: lodash,
                  },
                };

                // Ensure wrappers are instances of `baseLodash`.
                lodash.prototype = baseLodash.prototype;
                lodash.prototype.constructor = lodash;

                LodashWrapper.prototype = baseCreate(baseLodash.prototype);
                LodashWrapper.prototype.constructor = LodashWrapper;

                /*------------------------------------------------------------------------*/

                /**
                 * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
                 *
                 * @private
                 * @constructor
                 * @param {*} value The value to wrap.
                 */
                function LazyWrapper(value) {
                  this.__wrapped__ = value;
                  this.__actions__ = [];
                  this.__dir__ = 1;
                  this.__filtered__ = false;
                  this.__iteratees__ = [];
                  this.__takeCount__ = MAX_ARRAY_LENGTH;
                  this.__views__ = [];
                }

                /**
                 * Creates a clone of the lazy wrapper object.
                 *
                 * @private
                 * @name clone
                 * @memberOf LazyWrapper
                 * @returns {Object} Returns the cloned `LazyWrapper` object.
                 */
                function lazyClone() {
                  var result = new LazyWrapper(this.__wrapped__);
                  result.__actions__ = copyArray(this.__actions__);
                  result.__dir__ = this.__dir__;
                  result.__filtered__ = this.__filtered__;
                  result.__iteratees__ = copyArray(this.__iteratees__);
                  result.__takeCount__ = this.__takeCount__;
                  result.__views__ = copyArray(this.__views__);
                  return result;
                }

                /**
                 * Reverses the direction of lazy iteration.
                 *
                 * @private
                 * @name reverse
                 * @memberOf LazyWrapper
                 * @returns {Object} Returns the new reversed `LazyWrapper` object.
                 */
                function lazyReverse() {
                  if (this.__filtered__) {
                    var result = new LazyWrapper(this);
                    result.__dir__ = -1;
                    result.__filtered__ = true;
                  } else {
                    result = this.clone();
                    result.__dir__ *= -1;
                  }
                  return result;
                }

                /**
                 * Extracts the unwrapped value from its lazy wrapper.
                 *
                 * @private
                 * @name value
                 * @memberOf LazyWrapper
                 * @returns {*} Returns the unwrapped value.
                 */
                function lazyValue() {
                  var array = this.__wrapped__.value(),
                    dir = this.__dir__,
                    isArr = isArray(array),
                    isRight = dir < 0,
                    arrLength = isArr ? array.length : 0,
                    view = getView(0, arrLength, this.__views__),
                    start = view.start,
                    end = view.end,
                    length = end - start,
                    index = isRight ? end : start - 1,
                    iteratees = this.__iteratees__,
                    iterLength = iteratees.length,
                    resIndex = 0,
                    takeCount = nativeMin(length, this.__takeCount__);

                  if (
                    !isArr ||
                    (!isRight && arrLength == length && takeCount == length)
                  ) {
                    return baseWrapperValue(array, this.__actions__);
                  }
                  var result = [];

                  outer: while (length-- && resIndex < takeCount) {
                    index += dir;

                    var iterIndex = -1,
                      value = array[index];

                    while (++iterIndex < iterLength) {
                      var data = iteratees[iterIndex],
                        iteratee = data.iteratee,
                        type = data.type,
                        computed = iteratee(value);

                      if (type == LAZY_MAP_FLAG) {
                        value = computed;
                      } else if (!computed) {
                        if (type == LAZY_FILTER_FLAG) {
                          continue outer;
                        } else {
                          break outer;
                        }
                      }
                    }
                    result[resIndex++] = value;
                  }
                  return result;
                }

                // Ensure `LazyWrapper` is an instance of `baseLodash`.
                LazyWrapper.prototype = baseCreate(baseLodash.prototype);
                LazyWrapper.prototype.constructor = LazyWrapper;

                /*------------------------------------------------------------------------*/

                /**
                 * Creates a hash object.
                 *
                 * @private
                 * @constructor
                 * @param {Array} [entries] The key-value pairs to cache.
                 */
                function Hash(entries) {
                  var index = -1,
                    length = entries == null ? 0 : entries.length;

                  this.clear();
                  while (++index < length) {
                    var entry = entries[index];
                    this.set(entry[0], entry[1]);
                  }
                }

                /**
                 * Removes all key-value entries from the hash.
                 *
                 * @private
                 * @name clear
                 * @memberOf Hash
                 */
                function hashClear() {
                  this.__data__ = nativeCreate ? nativeCreate(null) : {};
                  this.size = 0;
                }

                /**
                 * Removes `key` and its value from the hash.
                 *
                 * @private
                 * @name delete
                 * @memberOf Hash
                 * @param {Object} hash The hash to modify.
                 * @param {string} key The key of the value to remove.
                 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
                 */
                function hashDelete(key) {
                  var result = this.has(key) && delete this.__data__[key];
                  this.size -= result ? 1 : 0;
                  return result;
                }

                /**
                 * Gets the hash value for `key`.
                 *
                 * @private
                 * @name get
                 * @memberOf Hash
                 * @param {string} key The key of the value to get.
                 * @returns {*} Returns the entry value.
                 */
                function hashGet(key) {
                  var data = this.__data__;
                  if (nativeCreate) {
                    var result = data[key];
                    return result === HASH_UNDEFINED ? undefined : result;
                  }
                  return hasOwnProperty.call(data, key) ? data[key] : undefined;
                }

                /**
                 * Checks if a hash value for `key` exists.
                 *
                 * @private
                 * @name has
                 * @memberOf Hash
                 * @param {string} key The key of the entry to check.
                 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
                 */
                function hashHas(key) {
                  var data = this.__data__;
                  return nativeCreate
                    ? data[key] !== undefined
                    : hasOwnProperty.call(data, key);
                }

                /**
                 * Sets the hash `key` to `value`.
                 *
                 * @private
                 * @name set
                 * @memberOf Hash
                 * @param {string} key The key of the value to set.
                 * @param {*} value The value to set.
                 * @returns {Object} Returns the hash instance.
                 */
                function hashSet(key, value) {
                  var data = this.__data__;
                  this.size += this.has(key) ? 0 : 1;
                  data[key] =
                    nativeCreate && value === undefined
                      ? HASH_UNDEFINED
                      : value;
                  return this;
                }

                // Add methods to `Hash`.
                Hash.prototype.clear = hashClear;
                Hash.prototype["delete"] = hashDelete;
                Hash.prototype.get = hashGet;
                Hash.prototype.has = hashHas;
                Hash.prototype.set = hashSet;

                /*------------------------------------------------------------------------*/

                /**
                 * Creates an list cache object.
                 *
                 * @private
                 * @constructor
                 * @param {Array} [entries] The key-value pairs to cache.
                 */
                function ListCache(entries) {
                  var index = -1,
                    length = entries == null ? 0 : entries.length;

                  this.clear();
                  while (++index < length) {
                    var entry = entries[index];
                    this.set(entry[0], entry[1]);
                  }
                }

                /**
                 * Removes all key-value entries from the list cache.
                 *
                 * @private
                 * @name clear
                 * @memberOf ListCache
                 */
                function listCacheClear() {
                  this.__data__ = [];
                  this.size = 0;
                }

                /**
                 * Removes `key` and its value from the list cache.
                 *
                 * @private
                 * @name delete
                 * @memberOf ListCache
                 * @param {string} key The key of the value to remove.
                 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
                 */
                function listCacheDelete(key) {
                  var data = this.__data__,
                    index = assocIndexOf(data, key);

                  if (index < 0) {
                    return false;
                  }
                  var lastIndex = data.length - 1;
                  if (index == lastIndex) {
                    data.pop();
                  } else {
                    splice.call(data, index, 1);
                  }
                  --this.size;
                  return true;
                }

                /**
                 * Gets the list cache value for `key`.
                 *
                 * @private
                 * @name get
                 * @memberOf ListCache
                 * @param {string} key The key of the value to get.
                 * @returns {*} Returns the entry value.
                 */
                function listCacheGet(key) {
                  var data = this.__data__,
                    index = assocIndexOf(data, key);

                  return index < 0 ? undefined : data[index][1];
                }

                /**
                 * Checks if a list cache value for `key` exists.
                 *
                 * @private
                 * @name has
                 * @memberOf ListCache
                 * @param {string} key The key of the entry to check.
                 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
                 */
                function listCacheHas(key) {
                  return assocIndexOf(this.__data__, key) > -1;
                }

                /**
                 * Sets the list cache `key` to `value`.
                 *
                 * @private
                 * @name set
                 * @memberOf ListCache
                 * @param {string} key The key of the value to set.
                 * @param {*} value The value to set.
                 * @returns {Object} Returns the list cache instance.
                 */
                function listCacheSet(key, value) {
                  var data = this.__data__,
                    index = assocIndexOf(data, key);

                  if (index < 0) {
                    ++this.size;
                    data.push([key, value]);
                  } else {
                    data[index][1] = value;
                  }
                  return this;
                }

                // Add methods to `ListCache`.
                ListCache.prototype.clear = listCacheClear;
                ListCache.prototype["delete"] = listCacheDelete;
                ListCache.prototype.get = listCacheGet;
                ListCache.prototype.has = listCacheHas;
                ListCache.prototype.set = listCacheSet;

                /*------------------------------------------------------------------------*/

                /**
                 * Creates a map cache object to store key-value pairs.
                 *
                 * @private
                 * @constructor
                 * @param {Array} [entries] The key-value pairs to cache.
                 */
                function MapCache(entries) {
                  var index = -1,
                    length = entries == null ? 0 : entries.length;

                  this.clear();
                  while (++index < length) {
                    var entry = entries[index];
                    this.set(entry[0], entry[1]);
                  }
                }

                /**
                 * Removes all key-value entries from the map.
                 *
                 * @private
                 * @name clear
                 * @memberOf MapCache
                 */
                function mapCacheClear() {
                  this.size = 0;
                  this.__data__ = {
                    hash: new Hash(),
                    map: new (Map || ListCache)(),
                    string: new Hash(),
                  };
                }

                /**
                 * Removes `key` and its value from the map.
                 *
                 * @private
                 * @name delete
                 * @memberOf MapCache
                 * @param {string} key The key of the value to remove.
                 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
                 */
                function mapCacheDelete(key) {
                  var result = getMapData(this, key)["delete"](key);
                  this.size -= result ? 1 : 0;
                  return result;
                }

                /**
                 * Gets the map value for `key`.
                 *
                 * @private
                 * @name get
                 * @memberOf MapCache
                 * @param {string} key The key of the value to get.
                 * @returns {*} Returns the entry value.
                 */
                function mapCacheGet(key) {
                  return getMapData(this, key).get(key);
                }

                /**
                 * Checks if a map value for `key` exists.
                 *
                 * @private
                 * @name has
                 * @memberOf MapCache
                 * @param {string} key The key of the entry to check.
                 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
                 */
                function mapCacheHas(key) {
                  return getMapData(this, key).has(key);
                }

                /**
                 * Sets the map `key` to `value`.
                 *
                 * @private
                 * @name set
                 * @memberOf MapCache
                 * @param {string} key The key of the value to set.
                 * @param {*} value The value to set.
                 * @returns {Object} Returns the map cache instance.
                 */
                function mapCacheSet(key, value) {
                  var data = getMapData(this, key),
                    size = data.size;

                  data.set(key, value);
                  this.size += data.size == size ? 0 : 1;
                  return this;
                }

                // Add methods to `MapCache`.
                MapCache.prototype.clear = mapCacheClear;
                MapCache.prototype["delete"] = mapCacheDelete;
                MapCache.prototype.get = mapCacheGet;
                MapCache.prototype.has = mapCacheHas;
                MapCache.prototype.set = mapCacheSet;

                /*------------------------------------------------------------------------*/

                /**
                 *
                 * Creates an array cache object to store unique values.
                 *
                 * @private
                 * @constructor
                 * @param {Array} [values] The values to cache.
                 */
                function SetCache(values) {
                  var index = -1,
                    length = values == null ? 0 : values.length;

                  this.__data__ = new MapCache();
                  while (++index < length) {
                    this.add(values[index]);
                  }
                }

                /**
                 * Adds `value` to the array cache.
                 *
                 * @private
                 * @name add
                 * @memberOf SetCache
                 * @alias push
                 * @param {*} value The value to cache.
                 * @returns {Object} Returns the cache instance.
                 */
                function setCacheAdd(value) {
                  this.__data__.set(value, HASH_UNDEFINED);
                  return this;
                }

                /**
                 * Checks if `value` is in the array cache.
                 *
                 * @private
                 * @name has
                 * @memberOf SetCache
                 * @param {*} value The value to search for.
                 * @returns {number} Returns `true` if `value` is found, else `false`.
                 */
                function setCacheHas(value) {
                  return this.__data__.has(value);
                }

                // Add methods to `SetCache`.
                SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
                SetCache.prototype.has = setCacheHas;

                /*------------------------------------------------------------------------*/

                /**
                 * Creates a stack cache object to store key-value pairs.
                 *
                 * @private
                 * @constructor
                 * @param {Array} [entries] The key-value pairs to cache.
                 */
                function Stack(entries) {
                  var data = (this.__data__ = new ListCache(entries));
                  this.size = data.size;
                }

                /**
                 * Removes all key-value entries from the stack.
                 *
                 * @private
                 * @name clear
                 * @memberOf Stack
                 */
                function stackClear() {
                  this.__data__ = new ListCache();
                  this.size = 0;
                }

                /**
                 * Removes `key` and its value from the stack.
                 *
                 * @private
                 * @name delete
                 * @memberOf Stack
                 * @param {string} key The key of the value to remove.
                 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
                 */
                function stackDelete(key) {
                  var data = this.__data__,
                    result = data["delete"](key);

                  this.size = data.size;
                  return result;
                }

                /**
                 * Gets the stack value for `key`.
                 *
                 * @private
                 * @name get
                 * @memberOf Stack
                 * @param {string} key The key of the value to get.
                 * @returns {*} Returns the entry value.
                 */
                function stackGet(key) {
                  return this.__data__.get(key);
                }

                /**
                 * Checks if a stack value for `key` exists.
                 *
                 * @private
                 * @name has
                 * @memberOf Stack
                 * @param {string} key The key of the entry to check.
                 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
                 */
                function stackHas(key) {
                  return this.__data__.has(key);
                }

                /**
                 * Sets the stack `key` to `value`.
                 *
                 * @private
                 * @name set
                 * @memberOf Stack
                 * @param {string} key The key of the value to set.
                 * @param {*} value The value to set.
                 * @returns {Object} Returns the stack cache instance.
                 */
                function stackSet(key, value) {
                  var data = this.__data__;
                  if (data instanceof ListCache) {
                    var pairs = data.__data__;
                    if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
                      pairs.push([key, value]);
                      this.size = ++data.size;
                      return this;
                    }
                    data = this.__data__ = new MapCache(pairs);
                  }
                  data.set(key, value);
                  this.size = data.size;
                  return this;
                }

                // Add methods to `Stack`.
                Stack.prototype.clear = stackClear;
                Stack.prototype["delete"] = stackDelete;
                Stack.prototype.get = stackGet;
                Stack.prototype.has = stackHas;
                Stack.prototype.set = stackSet;

                /*------------------------------------------------------------------------*/

                /**
                 * Creates an array of the enumerable property names of the array-like `value`.
                 *
                 * @private
                 * @param {*} value The value to query.
                 * @param {boolean} inherited Specify returning inherited property names.
                 * @returns {Array} Returns the array of property names.
                 */
                function arrayLikeKeys(value, inherited) {
                  var isArr = isArray(value),
                    isArg = !isArr && isArguments(value),
                    isBuff = !isArr && !isArg && isBuffer(value),
                    isType = !isArr && !isArg && !isBuff && isTypedArray(value),
                    skipIndexes = isArr || isArg || isBuff || isType,
                    result = skipIndexes ? baseTimes(value.length, String) : [],
                    length = result.length;

                  for (var key in value) {
                    if (
                      (inherited || hasOwnProperty.call(value, key)) &&
                      !(
                        skipIndexes &&
                        // Safari 9 has enumerable `arguments.length` in strict mode.
                        (key == "length" ||
                          // Node.js 0.10 has enumerable non-index properties on buffers.
                          (isBuff && (key == "offset" || key == "parent")) ||
                          // PhantomJS 2 has enumerable non-index properties on typed arrays.
                          (isType &&
                            (key == "buffer" ||
                              key == "byteLength" ||
                              key == "byteOffset")) ||
                          // Skip index properties.
                          isIndex(key, length))
                      )
                    ) {
                      result.push(key);
                    }
                  }
                  return result;
                }

                /**
                 * A specialized version of `_.sample` for arrays.
                 *
                 * @private
                 * @param {Array} array The array to sample.
                 * @returns {*} Returns the random element.
                 */
                function arraySample(array) {
                  var length = array.length;
                  return length ? array[baseRandom(0, length - 1)] : undefined;
                }

                /**
                 * A specialized version of `_.sampleSize` for arrays.
                 *
                 * @private
                 * @param {Array} array The array to sample.
                 * @param {number} n The number of elements to sample.
                 * @returns {Array} Returns the random elements.
                 */
                function arraySampleSize(array, n) {
                  return shuffleSelf(
                    copyArray(array),
                    baseClamp(n, 0, array.length)
                  );
                }

                /**
                 * A specialized version of `_.shuffle` for arrays.
                 *
                 * @private
                 * @param {Array} array The array to shuffle.
                 * @returns {Array} Returns the new shuffled array.
                 */
                function arrayShuffle(array) {
                  return shuffleSelf(copyArray(array));
                }

                /**
                 * This function is like `assignValue` except that it doesn't assign
                 * `undefined` values.
                 *
                 * @private
                 * @param {Object} object The object to modify.
                 * @param {string} key The key of the property to assign.
                 * @param {*} value The value to assign.
                 */
                function assignMergeValue(object, key, value) {
                  if (
                    (value !== undefined && !eq(object[key], value)) ||
                    (value === undefined && !(key in object))
                  ) {
                    baseAssignValue(object, key, value);
                  }
                }

                /**
                 * Assigns `value` to `key` of `object` if the existing value is not equivalent
                 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
                 * for equality comparisons.
                 *
                 * @private
                 * @param {Object} object The object to modify.
                 * @param {string} key The key of the property to assign.
                 * @param {*} value The value to assign.
                 */
                function assignValue(object, key, value) {
                  var objValue = object[key];
                  if (
                    !(
                      hasOwnProperty.call(object, key) && eq(objValue, value)
                    ) ||
                    (value === undefined && !(key in object))
                  ) {
                    baseAssignValue(object, key, value);
                  }
                }

                /**
                 * Gets the index at which the `key` is found in `array` of key-value pairs.
                 *
                 * @private
                 * @param {Array} array The array to inspect.
                 * @param {*} key The key to search for.
                 * @returns {number} Returns the index of the matched value, else `-1`.
                 */
                function assocIndexOf(array, key) {
                  var length = array.length;
                  while (length--) {
                    if (eq(array[length][0], key)) {
                      return length;
                    }
                  }
                  return -1;
                }

                /**
                 * Aggregates elements of `collection` on `accumulator` with keys transformed
                 * by `iteratee` and values set by `setter`.
                 *
                 * @private
                 * @param {Array|Object} collection The collection to iterate over.
                 * @param {Function} setter The function to set `accumulator` values.
                 * @param {Function} iteratee The iteratee to transform keys.
                 * @param {Object} accumulator The initial aggregated object.
                 * @returns {Function} Returns `accumulator`.
                 */
                function baseAggregator(
                  collection,
                  setter,
                  iteratee,
                  accumulator
                ) {
                  baseEach(collection, function (value, key, collection) {
                    setter(accumulator, value, iteratee(value), collection);
                  });
                  return accumulator;
                }

                /**
                 * The base implementation of `_.assign` without support for multiple sources
                 * or `customizer` functions.
                 *
                 * @private
                 * @param {Object} object The destination object.
                 * @param {Object} source The source object.
                 * @returns {Object} Returns `object`.
                 */
                function baseAssign(object, source) {
                  return object && copyObject(source, keys(source), object);
                }

                /**
                 * The base implementation of `_.assignIn` without support for multiple sources
                 * or `customizer` functions.
                 *
                 * @private
                 * @param {Object} object The destination object.
                 * @param {Object} source The source object.
                 * @returns {Object} Returns `object`.
                 */
                function baseAssignIn(object, source) {
                  return object && copyObject(source, keysIn(source), object);
                }

                /**
                 * The base implementation of `assignValue` and `assignMergeValue` without
                 * value checks.
                 *
                 * @private
                 * @param {Object} object The object to modify.
                 * @param {string} key The key of the property to assign.
                 * @param {*} value The value to assign.
                 */
                function baseAssignValue(object, key, value) {
                  if (key == "__proto__" && defineProperty) {
                    defineProperty(object, key, {
                      configurable: true,
                      enumerable: true,
                      value: value,
                      writable: true,
                    });
                  } else {
                    object[key] = value;
                  }
                }

                /**
                 * The base implementation of `_.at` without support for individual paths.
                 *
                 * @private
                 * @param {Object} object The object to iterate over.
                 * @param {string[]} paths The property paths to pick.
                 * @returns {Array} Returns the picked elements.
                 */
                function baseAt(object, paths) {
                  var index = -1,
                    length = paths.length,
                    result = Array(length),
                    skip = object == null;

                  while (++index < length) {
                    result[index] = skip
                      ? undefined
                      : get(object, paths[index]);
                  }
                  return result;
                }

                /**
                 * The base implementation of `_.clamp` which doesn't coerce arguments.
                 *
                 * @private
                 * @param {number} number The number to clamp.
                 * @param {number} [lower] The lower bound.
                 * @param {number} upper The upper bound.
                 * @returns {number} Returns the clamped number.
                 */
                function baseClamp(number, lower, upper) {
                  if (number === number) {
                    if (upper !== undefined) {
                      number = number <= upper ? number : upper;
                    }
                    if (lower !== undefined) {
                      number = number >= lower ? number : lower;
                    }
                  }
                  return number;
                }

                /**
                 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
                 * traversed objects.
                 *
                 * @private
                 * @param {*} value The value to clone.
                 * @param {boolean} bitmask The bitmask flags.
                 *  1 - Deep clone
                 *  2 - Flatten inherited properties
                 *  4 - Clone symbols
                 * @param {Function} [customizer] The function to customize cloning.
                 * @param {string} [key] The key of `value`.
                 * @param {Object} [object] The parent object of `value`.
                 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
                 * @returns {*} Returns the cloned value.
                 */
                function baseClone(
                  value,
                  bitmask,
                  customizer,
                  key,
                  object,
                  stack
                ) {
                  var result,
                    isDeep = bitmask & CLONE_DEEP_FLAG,
                    isFlat = bitmask & CLONE_FLAT_FLAG,
                    isFull = bitmask & CLONE_SYMBOLS_FLAG;

                  if (customizer) {
                    result = object
                      ? customizer(value, key, object, stack)
                      : customizer(value);
                  }
                  if (result !== undefined) {
                    return result;
                  }
                  if (!isObject(value)) {
                    return value;
                  }
                  var isArr = isArray(value);
                  if (isArr) {
                    result = initCloneArray(value);
                    if (!isDeep) {
                      return copyArray(value, result);
                    }
                  } else {
                    var tag = getTag(value),
                      isFunc = tag == funcTag || tag == genTag;

                    if (isBuffer(value)) {
                      return cloneBuffer(value, isDeep);
                    }
                    if (
                      tag == objectTag ||
                      tag == argsTag ||
                      (isFunc && !object)
                    ) {
                      result = isFlat || isFunc ? {} : initCloneObject(value);
                      if (!isDeep) {
                        return isFlat
                          ? copySymbolsIn(value, baseAssignIn(result, value))
                          : copySymbols(value, baseAssign(result, value));
                      }
                    } else {
                      if (!cloneableTags[tag]) {
                        return object ? value : {};
                      }
                      result = initCloneByTag(value, tag, isDeep);
                    }
                  }
                  // Check for circular references and return its corresponding clone.
                  stack || (stack = new Stack());
                  var stacked = stack.get(value);
                  if (stacked) {
                    return stacked;
                  }
                  stack.set(value, result);

                  if (isSet(value)) {
                    value.forEach(function (subValue) {
                      result.add(
                        baseClone(
                          subValue,
                          bitmask,
                          customizer,
                          subValue,
                          value,
                          stack
                        )
                      );
                    });
                  } else if (isMap(value)) {
                    value.forEach(function (subValue, key) {
                      result.set(
                        key,
                        baseClone(
                          subValue,
                          bitmask,
                          customizer,
                          key,
                          value,
                          stack
                        )
                      );
                    });
                  }

                  var keysFunc = isFull
                    ? isFlat
                      ? getAllKeysIn
                      : getAllKeys
                    : isFlat
                    ? keysIn
                    : keys;

                  var props = isArr ? undefined : keysFunc(value);
                  arrayEach(props || value, function (subValue, key) {
                    if (props) {
                      key = subValue;
                      subValue = value[key];
                    }
                    // Recursively populate clone (susceptible to call stack limits).
                    assignValue(
                      result,
                      key,
                      baseClone(
                        subValue,
                        bitmask,
                        customizer,
                        key,
                        value,
                        stack
                      )
                    );
                  });
                  return result;
                }

                /**
                 * The base implementation of `_.conforms` which doesn't clone `source`.
                 *
                 * @private
                 * @param {Object} source The object of property predicates to conform to.
                 * @returns {Function} Returns the new spec function.
                 */
                function baseConforms(source) {
                  var props = keys(source);
                  return function (object) {
                    return baseConformsTo(object, source, props);
                  };
                }

                /**
                 * The base implementation of `_.conformsTo` which accepts `props` to check.
                 *
                 * @private
                 * @param {Object} object The object to inspect.
                 * @param {Object} source The object of property predicates to conform to.
                 * @returns {boolean} Returns `true` if `object` conforms, else `false`.
                 */
                function baseConformsTo(object, source, props) {
                  var length = props.length;
                  if (object == null) {
                    return !length;
                  }
                  object = Object(object);
                  while (length--) {
                    var key = props[length],
                      predicate = source[key],
                      value = object[key];

                    if (
                      (value === undefined && !(key in object)) ||
                      !predicate(value)
                    ) {
                      return false;
                    }
                  }
                  return true;
                }

                /**
                 * The base implementation of `_.delay` and `_.defer` which accepts `args`
                 * to provide to `func`.
                 *
                 * @private
                 * @param {Function} func The function to delay.
                 * @param {number} wait The number of milliseconds to delay invocation.
                 * @param {Array} args The arguments to provide to `func`.
                 * @returns {number|Object} Returns the timer id or timeout object.
                 */
                function baseDelay(func, wait, args) {
                  if (typeof func != "function") {
                    throw new TypeError(FUNC_ERROR_TEXT);
                  }
                  return setTimeout(function () {
                    func.apply(undefined, args);
                  }, wait);
                }

                /**
                 * The base implementation of methods like `_.difference` without support
                 * for excluding multiple arrays or iteratee shorthands.
                 *
                 * @private
                 * @param {Array} array The array to inspect.
                 * @param {Array} values The values to exclude.
                 * @param {Function} [iteratee] The iteratee invoked per element.
                 * @param {Function} [comparator] The comparator invoked per element.
                 * @returns {Array} Returns the new array of filtered values.
                 */
                function baseDifference(array, values, iteratee, comparator) {
                  var index = -1,
                    includes = arrayIncludes,
                    isCommon = true,
                    length = array.length,
                    result = [],
                    valuesLength = values.length;

                  if (!length) {
                    return result;
                  }
                  if (iteratee) {
                    values = arrayMap(values, baseUnary(iteratee));
                  }
                  if (comparator) {
                    includes = arrayIncludesWith;
                    isCommon = false;
                  } else if (values.length >= LARGE_ARRAY_SIZE) {
                    includes = cacheHas;
                    isCommon = false;
                    values = new SetCache(values);
                  }
                  outer: while (++index < length) {
                    var value = array[index],
                      computed = iteratee == null ? value : iteratee(value);

                    value = comparator || value !== 0 ? value : 0;
                    if (isCommon && computed === computed) {
                      var valuesIndex = valuesLength;
                      while (valuesIndex--) {
                        if (values[valuesIndex] === computed) {
                          continue outer;
                        }
                      }
                      result.push(value);
                    } else if (!includes(values, computed, comparator)) {
                      result.push(value);
                    }
                  }
                  return result;
                }

                /**
                 * The base implementation of `_.forEach` without support for iteratee shorthands.
                 *
                 * @private
                 * @param {Array|Object} collection The collection to iterate over.
                 * @param {Function} iteratee The function invoked per iteration.
                 * @returns {Array|Object} Returns `collection`.
                 */
                var baseEach = createBaseEach(baseForOwn);

                /**
                 * The base implementation of `_.forEachRight` without support for iteratee shorthands.
                 *
                 * @private
                 * @param {Array|Object} collection The collection to iterate over.
                 * @param {Function} iteratee The function invoked per iteration.
                 * @returns {Array|Object} Returns `collection`.
                 */
                var baseEachRight = createBaseEach(baseForOwnRight, true);

                /**
                 * The base implementation of `_.every` without support for iteratee shorthands.
                 *
                 * @private
                 * @param {Array|Object} collection The collection to iterate over.
                 * @param {Function} predicate The function invoked per iteration.
                 * @returns {boolean} Returns `true` if all elements pass the predicate check,
                 *  else `false`
                 */
                function baseEvery(collection, predicate) {
                  var result = true;
                  baseEach(collection, function (value, index, collection) {
                    result = !!predicate(value, index, collection);
                    return result;
                  });
                  return result;
                }

                /**
                 * The base implementation of methods like `_.max` and `_.min` which accepts a
                 * `comparator` to determine the extremum value.
                 *
                 * @private
                 * @param {Array} array The array to iterate over.
                 * @param {Function} iteratee The iteratee invoked per iteration.
                 * @param {Function} comparator The comparator used to compare values.
                 * @returns {*} Returns the extremum value.
                 */
                function baseExtremum(array, iteratee, comparator) {
                  var index = -1,
                    length = array.length;

                  while (++index < length) {
                    var value = array[index],
                      current = iteratee(value);

                    if (
                      current != null &&
                      (computed === undefined
                        ? current === current && !isSymbol(current)
                        : comparator(current, computed))
                    ) {
                      var computed = current,
                        result = value;
                    }
                  }
                  return result;
                }

                /**
                 * The base implementation of `_.fill` without an iteratee call guard.
                 *
                 * @private
                 * @param {Array} array The array to fill.
                 * @param {*} value The value to fill `array` with.
                 * @param {number} [start=0] The start position.
                 * @param {number} [end=array.length] The end position.
                 * @returns {Array} Returns `array`.
                 */
                function baseFill(array, value, start, end) {
                  var length = array.length;

                  start = toInteger(start);
                  if (start < 0) {
                    start = -start > length ? 0 : length + start;
                  }
                  end =
                    end === undefined || end > length ? length : toInteger(end);
                  if (end < 0) {
                    end += length;
                  }
                  end = start > end ? 0 : toLength(end);
                  while (start < end) {
                    array[start++] = value;
                  }
                  return array;
                }

                /**
                 * The base implementation of `_.filter` without support for iteratee shorthands.
                 *
                 * @private
                 * @param {Array|Object} collection The collection to iterate over.
                 * @param {Function} predicate The function invoked per iteration.
                 * @returns {Array} Returns the new filtered array.
                 */
                function baseFilter(collection, predicate) {
                  var result = [];
                  baseEach(collection, function (value, index, collection) {
                    if (predicate(value, index, collection)) {
                      result.push(value);
                    }
                  });
                  return result;
                }

                /**
                 * The base implementation of `_.flatten` with support for restricting flattening.
                 *
                 * @private
                 * @param {Array} array The array to flatten.
                 * @param {number} depth The maximum recursion depth.
                 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
                 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
                 * @param {Array} [result=[]] The initial result value.
                 * @returns {Array} Returns the new flattened array.
                 */
                function baseFlatten(
                  array,
                  depth,
                  predicate,
                  isStrict,
                  result
                ) {
                  var index = -1,
                    length = array.length;

                  predicate || (predicate = isFlattenable);
                  result || (result = []);

                  while (++index < length) {
                    var value = array[index];
                    if (depth > 0 && predicate(value)) {
                      if (depth > 1) {
                        // Recursively flatten arrays (susceptible to call stack limits).
                        baseFlatten(
                          value,
                          depth - 1,
                          predicate,
                          isStrict,
                          result
                        );
                      } else {
                        arrayPush(result, value);
                      }
                    } else if (!isStrict) {
                      result[result.length] = value;
                    }
                  }
                  return result;
                }

                /**
                 * The base implementation of `baseForOwn` which iterates over `object`
                 * properties returned by `keysFunc` and invokes `iteratee` for each property.
                 * Iteratee functions may exit iteration early by explicitly returning `false`.
                 *
                 * @private
                 * @param {Object} object The object to iterate over.
                 * @param {Function} iteratee The function invoked per iteration.
                 * @param {Function} keysFunc The function to get the keys of `object`.
                 * @returns {Object} Returns `object`.
                 */
                var baseFor = createBaseFor();

                /**
                 * This function is like `baseFor` except that it iterates over properties
                 * in the opposite order.
                 *
                 * @private
                 * @param {Object} object The object to iterate over.
                 * @param {Function} iteratee The function invoked per iteration.
                 * @param {Function} keysFunc The function to get the keys of `object`.
                 * @returns {Object} Returns `object`.
                 */
                var baseForRight = createBaseFor(true);

                /**
                 * The base implementation of `_.forOwn` without support for iteratee shorthands.
                 *
                 * @private
                 * @param {Object} object The object to iterate over.
                 * @param {Function} iteratee The function invoked per iteration.
                 * @returns {Object} Returns `object`.
                 */
                function baseForOwn(object, iteratee) {
                  return object && baseFor(object, iteratee, keys);
                }

                /**
                 * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
                 *
                 * @private
                 * @param {Object} object The object to iterate over.
                 * @param {Function} iteratee The function invoked per iteration.
                 * @returns {Object} Returns `object`.
                 */
                function baseForOwnRight(object, iteratee) {
                  return object && baseForRight(object, iteratee, keys);
                }

                /**
                 * The base implementation of `_.functions` which creates an array of
                 * `object` function property names filtered from `props`.
                 *
                 * @private
                 * @param {Object} object The object to inspect.
                 * @param {Array} props The property names to filter.
                 * @returns {Array} Returns the function names.
                 */
                function baseFunctions(object, props) {
                  return arrayFilter(props, function (key) {
                    return isFunction(object[key]);
                  });
                }

                /**
                 * The base implementation of `_.get` without support for default values.
                 *
                 * @private
                 * @param {Object} object The object to query.
                 * @param {Array|string} path The path of the property to get.
                 * @returns {*} Returns the resolved value.
                 */
                function baseGet(object, path) {
                  path = castPath(path, object);

                  var index = 0,
                    length = path.length;

                  while (object != null && index < length) {
                    object = object[toKey(path[index++])];
                  }
                  return index && index == length ? object : undefined;
                }

                /**
                 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
                 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
                 * symbols of `object`.
                 *
                 * @private
                 * @param {Object} object The object to query.
                 * @param {Function} keysFunc The function to get the keys of `object`.
                 * @param {Function} symbolsFunc The function to get the symbols of `object`.
                 * @returns {Array} Returns the array of property names and symbols.
                 */
                function baseGetAllKeys(object, keysFunc, symbolsFunc) {
                  var result = keysFunc(object);
                  return isArray(object)
                    ? result
                    : arrayPush(result, symbolsFunc(object));
                }

                /**
                 * The base implementation of `getTag` without fallbacks for buggy environments.
                 *
                 * @private
                 * @param {*} value The value to query.
                 * @returns {string} Returns the `toStringTag`.
                 */
                function baseGetTag(value) {
                  if (value == null) {
                    return value === undefined ? undefinedTag : nullTag;
                  }
                  return symToStringTag && symToStringTag in Object(value)
                    ? getRawTag(value)
                    : objectToString(value);
                }

                /**
                 * The base implementation of `_.gt` which doesn't coerce arguments.
                 *
                 * @private
                 * @param {*} value The value to compare.
                 * @param {*} other The other value to compare.
                 * @returns {boolean} Returns `true` if `value` is greater than `other`,
                 *  else `false`.
                 */
                function baseGt(value, other) {
                  return value > other;
                }

                /**
                 * The base implementation of `_.has` without support for deep paths.
                 *
                 * @private
                 * @param {Object} [object] The object to query.
                 * @param {Array|string} key The key to check.
                 * @returns {boolean} Returns `true` if `key` exists, else `false`.
                 */
                function baseHas(object, key) {
                  return object != null && hasOwnProperty.call(object, key);
                }

                /**
                 * The base implementation of `_.hasIn` without support for deep paths.
                 *
                 * @private
                 * @param {Object} [object] The object to query.
                 * @param {Array|string} key The key to check.
                 * @returns {boolean} Returns `true` if `key` exists, else `false`.
                 */
                function baseHasIn(object, key) {
                  return object != null && key in Object(object);
                }

                /**
                 * The base implementation of `_.inRange` which doesn't coerce arguments.
                 *
                 * @private
                 * @param {number} number The number to check.
                 * @param {number} start The start of the range.
                 * @param {number} end The end of the range.
                 * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
                 */
                function baseInRange(number, start, end) {
                  return (
                    number >= nativeMin(start, end) &&
                    number < nativeMax(start, end)
                  );
                }

                /**
                 * The base implementation of methods like `_.intersection`, without support
                 * for iteratee shorthands, that accepts an array of arrays to inspect.
                 *
                 * @private
                 * @param {Array} arrays The arrays to inspect.
                 * @param {Function} [iteratee] The iteratee invoked per element.
                 * @param {Function} [comparator] The comparator invoked per element.
                 * @returns {Array} Returns the new array of shared values.
                 */
                function baseIntersection(arrays, iteratee, comparator) {
                  var includes = comparator ? arrayIncludesWith : arrayIncludes,
                    length = arrays[0].length,
                    othLength = arrays.length,
                    othIndex = othLength,
                    caches = Array(othLength),
                    maxLength = Infinity,
                    result = [];

                  while (othIndex--) {
                    var array = arrays[othIndex];
                    if (othIndex && iteratee) {
                      array = arrayMap(array, baseUnary(iteratee));
                    }
                    maxLength = nativeMin(array.length, maxLength);
                    caches[othIndex] =
                      !comparator &&
                      (iteratee || (length >= 120 && array.length >= 120))
                        ? new SetCache(othIndex && array)
                        : undefined;
                  }
                  array = arrays[0];

                  var index = -1,
                    seen = caches[0];

                  outer: while (++index < length && result.length < maxLength) {
                    var value = array[index],
                      computed = iteratee ? iteratee(value) : value;

                    value = comparator || value !== 0 ? value : 0;
                    if (
                      !(seen
                        ? cacheHas(seen, computed)
                        : includes(result, computed, comparator))
                    ) {
                      othIndex = othLength;
                      while (--othIndex) {
                        var cache = caches[othIndex];
                        if (
                          !(cache
                            ? cacheHas(cache, computed)
                            : includes(arrays[othIndex], computed, comparator))
                        ) {
                          continue outer;
                        }
                      }
                      if (seen) {
                        seen.push(computed);
                      }
                      result.push(value);
                    }
                  }
                  return result;
                }

                /**
                 * The base implementation of `_.invert` and `_.invertBy` which inverts
                 * `object` with values transformed by `iteratee` and set by `setter`.
                 *
                 * @private
                 * @param {Object} object The object to iterate over.
                 * @param {Function} setter The function to set `accumulator` values.
                 * @param {Function} iteratee The iteratee to transform values.
                 * @param {Object} accumulator The initial inverted object.
                 * @returns {Function} Returns `accumulator`.
                 */
                function baseInverter(object, setter, iteratee, accumulator) {
                  baseForOwn(object, function (value, key, object) {
                    setter(accumulator, iteratee(value), key, object);
                  });
                  return accumulator;
                }

                /**
                 * The base implementation of `_.invoke` without support for individual
                 * method arguments.
                 *
                 * @private
                 * @param {Object} object The object to query.
                 * @param {Array|string} path The path of the method to invoke.
                 * @param {Array} args The arguments to invoke the method with.
                 * @returns {*} Returns the result of the invoked method.
                 */
                function baseInvoke(object, path, args) {
                  path = castPath(path, object);
                  object = parent(object, path);
                  var func =
                    object == null ? object : object[toKey(last(path))];
                  return func == null ? undefined : apply(func, object, args);
                }

                /**
                 * The base implementation of `_.isArguments`.
                 *
                 * @private
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
                 */
                function baseIsArguments(value) {
                  return isObjectLike(value) && baseGetTag(value) == argsTag;
                }

                /**
                 * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
                 *
                 * @private
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
                 */
                function baseIsArrayBuffer(value) {
                  return (
                    isObjectLike(value) && baseGetTag(value) == arrayBufferTag
                  );
                }

                /**
                 * The base implementation of `_.isDate` without Node.js optimizations.
                 *
                 * @private
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
                 */
                function baseIsDate(value) {
                  return isObjectLike(value) && baseGetTag(value) == dateTag;
                }

                /**
                 * The base implementation of `_.isEqual` which supports partial comparisons
                 * and tracks traversed objects.
                 *
                 * @private
                 * @param {*} value The value to compare.
                 * @param {*} other The other value to compare.
                 * @param {boolean} bitmask The bitmask flags.
                 *  1 - Unordered comparison
                 *  2 - Partial comparison
                 * @param {Function} [customizer] The function to customize comparisons.
                 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
                 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
                 */
                function baseIsEqual(value, other, bitmask, customizer, stack) {
                  if (value === other) {
                    return true;
                  }
                  if (
                    value == null ||
                    other == null ||
                    (!isObjectLike(value) && !isObjectLike(other))
                  ) {
                    return value !== value && other !== other;
                  }
                  return baseIsEqualDeep(
                    value,
                    other,
                    bitmask,
                    customizer,
                    baseIsEqual,
                    stack
                  );
                }

                /**
                 * A specialized version of `baseIsEqual` for arrays and objects which performs
                 * deep comparisons and tracks traversed objects enabling objects with circular
                 * references to be compared.
                 *
                 * @private
                 * @param {Object} object The object to compare.
                 * @param {Object} other The other object to compare.
                 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
                 * @param {Function} customizer The function to customize comparisons.
                 * @param {Function} equalFunc The function to determine equivalents of values.
                 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
                 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
                 */
                function baseIsEqualDeep(
                  object,
                  other,
                  bitmask,
                  customizer,
                  equalFunc,
                  stack
                ) {
                  var objIsArr = isArray(object),
                    othIsArr = isArray(other),
                    objTag = objIsArr ? arrayTag : getTag(object),
                    othTag = othIsArr ? arrayTag : getTag(other);

                  objTag = objTag == argsTag ? objectTag : objTag;
                  othTag = othTag == argsTag ? objectTag : othTag;

                  var objIsObj = objTag == objectTag,
                    othIsObj = othTag == objectTag,
                    isSameTag = objTag == othTag;

                  if (isSameTag && isBuffer(object)) {
                    if (!isBuffer(other)) {
                      return false;
                    }
                    objIsArr = true;
                    objIsObj = false;
                  }
                  if (isSameTag && !objIsObj) {
                    stack || (stack = new Stack());
                    return objIsArr || isTypedArray(object)
                      ? equalArrays(
                          object,
                          other,
                          bitmask,
                          customizer,
                          equalFunc,
                          stack
                        )
                      : equalByTag(
                          object,
                          other,
                          objTag,
                          bitmask,
                          customizer,
                          equalFunc,
                          stack
                        );
                  }
                  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
                    var objIsWrapped =
                        objIsObj && hasOwnProperty.call(object, "__wrapped__"),
                      othIsWrapped =
                        othIsObj && hasOwnProperty.call(other, "__wrapped__");

                    if (objIsWrapped || othIsWrapped) {
                      var objUnwrapped = objIsWrapped ? object.value() : object,
                        othUnwrapped = othIsWrapped ? other.value() : other;

                      stack || (stack = new Stack());
                      return equalFunc(
                        objUnwrapped,
                        othUnwrapped,
                        bitmask,
                        customizer,
                        stack
                      );
                    }
                  }
                  if (!isSameTag) {
                    return false;
                  }
                  stack || (stack = new Stack());
                  return equalObjects(
                    object,
                    other,
                    bitmask,
                    customizer,
                    equalFunc,
                    stack
                  );
                }

                /**
                 * The base implementation of `_.isMap` without Node.js optimizations.
                 *
                 * @private
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
                 */
                function baseIsMap(value) {
                  return isObjectLike(value) && getTag(value) == mapTag;
                }

                /**
                 * The base implementation of `_.isMatch` without support for iteratee shorthands.
                 *
                 * @private
                 * @param {Object} object The object to inspect.
                 * @param {Object} source The object of property values to match.
                 * @param {Array} matchData The property names, values, and compare flags to match.
                 * @param {Function} [customizer] The function to customize comparisons.
                 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
                 */
                function baseIsMatch(object, source, matchData, customizer) {
                  var index = matchData.length,
                    length = index,
                    noCustomizer = !customizer;

                  if (object == null) {
                    return !length;
                  }
                  object = Object(object);
                  while (index--) {
                    var data = matchData[index];
                    if (
                      noCustomizer && data[2]
                        ? data[1] !== object[data[0]]
                        : !(data[0] in object)
                    ) {
                      return false;
                    }
                  }
                  while (++index < length) {
                    data = matchData[index];
                    var key = data[0],
                      objValue = object[key],
                      srcValue = data[1];

                    if (noCustomizer && data[2]) {
                      if (objValue === undefined && !(key in object)) {
                        return false;
                      }
                    } else {
                      var stack = new Stack();
                      if (customizer) {
                        var result = customizer(
                          objValue,
                          srcValue,
                          key,
                          object,
                          source,
                          stack
                        );
                      }
                      if (
                        !(result === undefined
                          ? baseIsEqual(
                              srcValue,
                              objValue,
                              COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG,
                              customizer,
                              stack
                            )
                          : result)
                      ) {
                        return false;
                      }
                    }
                  }
                  return true;
                }

                /**
                 * The base implementation of `_.isNative` without bad shim checks.
                 *
                 * @private
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is a native function,
                 *  else `false`.
                 */
                function baseIsNative(value) {
                  if (!isObject(value) || isMasked(value)) {
                    return false;
                  }
                  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
                  return pattern.test(toSource(value));
                }

                /**
                 * The base implementation of `_.isRegExp` without Node.js optimizations.
                 *
                 * @private
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
                 */
                function baseIsRegExp(value) {
                  return isObjectLike(value) && baseGetTag(value) == regexpTag;
                }

                /**
                 * The base implementation of `_.isSet` without Node.js optimizations.
                 *
                 * @private
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
                 */
                function baseIsSet(value) {
                  return isObjectLike(value) && getTag(value) == setTag;
                }

                /**
                 * The base implementation of `_.isTypedArray` without Node.js optimizations.
                 *
                 * @private
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
                 */
                function baseIsTypedArray(value) {
                  return (
                    isObjectLike(value) &&
                    isLength(value.length) &&
                    !!typedArrayTags[baseGetTag(value)]
                  );
                }

                /**
                 * The base implementation of `_.iteratee`.
                 *
                 * @private
                 * @param {*} [value=_.identity] The value to convert to an iteratee.
                 * @returns {Function} Returns the iteratee.
                 */
                function baseIteratee(value) {
                  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
                  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
                  if (typeof value == "function") {
                    return value;
                  }
                  if (value == null) {
                    return identity;
                  }
                  if (typeof value == "object") {
                    return isArray(value)
                      ? baseMatchesProperty(value[0], value[1])
                      : baseMatches(value);
                  }
                  return property(value);
                }

                /**
                 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
                 *
                 * @private
                 * @param {Object} object The object to query.
                 * @returns {Array} Returns the array of property names.
                 */
                function baseKeys(object) {
                  if (!isPrototype(object)) {
                    return nativeKeys(object);
                  }
                  var result = [];
                  for (var key in Object(object)) {
                    if (
                      hasOwnProperty.call(object, key) &&
                      key != "constructor"
                    ) {
                      result.push(key);
                    }
                  }
                  return result;
                }

                /**
                 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
                 *
                 * @private
                 * @param {Object} object The object to query.
                 * @returns {Array} Returns the array of property names.
                 */
                function baseKeysIn(object) {
                  if (!isObject(object)) {
                    return nativeKeysIn(object);
                  }
                  var isProto = isPrototype(object),
                    result = [];

                  for (var key in object) {
                    if (
                      !(
                        key == "constructor" &&
                        (isProto || !hasOwnProperty.call(object, key))
                      )
                    ) {
                      result.push(key);
                    }
                  }
                  return result;
                }

                /**
                 * The base implementation of `_.lt` which doesn't coerce arguments.
                 *
                 * @private
                 * @param {*} value The value to compare.
                 * @param {*} other The other value to compare.
                 * @returns {boolean} Returns `true` if `value` is less than `other`,
                 *  else `false`.
                 */
                function baseLt(value, other) {
                  return value < other;
                }

                /**
                 * The base implementation of `_.map` without support for iteratee shorthands.
                 *
                 * @private
                 * @param {Array|Object} collection The collection to iterate over.
                 * @param {Function} iteratee The function invoked per iteration.
                 * @returns {Array} Returns the new mapped array.
                 */
                function baseMap(collection, iteratee) {
                  var index = -1,
                    result = isArrayLike(collection)
                      ? Array(collection.length)
                      : [];

                  baseEach(collection, function (value, key, collection) {
                    result[++index] = iteratee(value, key, collection);
                  });
                  return result;
                }

                /**
                 * The base implementation of `_.matches` which doesn't clone `source`.
                 *
                 * @private
                 * @param {Object} source The object of property values to match.
                 * @returns {Function} Returns the new spec function.
                 */
                function baseMatches(source) {
                  var matchData = getMatchData(source);
                  if (matchData.length == 1 && matchData[0][2]) {
                    return matchesStrictComparable(
                      matchData[0][0],
                      matchData[0][1]
                    );
                  }
                  return function (object) {
                    return (
                      object === source ||
                      baseIsMatch(object, source, matchData)
                    );
                  };
                }

                /**
                 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
                 *
                 * @private
                 * @param {string} path The path of the property to get.
                 * @param {*} srcValue The value to match.
                 * @returns {Function} Returns the new spec function.
                 */
                function baseMatchesProperty(path, srcValue) {
                  if (isKey(path) && isStrictComparable(srcValue)) {
                    return matchesStrictComparable(toKey(path), srcValue);
                  }
                  return function (object) {
                    var objValue = get(object, path);
                    return objValue === undefined && objValue === srcValue
                      ? hasIn(object, path)
                      : baseIsEqual(
                          srcValue,
                          objValue,
                          COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG
                        );
                  };
                }

                /**
                 * The base implementation of `_.merge` without support for multiple sources.
                 *
                 * @private
                 * @param {Object} object The destination object.
                 * @param {Object} source The source object.
                 * @param {number} srcIndex The index of `source`.
                 * @param {Function} [customizer] The function to customize merged values.
                 * @param {Object} [stack] Tracks traversed source values and their merged
                 *  counterparts.
                 */
                function baseMerge(
                  object,
                  source,
                  srcIndex,
                  customizer,
                  stack
                ) {
                  if (object === source) {
                    return;
                  }
                  baseFor(
                    source,
                    function (srcValue, key) {
                      stack || (stack = new Stack());
                      if (isObject(srcValue)) {
                        baseMergeDeep(
                          object,
                          source,
                          key,
                          srcIndex,
                          baseMerge,
                          customizer,
                          stack
                        );
                      } else {
                        var newValue = customizer
                          ? customizer(
                              safeGet(object, key),
                              srcValue,
                              key + "",
                              object,
                              source,
                              stack
                            )
                          : undefined;

                        if (newValue === undefined) {
                          newValue = srcValue;
                        }
                        assignMergeValue(object, key, newValue);
                      }
                    },
                    keysIn
                  );
                }

                /**
                 * A specialized version of `baseMerge` for arrays and objects which performs
                 * deep merges and tracks traversed objects enabling objects with circular
                 * references to be merged.
                 *
                 * @private
                 * @param {Object} object The destination object.
                 * @param {Object} source The source object.
                 * @param {string} key The key of the value to merge.
                 * @param {number} srcIndex The index of `source`.
                 * @param {Function} mergeFunc The function to merge values.
                 * @param {Function} [customizer] The function to customize assigned values.
                 * @param {Object} [stack] Tracks traversed source values and their merged
                 *  counterparts.
                 */
                function baseMergeDeep(
                  object,
                  source,
                  key,
                  srcIndex,
                  mergeFunc,
                  customizer,
                  stack
                ) {
                  var objValue = safeGet(object, key),
                    srcValue = safeGet(source, key),
                    stacked = stack.get(srcValue);

                  if (stacked) {
                    assignMergeValue(object, key, stacked);
                    return;
                  }
                  var newValue = customizer
                    ? customizer(
                        objValue,
                        srcValue,
                        key + "",
                        object,
                        source,
                        stack
                      )
                    : undefined;

                  var isCommon = newValue === undefined;

                  if (isCommon) {
                    var isArr = isArray(srcValue),
                      isBuff = !isArr && isBuffer(srcValue),
                      isTyped = !isArr && !isBuff && isTypedArray(srcValue);

                    newValue = srcValue;
                    if (isArr || isBuff || isTyped) {
                      if (isArray(objValue)) {
                        newValue = objValue;
                      } else if (isArrayLikeObject(objValue)) {
                        newValue = copyArray(objValue);
                      } else if (isBuff) {
                        isCommon = false;
                        newValue = cloneBuffer(srcValue, true);
                      } else if (isTyped) {
                        isCommon = false;
                        newValue = cloneTypedArray(srcValue, true);
                      } else {
                        newValue = [];
                      }
                    } else if (
                      isPlainObject(srcValue) ||
                      isArguments(srcValue)
                    ) {
                      newValue = objValue;
                      if (isArguments(objValue)) {
                        newValue = toPlainObject(objValue);
                      } else if (!isObject(objValue) || isFunction(objValue)) {
                        newValue = initCloneObject(srcValue);
                      }
                    } else {
                      isCommon = false;
                    }
                  }
                  if (isCommon) {
                    // Recursively merge objects and arrays (susceptible to call stack limits).
                    stack.set(srcValue, newValue);
                    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
                    stack["delete"](srcValue);
                  }
                  assignMergeValue(object, key, newValue);
                }

                /**
                 * The base implementation of `_.nth` which doesn't coerce arguments.
                 *
                 * @private
                 * @param {Array} array The array to query.
                 * @param {number} n The index of the element to return.
                 * @returns {*} Returns the nth element of `array`.
                 */
                function baseNth(array, n) {
                  var length = array.length;
                  if (!length) {
                    return;
                  }
                  n += n < 0 ? length : 0;
                  return isIndex(n, length) ? array[n] : undefined;
                }

                /**
                 * The base implementation of `_.orderBy` without param guards.
                 *
                 * @private
                 * @param {Array|Object} collection The collection to iterate over.
                 * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
                 * @param {string[]} orders The sort orders of `iteratees`.
                 * @returns {Array} Returns the new sorted array.
                 */
                function baseOrderBy(collection, iteratees, orders) {
                  if (iteratees.length) {
                    iteratees = arrayMap(iteratees, function (iteratee) {
                      if (isArray(iteratee)) {
                        return function (value) {
                          return baseGet(
                            value,
                            iteratee.length === 1 ? iteratee[0] : iteratee
                          );
                        };
                      }
                      return iteratee;
                    });
                  } else {
                    iteratees = [identity];
                  }

                  var index = -1;
                  iteratees = arrayMap(iteratees, baseUnary(getIteratee()));

                  var result = baseMap(collection, function (
                    value,
                    key,
                    collection
                  ) {
                    var criteria = arrayMap(iteratees, function (iteratee) {
                      return iteratee(value);
                    });
                    return { criteria: criteria, index: ++index, value: value };
                  });

                  return baseSortBy(result, function (object, other) {
                    return compareMultiple(object, other, orders);
                  });
                }

                /**
                 * The base implementation of `_.pick` without support for individual
                 * property identifiers.
                 *
                 * @private
                 * @param {Object} object The source object.
                 * @param {string[]} paths The property paths to pick.
                 * @returns {Object} Returns the new object.
                 */
                function basePick(object, paths) {
                  return basePickBy(object, paths, function (value, path) {
                    return hasIn(object, path);
                  });
                }

                /**
                 * The base implementation of  `_.pickBy` without support for iteratee shorthands.
                 *
                 * @private
                 * @param {Object} object The source object.
                 * @param {string[]} paths The property paths to pick.
                 * @param {Function} predicate The function invoked per property.
                 * @returns {Object} Returns the new object.
                 */
                function basePickBy(object, paths, predicate) {
                  var index = -1,
                    length = paths.length,
                    result = {};

                  while (++index < length) {
                    var path = paths[index],
                      value = baseGet(object, path);

                    if (predicate(value, path)) {
                      baseSet(result, castPath(path, object), value);
                    }
                  }
                  return result;
                }

                /**
                 * A specialized version of `baseProperty` which supports deep paths.
                 *
                 * @private
                 * @param {Array|string} path The path of the property to get.
                 * @returns {Function} Returns the new accessor function.
                 */
                function basePropertyDeep(path) {
                  return function (object) {
                    return baseGet(object, path);
                  };
                }

                /**
                 * The base implementation of `_.pullAllBy` without support for iteratee
                 * shorthands.
                 *
                 * @private
                 * @param {Array} array The array to modify.
                 * @param {Array} values The values to remove.
                 * @param {Function} [iteratee] The iteratee invoked per element.
                 * @param {Function} [comparator] The comparator invoked per element.
                 * @returns {Array} Returns `array`.
                 */
                function basePullAll(array, values, iteratee, comparator) {
                  var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
                    index = -1,
                    length = values.length,
                    seen = array;

                  if (array === values) {
                    values = copyArray(values);
                  }
                  if (iteratee) {
                    seen = arrayMap(array, baseUnary(iteratee));
                  }
                  while (++index < length) {
                    var fromIndex = 0,
                      value = values[index],
                      computed = iteratee ? iteratee(value) : value;

                    while (
                      (fromIndex = indexOf(
                        seen,
                        computed,
                        fromIndex,
                        comparator
                      )) > -1
                    ) {
                      if (seen !== array) {
                        splice.call(seen, fromIndex, 1);
                      }
                      splice.call(array, fromIndex, 1);
                    }
                  }
                  return array;
                }

                /**
                 * The base implementation of `_.pullAt` without support for individual
                 * indexes or capturing the removed elements.
                 *
                 * @private
                 * @param {Array} array The array to modify.
                 * @param {number[]} indexes The indexes of elements to remove.
                 * @returns {Array} Returns `array`.
                 */
                function basePullAt(array, indexes) {
                  var length = array ? indexes.length : 0,
                    lastIndex = length - 1;

                  while (length--) {
                    var index = indexes[length];
                    if (length == lastIndex || index !== previous) {
                      var previous = index;
                      if (isIndex(index)) {
                        splice.call(array, index, 1);
                      } else {
                        baseUnset(array, index);
                      }
                    }
                  }
                  return array;
                }

                /**
                 * The base implementation of `_.random` without support for returning
                 * floating-point numbers.
                 *
                 * @private
                 * @param {number} lower The lower bound.
                 * @param {number} upper The upper bound.
                 * @returns {number} Returns the random number.
                 */
                function baseRandom(lower, upper) {
                  return (
                    lower + nativeFloor(nativeRandom() * (upper - lower + 1))
                  );
                }

                /**
                 * The base implementation of `_.range` and `_.rangeRight` which doesn't
                 * coerce arguments.
                 *
                 * @private
                 * @param {number} start The start of the range.
                 * @param {number} end The end of the range.
                 * @param {number} step The value to increment or decrement by.
                 * @param {boolean} [fromRight] Specify iterating from right to left.
                 * @returns {Array} Returns the range of numbers.
                 */
                function baseRange(start, end, step, fromRight) {
                  var index = -1,
                    length = nativeMax(
                      nativeCeil((end - start) / (step || 1)),
                      0
                    ),
                    result = Array(length);

                  while (length--) {
                    result[fromRight ? length : ++index] = start;
                    start += step;
                  }
                  return result;
                }

                /**
                 * The base implementation of `_.repeat` which doesn't coerce arguments.
                 *
                 * @private
                 * @param {string} string The string to repeat.
                 * @param {number} n The number of times to repeat the string.
                 * @returns {string} Returns the repeated string.
                 */
                function baseRepeat(string, n) {
                  var result = "";
                  if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
                    return result;
                  }
                  // Leverage the exponentiation by squaring algorithm for a faster repeat.
                  // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
                  do {
                    if (n % 2) {
                      result += string;
                    }
                    n = nativeFloor(n / 2);
                    if (n) {
                      string += string;
                    }
                  } while (n);

                  return result;
                }

                /**
                 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
                 *
                 * @private
                 * @param {Function} func The function to apply a rest parameter to.
                 * @param {number} [start=func.length-1] The start position of the rest parameter.
                 * @returns {Function} Returns the new function.
                 */
                function baseRest(func, start) {
                  return setToString(
                    overRest(func, start, identity),
                    func + ""
                  );
                }

                /**
                 * The base implementation of `_.sample`.
                 *
                 * @private
                 * @param {Array|Object} collection The collection to sample.
                 * @returns {*} Returns the random element.
                 */
                function baseSample(collection) {
                  return arraySample(values(collection));
                }

                /**
                 * The base implementation of `_.sampleSize` without param guards.
                 *
                 * @private
                 * @param {Array|Object} collection The collection to sample.
                 * @param {number} n The number of elements to sample.
                 * @returns {Array} Returns the random elements.
                 */
                function baseSampleSize(collection, n) {
                  var array = values(collection);
                  return shuffleSelf(array, baseClamp(n, 0, array.length));
                }

                /**
                 * The base implementation of `_.set`.
                 *
                 * @private
                 * @param {Object} object The object to modify.
                 * @param {Array|string} path The path of the property to set.
                 * @param {*} value The value to set.
                 * @param {Function} [customizer] The function to customize path creation.
                 * @returns {Object} Returns `object`.
                 */
                function baseSet(object, path, value, customizer) {
                  if (!isObject(object)) {
                    return object;
                  }
                  path = castPath(path, object);

                  var index = -1,
                    length = path.length,
                    lastIndex = length - 1,
                    nested = object;

                  while (nested != null && ++index < length) {
                    var key = toKey(path[index]),
                      newValue = value;

                    if (
                      key === "__proto__" ||
                      key === "constructor" ||
                      key === "prototype"
                    ) {
                      return object;
                    }

                    if (index != lastIndex) {
                      var objValue = nested[key];
                      newValue = customizer
                        ? customizer(objValue, key, nested)
                        : undefined;
                      if (newValue === undefined) {
                        newValue = isObject(objValue)
                          ? objValue
                          : isIndex(path[index + 1])
                          ? []
                          : {};
                      }
                    }
                    assignValue(nested, key, newValue);
                    nested = nested[key];
                  }
                  return object;
                }

                /**
                 * The base implementation of `setData` without support for hot loop shorting.
                 *
                 * @private
                 * @param {Function} func The function to associate metadata with.
                 * @param {*} data The metadata.
                 * @returns {Function} Returns `func`.
                 */
                var baseSetData = !metaMap
                  ? identity
                  : function (func, data) {
                      metaMap.set(func, data);
                      return func;
                    };

                /**
                 * The base implementation of `setToString` without support for hot loop shorting.
                 *
                 * @private
                 * @param {Function} func The function to modify.
                 * @param {Function} string The `toString` result.
                 * @returns {Function} Returns `func`.
                 */
                var baseSetToString = !defineProperty
                  ? identity
                  : function (func, string) {
                      return defineProperty(func, "toString", {
                        configurable: true,
                        enumerable: false,
                        value: constant(string),
                        writable: true,
                      });
                    };

                /**
                 * The base implementation of `_.shuffle`.
                 *
                 * @private
                 * @param {Array|Object} collection The collection to shuffle.
                 * @returns {Array} Returns the new shuffled array.
                 */
                function baseShuffle(collection) {
                  return shuffleSelf(values(collection));
                }

                /**
                 * The base implementation of `_.slice` without an iteratee call guard.
                 *
                 * @private
                 * @param {Array} array The array to slice.
                 * @param {number} [start=0] The start position.
                 * @param {number} [end=array.length] The end position.
                 * @returns {Array} Returns the slice of `array`.
                 */
                function baseSlice(array, start, end) {
                  var index = -1,
                    length = array.length;

                  if (start < 0) {
                    start = -start > length ? 0 : length + start;
                  }
                  end = end > length ? length : end;
                  if (end < 0) {
                    end += length;
                  }
                  length = start > end ? 0 : (end - start) >>> 0;
                  start >>>= 0;

                  var result = Array(length);
                  while (++index < length) {
                    result[index] = array[index + start];
                  }
                  return result;
                }

                /**
                 * The base implementation of `_.some` without support for iteratee shorthands.
                 *
                 * @private
                 * @param {Array|Object} collection The collection to iterate over.
                 * @param {Function} predicate The function invoked per iteration.
                 * @returns {boolean} Returns `true` if any element passes the predicate check,
                 *  else `false`.
                 */
                function baseSome(collection, predicate) {
                  var result;

                  baseEach(collection, function (value, index, collection) {
                    result = predicate(value, index, collection);
                    return !result;
                  });
                  return !!result;
                }

                /**
                 * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
                 * performs a binary search of `array` to determine the index at which `value`
                 * should be inserted into `array` in order to maintain its sort order.
                 *
                 * @private
                 * @param {Array} array The sorted array to inspect.
                 * @param {*} value The value to evaluate.
                 * @param {boolean} [retHighest] Specify returning the highest qualified index.
                 * @returns {number} Returns the index at which `value` should be inserted
                 *  into `array`.
                 */
                function baseSortedIndex(array, value, retHighest) {
                  var low = 0,
                    high = array == null ? low : array.length;

                  if (
                    typeof value == "number" &&
                    value === value &&
                    high <= HALF_MAX_ARRAY_LENGTH
                  ) {
                    while (low < high) {
                      var mid = (low + high) >>> 1,
                        computed = array[mid];

                      if (
                        computed !== null &&
                        !isSymbol(computed) &&
                        (retHighest ? computed <= value : computed < value)
                      ) {
                        low = mid + 1;
                      } else {
                        high = mid;
                      }
                    }
                    return high;
                  }
                  return baseSortedIndexBy(array, value, identity, retHighest);
                }

                /**
                 * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
                 * which invokes `iteratee` for `value` and each element of `array` to compute
                 * their sort ranking. The iteratee is invoked with one argument; (value).
                 *
                 * @private
                 * @param {Array} array The sorted array to inspect.
                 * @param {*} value The value to evaluate.
                 * @param {Function} iteratee The iteratee invoked per element.
                 * @param {boolean} [retHighest] Specify returning the highest qualified index.
                 * @returns {number} Returns the index at which `value` should be inserted
                 *  into `array`.
                 */
                function baseSortedIndexBy(array, value, iteratee, retHighest) {
                  var low = 0,
                    high = array == null ? 0 : array.length;
                  if (high === 0) {
                    return 0;
                  }

                  value = iteratee(value);
                  var valIsNaN = value !== value,
                    valIsNull = value === null,
                    valIsSymbol = isSymbol(value),
                    valIsUndefined = value === undefined;

                  while (low < high) {
                    var mid = nativeFloor((low + high) / 2),
                      computed = iteratee(array[mid]),
                      othIsDefined = computed !== undefined,
                      othIsNull = computed === null,
                      othIsReflexive = computed === computed,
                      othIsSymbol = isSymbol(computed);

                    if (valIsNaN) {
                      var setLow = retHighest || othIsReflexive;
                    } else if (valIsUndefined) {
                      setLow = othIsReflexive && (retHighest || othIsDefined);
                    } else if (valIsNull) {
                      setLow =
                        othIsReflexive &&
                        othIsDefined &&
                        (retHighest || !othIsNull);
                    } else if (valIsSymbol) {
                      setLow =
                        othIsReflexive &&
                        othIsDefined &&
                        !othIsNull &&
                        (retHighest || !othIsSymbol);
                    } else if (othIsNull || othIsSymbol) {
                      setLow = false;
                    } else {
                      setLow = retHighest
                        ? computed <= value
                        : computed < value;
                    }
                    if (setLow) {
                      low = mid + 1;
                    } else {
                      high = mid;
                    }
                  }
                  return nativeMin(high, MAX_ARRAY_INDEX);
                }

                /**
                 * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
                 * support for iteratee shorthands.
                 *
                 * @private
                 * @param {Array} array The array to inspect.
                 * @param {Function} [iteratee] The iteratee invoked per element.
                 * @returns {Array} Returns the new duplicate free array.
                 */
                function baseSortedUniq(array, iteratee) {
                  var index = -1,
                    length = array.length,
                    resIndex = 0,
                    result = [];

                  while (++index < length) {
                    var value = array[index],
                      computed = iteratee ? iteratee(value) : value;

                    if (!index || !eq(computed, seen)) {
                      var seen = computed;
                      result[resIndex++] = value === 0 ? 0 : value;
                    }
                  }
                  return result;
                }

                /**
                 * The base implementation of `_.toNumber` which doesn't ensure correct
                 * conversions of binary, hexadecimal, or octal string values.
                 *
                 * @private
                 * @param {*} value The value to process.
                 * @returns {number} Returns the number.
                 */
                function baseToNumber(value) {
                  if (typeof value == "number") {
                    return value;
                  }
                  if (isSymbol(value)) {
                    return NAN;
                  }
                  return +value;
                }

                /**
                 * The base implementation of `_.toString` which doesn't convert nullish
                 * values to empty strings.
                 *
                 * @private
                 * @param {*} value The value to process.
                 * @returns {string} Returns the string.
                 */
                function baseToString(value) {
                  // Exit early for strings to avoid a performance hit in some environments.
                  if (typeof value == "string") {
                    return value;
                  }
                  if (isArray(value)) {
                    // Recursively convert values (susceptible to call stack limits).
                    return arrayMap(value, baseToString) + "";
                  }
                  if (isSymbol(value)) {
                    return symbolToString ? symbolToString.call(value) : "";
                  }
                  var result = value + "";
                  return result == "0" && 1 / value == -INFINITY
                    ? "-0"
                    : result;
                }

                /**
                 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
                 *
                 * @private
                 * @param {Array} array The array to inspect.
                 * @param {Function} [iteratee] The iteratee invoked per element.
                 * @param {Function} [comparator] The comparator invoked per element.
                 * @returns {Array} Returns the new duplicate free array.
                 */
                function baseUniq(array, iteratee, comparator) {
                  var index = -1,
                    includes = arrayIncludes,
                    length = array.length,
                    isCommon = true,
                    result = [],
                    seen = result;

                  if (comparator) {
                    isCommon = false;
                    includes = arrayIncludesWith;
                  } else if (length >= LARGE_ARRAY_SIZE) {
                    var set = iteratee ? null : createSet(array);
                    if (set) {
                      return setToArray(set);
                    }
                    isCommon = false;
                    includes = cacheHas;
                    seen = new SetCache();
                  } else {
                    seen = iteratee ? [] : result;
                  }
                  outer: while (++index < length) {
                    var value = array[index],
                      computed = iteratee ? iteratee(value) : value;

                    value = comparator || value !== 0 ? value : 0;
                    if (isCommon && computed === computed) {
                      var seenIndex = seen.length;
                      while (seenIndex--) {
                        if (seen[seenIndex] === computed) {
                          continue outer;
                        }
                      }
                      if (iteratee) {
                        seen.push(computed);
                      }
                      result.push(value);
                    } else if (!includes(seen, computed, comparator)) {
                      if (seen !== result) {
                        seen.push(computed);
                      }
                      result.push(value);
                    }
                  }
                  return result;
                }

                /**
                 * The base implementation of `_.unset`.
                 *
                 * @private
                 * @param {Object} object The object to modify.
                 * @param {Array|string} path The property path to unset.
                 * @returns {boolean} Returns `true` if the property is deleted, else `false`.
                 */
                function baseUnset(object, path) {
                  path = castPath(path, object);
                  object = parent(object, path);
                  return object == null || delete object[toKey(last(path))];
                }

                /**
                 * The base implementation of `_.update`.
                 *
                 * @private
                 * @param {Object} object The object to modify.
                 * @param {Array|string} path The path of the property to update.
                 * @param {Function} updater The function to produce the updated value.
                 * @param {Function} [customizer] The function to customize path creation.
                 * @returns {Object} Returns `object`.
                 */
                function baseUpdate(object, path, updater, customizer) {
                  return baseSet(
                    object,
                    path,
                    updater(baseGet(object, path)),
                    customizer
                  );
                }

                /**
                 * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
                 * without support for iteratee shorthands.
                 *
                 * @private
                 * @param {Array} array The array to query.
                 * @param {Function} predicate The function invoked per iteration.
                 * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
                 * @param {boolean} [fromRight] Specify iterating from right to left.
                 * @returns {Array} Returns the slice of `array`.
                 */
                function baseWhile(array, predicate, isDrop, fromRight) {
                  var length = array.length,
                    index = fromRight ? length : -1;

                  while (
                    (fromRight ? index-- : ++index < length) &&
                    predicate(array[index], index, array)
                  ) {}

                  return isDrop
                    ? baseSlice(
                        array,
                        fromRight ? 0 : index,
                        fromRight ? index + 1 : length
                      )
                    : baseSlice(
                        array,
                        fromRight ? index + 1 : 0,
                        fromRight ? length : index
                      );
                }

                /**
                 * The base implementation of `wrapperValue` which returns the result of
                 * performing a sequence of actions on the unwrapped `value`, where each
                 * successive action is supplied the return value of the previous.
                 *
                 * @private
                 * @param {*} value The unwrapped value.
                 * @param {Array} actions Actions to perform to resolve the unwrapped value.
                 * @returns {*} Returns the resolved value.
                 */
                function baseWrapperValue(value, actions) {
                  var result = value;
                  if (result instanceof LazyWrapper) {
                    result = result.value();
                  }
                  return arrayReduce(
                    actions,
                    function (result, action) {
                      return action.func.apply(
                        action.thisArg,
                        arrayPush([result], action.args)
                      );
                    },
                    result
                  );
                }

                /**
                 * The base implementation of methods like `_.xor`, without support for
                 * iteratee shorthands, that accepts an array of arrays to inspect.
                 *
                 * @private
                 * @param {Array} arrays The arrays to inspect.
                 * @param {Function} [iteratee] The iteratee invoked per element.
                 * @param {Function} [comparator] The comparator invoked per element.
                 * @returns {Array} Returns the new array of values.
                 */
                function baseXor(arrays, iteratee, comparator) {
                  var length = arrays.length;
                  if (length < 2) {
                    return length ? baseUniq(arrays[0]) : [];
                  }
                  var index = -1,
                    result = Array(length);

                  while (++index < length) {
                    var array = arrays[index],
                      othIndex = -1;

                    while (++othIndex < length) {
                      if (othIndex != index) {
                        result[index] = baseDifference(
                          result[index] || array,
                          arrays[othIndex],
                          iteratee,
                          comparator
                        );
                      }
                    }
                  }
                  return baseUniq(baseFlatten(result, 1), iteratee, comparator);
                }

                /**
                 * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
                 *
                 * @private
                 * @param {Array} props The property identifiers.
                 * @param {Array} values The property values.
                 * @param {Function} assignFunc The function to assign values.
                 * @returns {Object} Returns the new object.
                 */
                function baseZipObject(props, values, assignFunc) {
                  var index = -1,
                    length = props.length,
                    valsLength = values.length,
                    result = {};

                  while (++index < length) {
                    var value = index < valsLength ? values[index] : undefined;
                    assignFunc(result, props[index], value);
                  }
                  return result;
                }

                /**
                 * Casts `value` to an empty array if it's not an array like object.
                 *
                 * @private
                 * @param {*} value The value to inspect.
                 * @returns {Array|Object} Returns the cast array-like object.
                 */
                function castArrayLikeObject(value) {
                  return isArrayLikeObject(value) ? value : [];
                }

                /**
                 * Casts `value` to `identity` if it's not a function.
                 *
                 * @private
                 * @param {*} value The value to inspect.
                 * @returns {Function} Returns cast function.
                 */
                function castFunction(value) {
                  return typeof value == "function" ? value : identity;
                }

                /**
                 * Casts `value` to a path array if it's not one.
                 *
                 * @private
                 * @param {*} value The value to inspect.
                 * @param {Object} [object] The object to query keys on.
                 * @returns {Array} Returns the cast property path array.
                 */
                function castPath(value, object) {
                  if (isArray(value)) {
                    return value;
                  }
                  return isKey(value, object)
                    ? [value]
                    : stringToPath(toString(value));
                }

                /**
                 * A `baseRest` alias which can be replaced with `identity` by module
                 * replacement plugins.
                 *
                 * @private
                 * @type {Function}
                 * @param {Function} func The function to apply a rest parameter to.
                 * @returns {Function} Returns the new function.
                 */
                var castRest = baseRest;

                /**
                 * Casts `array` to a slice if it's needed.
                 *
                 * @private
                 * @param {Array} array The array to inspect.
                 * @param {number} start The start position.
                 * @param {number} [end=array.length] The end position.
                 * @returns {Array} Returns the cast slice.
                 */
                function castSlice(array, start, end) {
                  var length = array.length;
                  end = end === undefined ? length : end;
                  return !start && end >= length
                    ? array
                    : baseSlice(array, start, end);
                }

                /**
                 * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
                 *
                 * @private
                 * @param {number|Object} id The timer id or timeout object of the timer to clear.
                 */
                var clearTimeout =
                  ctxClearTimeout ||
                  function (id) {
                    return root.clearTimeout(id);
                  };

                /**
                 * Creates a clone of  `buffer`.
                 *
                 * @private
                 * @param {Buffer} buffer The buffer to clone.
                 * @param {boolean} [isDeep] Specify a deep clone.
                 * @returns {Buffer} Returns the cloned buffer.
                 */
                function cloneBuffer(buffer, isDeep) {
                  if (isDeep) {
                    return buffer.slice();
                  }
                  var length = buffer.length,
                    result = allocUnsafe
                      ? allocUnsafe(length)
                      : new buffer.constructor(length);

                  buffer.copy(result);
                  return result;
                }

                /**
                 * Creates a clone of `arrayBuffer`.
                 *
                 * @private
                 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
                 * @returns {ArrayBuffer} Returns the cloned array buffer.
                 */
                function cloneArrayBuffer(arrayBuffer) {
                  var result = new arrayBuffer.constructor(
                    arrayBuffer.byteLength
                  );
                  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
                  return result;
                }

                /**
                 * Creates a clone of `dataView`.
                 *
                 * @private
                 * @param {Object} dataView The data view to clone.
                 * @param {boolean} [isDeep] Specify a deep clone.
                 * @returns {Object} Returns the cloned data view.
                 */
                function cloneDataView(dataView, isDeep) {
                  var buffer = isDeep
                    ? cloneArrayBuffer(dataView.buffer)
                    : dataView.buffer;
                  return new dataView.constructor(
                    buffer,
                    dataView.byteOffset,
                    dataView.byteLength
                  );
                }

                /**
                 * Creates a clone of `regexp`.
                 *
                 * @private
                 * @param {Object} regexp The regexp to clone.
                 * @returns {Object} Returns the cloned regexp.
                 */
                function cloneRegExp(regexp) {
                  var result = new regexp.constructor(
                    regexp.source,
                    reFlags.exec(regexp)
                  );
                  result.lastIndex = regexp.lastIndex;
                  return result;
                }

                /**
                 * Creates a clone of the `symbol` object.
                 *
                 * @private
                 * @param {Object} symbol The symbol object to clone.
                 * @returns {Object} Returns the cloned symbol object.
                 */
                function cloneSymbol(symbol) {
                  return symbolValueOf
                    ? Object(symbolValueOf.call(symbol))
                    : {};
                }

                /**
                 * Creates a clone of `typedArray`.
                 *
                 * @private
                 * @param {Object} typedArray The typed array to clone.
                 * @param {boolean} [isDeep] Specify a deep clone.
                 * @returns {Object} Returns the cloned typed array.
                 */
                function cloneTypedArray(typedArray, isDeep) {
                  var buffer = isDeep
                    ? cloneArrayBuffer(typedArray.buffer)
                    : typedArray.buffer;
                  return new typedArray.constructor(
                    buffer,
                    typedArray.byteOffset,
                    typedArray.length
                  );
                }

                /**
                 * Compares values to sort them in ascending order.
                 *
                 * @private
                 * @param {*} value The value to compare.
                 * @param {*} other The other value to compare.
                 * @returns {number} Returns the sort order indicator for `value`.
                 */
                function compareAscending(value, other) {
                  if (value !== other) {
                    var valIsDefined = value !== undefined,
                      valIsNull = value === null,
                      valIsReflexive = value === value,
                      valIsSymbol = isSymbol(value);

                    var othIsDefined = other !== undefined,
                      othIsNull = other === null,
                      othIsReflexive = other === other,
                      othIsSymbol = isSymbol(other);

                    if (
                      (!othIsNull &&
                        !othIsSymbol &&
                        !valIsSymbol &&
                        value > other) ||
                      (valIsSymbol &&
                        othIsDefined &&
                        othIsReflexive &&
                        !othIsNull &&
                        !othIsSymbol) ||
                      (valIsNull && othIsDefined && othIsReflexive) ||
                      (!valIsDefined && othIsReflexive) ||
                      !valIsReflexive
                    ) {
                      return 1;
                    }
                    if (
                      (!valIsNull &&
                        !valIsSymbol &&
                        !othIsSymbol &&
                        value < other) ||
                      (othIsSymbol &&
                        valIsDefined &&
                        valIsReflexive &&
                        !valIsNull &&
                        !valIsSymbol) ||
                      (othIsNull && valIsDefined && valIsReflexive) ||
                      (!othIsDefined && valIsReflexive) ||
                      !othIsReflexive
                    ) {
                      return -1;
                    }
                  }
                  return 0;
                }

                /**
                 * Used by `_.orderBy` to compare multiple properties of a value to another
                 * and stable sort them.
                 *
                 * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
                 * specify an order of "desc" for descending or "asc" for ascending sort order
                 * of corresponding values.
                 *
                 * @private
                 * @param {Object} object The object to compare.
                 * @param {Object} other The other object to compare.
                 * @param {boolean[]|string[]} orders The order to sort by for each property.
                 * @returns {number} Returns the sort order indicator for `object`.
                 */
                function compareMultiple(object, other, orders) {
                  var index = -1,
                    objCriteria = object.criteria,
                    othCriteria = other.criteria,
                    length = objCriteria.length,
                    ordersLength = orders.length;

                  while (++index < length) {
                    var result = compareAscending(
                      objCriteria[index],
                      othCriteria[index]
                    );
                    if (result) {
                      if (index >= ordersLength) {
                        return result;
                      }
                      var order = orders[index];
                      return result * (order == "desc" ? -1 : 1);
                    }
                  }
                  // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
                  // that causes it, under certain circumstances, to provide the same value for
                  // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
                  // for more details.
                  //
                  // This also ensures a stable sort in V8 and other engines.
                  // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
                  return object.index - other.index;
                }

                /**
                 * Creates an array that is the composition of partially applied arguments,
                 * placeholders, and provided arguments into a single array of arguments.
                 *
                 * @private
                 * @param {Array} args The provided arguments.
                 * @param {Array} partials The arguments to prepend to those provided.
                 * @param {Array} holders The `partials` placeholder indexes.
                 * @params {boolean} [isCurried] Specify composing for a curried function.
                 * @returns {Array} Returns the new array of composed arguments.
                 */
                function composeArgs(args, partials, holders, isCurried) {
                  var argsIndex = -1,
                    argsLength = args.length,
                    holdersLength = holders.length,
                    leftIndex = -1,
                    leftLength = partials.length,
                    rangeLength = nativeMax(argsLength - holdersLength, 0),
                    result = Array(leftLength + rangeLength),
                    isUncurried = !isCurried;

                  while (++leftIndex < leftLength) {
                    result[leftIndex] = partials[leftIndex];
                  }
                  while (++argsIndex < holdersLength) {
                    if (isUncurried || argsIndex < argsLength) {
                      result[holders[argsIndex]] = args[argsIndex];
                    }
                  }
                  while (rangeLength--) {
                    result[leftIndex++] = args[argsIndex++];
                  }
                  return result;
                }

                /**
                 * This function is like `composeArgs` except that the arguments composition
                 * is tailored for `_.partialRight`.
                 *
                 * @private
                 * @param {Array} args The provided arguments.
                 * @param {Array} partials The arguments to append to those provided.
                 * @param {Array} holders The `partials` placeholder indexes.
                 * @params {boolean} [isCurried] Specify composing for a curried function.
                 * @returns {Array} Returns the new array of composed arguments.
                 */
                function composeArgsRight(args, partials, holders, isCurried) {
                  var argsIndex = -1,
                    argsLength = args.length,
                    holdersIndex = -1,
                    holdersLength = holders.length,
                    rightIndex = -1,
                    rightLength = partials.length,
                    rangeLength = nativeMax(argsLength - holdersLength, 0),
                    result = Array(rangeLength + rightLength),
                    isUncurried = !isCurried;

                  while (++argsIndex < rangeLength) {
                    result[argsIndex] = args[argsIndex];
                  }
                  var offset = argsIndex;
                  while (++rightIndex < rightLength) {
                    result[offset + rightIndex] = partials[rightIndex];
                  }
                  while (++holdersIndex < holdersLength) {
                    if (isUncurried || argsIndex < argsLength) {
                      result[offset + holders[holdersIndex]] =
                        args[argsIndex++];
                    }
                  }
                  return result;
                }

                /**
                 * Copies the values of `source` to `array`.
                 *
                 * @private
                 * @param {Array} source The array to copy values from.
                 * @param {Array} [array=[]] The array to copy values to.
                 * @returns {Array} Returns `array`.
                 */
                function copyArray(source, array) {
                  var index = -1,
                    length = source.length;

                  array || (array = Array(length));
                  while (++index < length) {
                    array[index] = source[index];
                  }
                  return array;
                }

                /**
                 * Copies properties of `source` to `object`.
                 *
                 * @private
                 * @param {Object} source The object to copy properties from.
                 * @param {Array} props The property identifiers to copy.
                 * @param {Object} [object={}] The object to copy properties to.
                 * @param {Function} [customizer] The function to customize copied values.
                 * @returns {Object} Returns `object`.
                 */
                function copyObject(source, props, object, customizer) {
                  var isNew = !object;
                  object || (object = {});

                  var index = -1,
                    length = props.length;

                  while (++index < length) {
                    var key = props[index];

                    var newValue = customizer
                      ? customizer(
                          object[key],
                          source[key],
                          key,
                          object,
                          source
                        )
                      : undefined;

                    if (newValue === undefined) {
                      newValue = source[key];
                    }
                    if (isNew) {
                      baseAssignValue(object, key, newValue);
                    } else {
                      assignValue(object, key, newValue);
                    }
                  }
                  return object;
                }

                /**
                 * Copies own symbols of `source` to `object`.
                 *
                 * @private
                 * @param {Object} source The object to copy symbols from.
                 * @param {Object} [object={}] The object to copy symbols to.
                 * @returns {Object} Returns `object`.
                 */
                function copySymbols(source, object) {
                  return copyObject(source, getSymbols(source), object);
                }

                /**
                 * Copies own and inherited symbols of `source` to `object`.
                 *
                 * @private
                 * @param {Object} source The object to copy symbols from.
                 * @param {Object} [object={}] The object to copy symbols to.
                 * @returns {Object} Returns `object`.
                 */
                function copySymbolsIn(source, object) {
                  return copyObject(source, getSymbolsIn(source), object);
                }

                /**
                 * Creates a function like `_.groupBy`.
                 *
                 * @private
                 * @param {Function} setter The function to set accumulator values.
                 * @param {Function} [initializer] The accumulator object initializer.
                 * @returns {Function} Returns the new aggregator function.
                 */
                function createAggregator(setter, initializer) {
                  return function (collection, iteratee) {
                    var func = isArray(collection)
                        ? arrayAggregator
                        : baseAggregator,
                      accumulator = initializer ? initializer() : {};

                    return func(
                      collection,
                      setter,
                      getIteratee(iteratee, 2),
                      accumulator
                    );
                  };
                }

                /**
                 * Creates a function like `_.assign`.
                 *
                 * @private
                 * @param {Function} assigner The function to assign values.
                 * @returns {Function} Returns the new assigner function.
                 */
                function createAssigner(assigner) {
                  return baseRest(function (object, sources) {
                    var index = -1,
                      length = sources.length,
                      customizer = length > 1 ? sources[length - 1] : undefined,
                      guard = length > 2 ? sources[2] : undefined;

                    customizer =
                      assigner.length > 3 && typeof customizer == "function"
                        ? (length--, customizer)
                        : undefined;

                    if (
                      guard &&
                      isIterateeCall(sources[0], sources[1], guard)
                    ) {
                      customizer = length < 3 ? undefined : customizer;
                      length = 1;
                    }
                    object = Object(object);
                    while (++index < length) {
                      var source = sources[index];
                      if (source) {
                        assigner(object, source, index, customizer);
                      }
                    }
                    return object;
                  });
                }

                /**
                 * Creates a `baseEach` or `baseEachRight` function.
                 *
                 * @private
                 * @param {Function} eachFunc The function to iterate over a collection.
                 * @param {boolean} [fromRight] Specify iterating from right to left.
                 * @returns {Function} Returns the new base function.
                 */
                function createBaseEach(eachFunc, fromRight) {
                  return function (collection, iteratee) {
                    if (collection == null) {
                      return collection;
                    }
                    if (!isArrayLike(collection)) {
                      return eachFunc(collection, iteratee);
                    }
                    var length = collection.length,
                      index = fromRight ? length : -1,
                      iterable = Object(collection);

                    while (fromRight ? index-- : ++index < length) {
                      if (
                        iteratee(iterable[index], index, iterable) === false
                      ) {
                        break;
                      }
                    }
                    return collection;
                  };
                }

                /**
                 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
                 *
                 * @private
                 * @param {boolean} [fromRight] Specify iterating from right to left.
                 * @returns {Function} Returns the new base function.
                 */
                function createBaseFor(fromRight) {
                  return function (object, iteratee, keysFunc) {
                    var index = -1,
                      iterable = Object(object),
                      props = keysFunc(object),
                      length = props.length;

                    while (length--) {
                      var key = props[fromRight ? length : ++index];
                      if (iteratee(iterable[key], key, iterable) === false) {
                        break;
                      }
                    }
                    return object;
                  };
                }

                /**
                 * Creates a function that wraps `func` to invoke it with the optional `this`
                 * binding of `thisArg`.
                 *
                 * @private
                 * @param {Function} func The function to wrap.
                 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
                 * @param {*} [thisArg] The `this` binding of `func`.
                 * @returns {Function} Returns the new wrapped function.
                 */
                function createBind(func, bitmask, thisArg) {
                  var isBind = bitmask & WRAP_BIND_FLAG,
                    Ctor = createCtor(func);

                  function wrapper() {
                    var fn =
                      this && this !== root && this instanceof wrapper
                        ? Ctor
                        : func;
                    return fn.apply(isBind ? thisArg : this, arguments);
                  }
                  return wrapper;
                }

                /**
                 * Creates a function like `_.lowerFirst`.
                 *
                 * @private
                 * @param {string} methodName The name of the `String` case method to use.
                 * @returns {Function} Returns the new case function.
                 */
                function createCaseFirst(methodName) {
                  return function (string) {
                    string = toString(string);

                    var strSymbols = hasUnicode(string)
                      ? stringToArray(string)
                      : undefined;

                    var chr = strSymbols ? strSymbols[0] : string.charAt(0);

                    var trailing = strSymbols
                      ? castSlice(strSymbols, 1).join("")
                      : string.slice(1);

                    return chr[methodName]() + trailing;
                  };
                }

                /**
                 * Creates a function like `_.camelCase`.
                 *
                 * @private
                 * @param {Function} callback The function to combine each word.
                 * @returns {Function} Returns the new compounder function.
                 */
                function createCompounder(callback) {
                  return function (string) {
                    return arrayReduce(
                      words(deburr(string).replace(reApos, "")),
                      callback,
                      ""
                    );
                  };
                }

                /**
                 * Creates a function that produces an instance of `Ctor` regardless of
                 * whether it was invoked as part of a `new` expression or by `call` or `apply`.
                 *
                 * @private
                 * @param {Function} Ctor The constructor to wrap.
                 * @returns {Function} Returns the new wrapped function.
                 */
                function createCtor(Ctor) {
                  return function () {
                    // Use a `switch` statement to work with class constructors. See
                    // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
                    // for more details.
                    var args = arguments;
                    switch (args.length) {
                      case 0:
                        return new Ctor();
                      case 1:
                        return new Ctor(args[0]);
                      case 2:
                        return new Ctor(args[0], args[1]);
                      case 3:
                        return new Ctor(args[0], args[1], args[2]);
                      case 4:
                        return new Ctor(args[0], args[1], args[2], args[3]);
                      case 5:
                        return new Ctor(
                          args[0],
                          args[1],
                          args[2],
                          args[3],
                          args[4]
                        );
                      case 6:
                        return new Ctor(
                          args[0],
                          args[1],
                          args[2],
                          args[3],
                          args[4],
                          args[5]
                        );
                      case 7:
                        return new Ctor(
                          args[0],
                          args[1],
                          args[2],
                          args[3],
                          args[4],
                          args[5],
                          args[6]
                        );
                    }
                    var thisBinding = baseCreate(Ctor.prototype),
                      result = Ctor.apply(thisBinding, args);

                    // Mimic the constructor's `return` behavior.
                    // See https://es5.github.io/#x13.2.2 for more details.
                    return isObject(result) ? result : thisBinding;
                  };
                }

                /**
                 * Creates a function that wraps `func` to enable currying.
                 *
                 * @private
                 * @param {Function} func The function to wrap.
                 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
                 * @param {number} arity The arity of `func`.
                 * @returns {Function} Returns the new wrapped function.
                 */
                function createCurry(func, bitmask, arity) {
                  var Ctor = createCtor(func);

                  function wrapper() {
                    var length = arguments.length,
                      args = Array(length),
                      index = length,
                      placeholder = getHolder(wrapper);

                    while (index--) {
                      args[index] = arguments[index];
                    }
                    var holders =
                      length < 3 &&
                      args[0] !== placeholder &&
                      args[length - 1] !== placeholder
                        ? []
                        : replaceHolders(args, placeholder);

                    length -= holders.length;
                    if (length < arity) {
                      return createRecurry(
                        func,
                        bitmask,
                        createHybrid,
                        wrapper.placeholder,
                        undefined,
                        args,
                        holders,
                        undefined,
                        undefined,
                        arity - length
                      );
                    }
                    var fn =
                      this && this !== root && this instanceof wrapper
                        ? Ctor
                        : func;
                    return apply(fn, this, args);
                  }
                  return wrapper;
                }

                /**
                 * Creates a `_.find` or `_.findLast` function.
                 *
                 * @private
                 * @param {Function} findIndexFunc The function to find the collection index.
                 * @returns {Function} Returns the new find function.
                 */
                function createFind(findIndexFunc) {
                  return function (collection, predicate, fromIndex) {
                    var iterable = Object(collection);
                    if (!isArrayLike(collection)) {
                      var iteratee = getIteratee(predicate, 3);
                      collection = keys(collection);
                      predicate = function (key) {
                        return iteratee(iterable[key], key, iterable);
                      };
                    }
                    var index = findIndexFunc(collection, predicate, fromIndex);
                    return index > -1
                      ? iterable[iteratee ? collection[index] : index]
                      : undefined;
                  };
                }

                /**
                 * Creates a `_.flow` or `_.flowRight` function.
                 *
                 * @private
                 * @param {boolean} [fromRight] Specify iterating from right to left.
                 * @returns {Function} Returns the new flow function.
                 */
                function createFlow(fromRight) {
                  return flatRest(function (funcs) {
                    var length = funcs.length,
                      index = length,
                      prereq = LodashWrapper.prototype.thru;

                    if (fromRight) {
                      funcs.reverse();
                    }
                    while (index--) {
                      var func = funcs[index];
                      if (typeof func != "function") {
                        throw new TypeError(FUNC_ERROR_TEXT);
                      }
                      if (
                        prereq &&
                        !wrapper &&
                        getFuncName(func) == "wrapper"
                      ) {
                        var wrapper = new LodashWrapper([], true);
                      }
                    }
                    index = wrapper ? index : length;
                    while (++index < length) {
                      func = funcs[index];

                      var funcName = getFuncName(func),
                        data =
                          funcName == "wrapper" ? getData(func) : undefined;

                      if (
                        data &&
                        isLaziable(data[0]) &&
                        data[1] ==
                          (WRAP_ARY_FLAG |
                            WRAP_CURRY_FLAG |
                            WRAP_PARTIAL_FLAG |
                            WRAP_REARG_FLAG) &&
                        !data[4].length &&
                        data[9] == 1
                      ) {
                        wrapper = wrapper[getFuncName(data[0])].apply(
                          wrapper,
                          data[3]
                        );
                      } else {
                        wrapper =
                          func.length == 1 && isLaziable(func)
                            ? wrapper[funcName]()
                            : wrapper.thru(func);
                      }
                    }
                    return function () {
                      var args = arguments,
                        value = args[0];

                      if (wrapper && args.length == 1 && isArray(value)) {
                        return wrapper.plant(value).value();
                      }
                      var index = 0,
                        result = length
                          ? funcs[index].apply(this, args)
                          : value;

                      while (++index < length) {
                        result = funcs[index].call(this, result);
                      }
                      return result;
                    };
                  });
                }

                /**
                 * Creates a function that wraps `func` to invoke it with optional `this`
                 * binding of `thisArg`, partial application, and currying.
                 *
                 * @private
                 * @param {Function|string} func The function or method name to wrap.
                 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
                 * @param {*} [thisArg] The `this` binding of `func`.
                 * @param {Array} [partials] The arguments to prepend to those provided to
                 *  the new function.
                 * @param {Array} [holders] The `partials` placeholder indexes.
                 * @param {Array} [partialsRight] The arguments to append to those provided
                 *  to the new function.
                 * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
                 * @param {Array} [argPos] The argument positions of the new function.
                 * @param {number} [ary] The arity cap of `func`.
                 * @param {number} [arity] The arity of `func`.
                 * @returns {Function} Returns the new wrapped function.
                 */
                function createHybrid(
                  func,
                  bitmask,
                  thisArg,
                  partials,
                  holders,
                  partialsRight,
                  holdersRight,
                  argPos,
                  ary,
                  arity
                ) {
                  var isAry = bitmask & WRAP_ARY_FLAG,
                    isBind = bitmask & WRAP_BIND_FLAG,
                    isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
                    isCurried =
                      bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
                    isFlip = bitmask & WRAP_FLIP_FLAG,
                    Ctor = isBindKey ? undefined : createCtor(func);

                  function wrapper() {
                    var length = arguments.length,
                      args = Array(length),
                      index = length;

                    while (index--) {
                      args[index] = arguments[index];
                    }
                    if (isCurried) {
                      var placeholder = getHolder(wrapper),
                        holdersCount = countHolders(args, placeholder);
                    }
                    if (partials) {
                      args = composeArgs(args, partials, holders, isCurried);
                    }
                    if (partialsRight) {
                      args = composeArgsRight(
                        args,
                        partialsRight,
                        holdersRight,
                        isCurried
                      );
                    }
                    length -= holdersCount;
                    if (isCurried && length < arity) {
                      var newHolders = replaceHolders(args, placeholder);
                      return createRecurry(
                        func,
                        bitmask,
                        createHybrid,
                        wrapper.placeholder,
                        thisArg,
                        args,
                        newHolders,
                        argPos,
                        ary,
                        arity - length
                      );
                    }
                    var thisBinding = isBind ? thisArg : this,
                      fn = isBindKey ? thisBinding[func] : func;

                    length = args.length;
                    if (argPos) {
                      args = reorder(args, argPos);
                    } else if (isFlip && length > 1) {
                      args.reverse();
                    }
                    if (isAry && ary < length) {
                      args.length = ary;
                    }
                    if (this && this !== root && this instanceof wrapper) {
                      fn = Ctor || createCtor(fn);
                    }
                    return fn.apply(thisBinding, args);
                  }
                  return wrapper;
                }

                /**
                 * Creates a function like `_.invertBy`.
                 *
                 * @private
                 * @param {Function} setter The function to set accumulator values.
                 * @param {Function} toIteratee The function to resolve iteratees.
                 * @returns {Function} Returns the new inverter function.
                 */
                function createInverter(setter, toIteratee) {
                  return function (object, iteratee) {
                    return baseInverter(
                      object,
                      setter,
                      toIteratee(iteratee),
                      {}
                    );
                  };
                }

                /**
                 * Creates a function that performs a mathematical operation on two values.
                 *
                 * @private
                 * @param {Function} operator The function to perform the operation.
                 * @param {number} [defaultValue] The value used for `undefined` arguments.
                 * @returns {Function} Returns the new mathematical operation function.
                 */
                function createMathOperation(operator, defaultValue) {
                  return function (value, other) {
                    var result;
                    if (value === undefined && other === undefined) {
                      return defaultValue;
                    }
                    if (value !== undefined) {
                      result = value;
                    }
                    if (other !== undefined) {
                      if (result === undefined) {
                        return other;
                      }
                      if (
                        typeof value == "string" ||
                        typeof other == "string"
                      ) {
                        value = baseToString(value);
                        other = baseToString(other);
                      } else {
                        value = baseToNumber(value);
                        other = baseToNumber(other);
                      }
                      result = operator(value, other);
                    }
                    return result;
                  };
                }

                /**
                 * Creates a function like `_.over`.
                 *
                 * @private
                 * @param {Function} arrayFunc The function to iterate over iteratees.
                 * @returns {Function} Returns the new over function.
                 */
                function createOver(arrayFunc) {
                  return flatRest(function (iteratees) {
                    iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
                    return baseRest(function (args) {
                      var thisArg = this;
                      return arrayFunc(iteratees, function (iteratee) {
                        return apply(iteratee, thisArg, args);
                      });
                    });
                  });
                }

                /**
                 * Creates the padding for `string` based on `length`. The `chars` string
                 * is truncated if the number of characters exceeds `length`.
                 *
                 * @private
                 * @param {number} length The padding length.
                 * @param {string} [chars=' '] The string used as padding.
                 * @returns {string} Returns the padding for `string`.
                 */
                function createPadding(length, chars) {
                  chars = chars === undefined ? " " : baseToString(chars);

                  var charsLength = chars.length;
                  if (charsLength < 2) {
                    return charsLength ? baseRepeat(chars, length) : chars;
                  }
                  var result = baseRepeat(
                    chars,
                    nativeCeil(length / stringSize(chars))
                  );
                  return hasUnicode(chars)
                    ? castSlice(stringToArray(result), 0, length).join("")
                    : result.slice(0, length);
                }

                /**
                 * Creates a function that wraps `func` to invoke it with the `this` binding
                 * of `thisArg` and `partials` prepended to the arguments it receives.
                 *
                 * @private
                 * @param {Function} func The function to wrap.
                 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
                 * @param {*} thisArg The `this` binding of `func`.
                 * @param {Array} partials The arguments to prepend to those provided to
                 *  the new function.
                 * @returns {Function} Returns the new wrapped function.
                 */
                function createPartial(func, bitmask, thisArg, partials) {
                  var isBind = bitmask & WRAP_BIND_FLAG,
                    Ctor = createCtor(func);

                  function wrapper() {
                    var argsIndex = -1,
                      argsLength = arguments.length,
                      leftIndex = -1,
                      leftLength = partials.length,
                      args = Array(leftLength + argsLength),
                      fn =
                        this && this !== root && this instanceof wrapper
                          ? Ctor
                          : func;

                    while (++leftIndex < leftLength) {
                      args[leftIndex] = partials[leftIndex];
                    }
                    while (argsLength--) {
                      args[leftIndex++] = arguments[++argsIndex];
                    }
                    return apply(fn, isBind ? thisArg : this, args);
                  }
                  return wrapper;
                }

                /**
                 * Creates a `_.range` or `_.rangeRight` function.
                 *
                 * @private
                 * @param {boolean} [fromRight] Specify iterating from right to left.
                 * @returns {Function} Returns the new range function.
                 */
                function createRange(fromRight) {
                  return function (start, end, step) {
                    if (
                      step &&
                      typeof step != "number" &&
                      isIterateeCall(start, end, step)
                    ) {
                      end = step = undefined;
                    }
                    // Ensure the sign of `-0` is preserved.
                    start = toFinite(start);
                    if (end === undefined) {
                      end = start;
                      start = 0;
                    } else {
                      end = toFinite(end);
                    }
                    step =
                      step === undefined
                        ? start < end
                          ? 1
                          : -1
                        : toFinite(step);
                    return baseRange(start, end, step, fromRight);
                  };
                }

                /**
                 * Creates a function that performs a relational operation on two values.
                 *
                 * @private
                 * @param {Function} operator The function to perform the operation.
                 * @returns {Function} Returns the new relational operation function.
                 */
                function createRelationalOperation(operator) {
                  return function (value, other) {
                    if (
                      !(typeof value == "string" && typeof other == "string")
                    ) {
                      value = toNumber(value);
                      other = toNumber(other);
                    }
                    return operator(value, other);
                  };
                }

                /**
                 * Creates a function that wraps `func` to continue currying.
                 *
                 * @private
                 * @param {Function} func The function to wrap.
                 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
                 * @param {Function} wrapFunc The function to create the `func` wrapper.
                 * @param {*} placeholder The placeholder value.
                 * @param {*} [thisArg] The `this` binding of `func`.
                 * @param {Array} [partials] The arguments to prepend to those provided to
                 *  the new function.
                 * @param {Array} [holders] The `partials` placeholder indexes.
                 * @param {Array} [argPos] The argument positions of the new function.
                 * @param {number} [ary] The arity cap of `func`.
                 * @param {number} [arity] The arity of `func`.
                 * @returns {Function} Returns the new wrapped function.
                 */
                function createRecurry(
                  func,
                  bitmask,
                  wrapFunc,
                  placeholder,
                  thisArg,
                  partials,
                  holders,
                  argPos,
                  ary,
                  arity
                ) {
                  var isCurry = bitmask & WRAP_CURRY_FLAG,
                    newHolders = isCurry ? holders : undefined,
                    newHoldersRight = isCurry ? undefined : holders,
                    newPartials = isCurry ? partials : undefined,
                    newPartialsRight = isCurry ? undefined : partials;

                  bitmask |= isCurry
                    ? WRAP_PARTIAL_FLAG
                    : WRAP_PARTIAL_RIGHT_FLAG;
                  bitmask &= ~(isCurry
                    ? WRAP_PARTIAL_RIGHT_FLAG
                    : WRAP_PARTIAL_FLAG);

                  if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
                    bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
                  }
                  var newData = [
                    func,
                    bitmask,
                    thisArg,
                    newPartials,
                    newHolders,
                    newPartialsRight,
                    newHoldersRight,
                    argPos,
                    ary,
                    arity,
                  ];

                  var result = wrapFunc.apply(undefined, newData);
                  if (isLaziable(func)) {
                    setData(result, newData);
                  }
                  result.placeholder = placeholder;
                  return setWrapToString(result, func, bitmask);
                }

                /**
                 * Creates a function like `_.round`.
                 *
                 * @private
                 * @param {string} methodName The name of the `Math` method to use when rounding.
                 * @returns {Function} Returns the new round function.
                 */
                function createRound(methodName) {
                  var func = Math[methodName];
                  return function (number, precision) {
                    number = toNumber(number);
                    precision =
                      precision == null
                        ? 0
                        : nativeMin(toInteger(precision), 292);
                    if (precision && nativeIsFinite(number)) {
                      // Shift with exponential notation to avoid floating-point issues.
                      // See [MDN](https://mdn.io/round#Examples) for more details.
                      var pair = (toString(number) + "e").split("e"),
                        value = func(pair[0] + "e" + (+pair[1] + precision));

                      pair = (toString(value) + "e").split("e");
                      return +(pair[0] + "e" + (+pair[1] - precision));
                    }
                    return func(number);
                  };
                }

                /**
                 * Creates a set object of `values`.
                 *
                 * @private
                 * @param {Array} values The values to add to the set.
                 * @returns {Object} Returns the new set.
                 */
                var createSet = !(
                  Set && 1 / setToArray(new Set([, -0]))[1] == INFINITY
                )
                  ? noop
                  : function (values) {
                      return new Set(values);
                    };

                /**
                 * Creates a `_.toPairs` or `_.toPairsIn` function.
                 *
                 * @private
                 * @param {Function} keysFunc The function to get the keys of a given object.
                 * @returns {Function} Returns the new pairs function.
                 */
                function createToPairs(keysFunc) {
                  return function (object) {
                    var tag = getTag(object);
                    if (tag == mapTag) {
                      return mapToArray(object);
                    }
                    if (tag == setTag) {
                      return setToPairs(object);
                    }
                    return baseToPairs(object, keysFunc(object));
                  };
                }

                /**
                 * Creates a function that either curries or invokes `func` with optional
                 * `this` binding and partially applied arguments.
                 *
                 * @private
                 * @param {Function|string} func The function or method name to wrap.
                 * @param {number} bitmask The bitmask flags.
                 *    1 - `_.bind`
                 *    2 - `_.bindKey`
                 *    4 - `_.curry` or `_.curryRight` of a bound function
                 *    8 - `_.curry`
                 *   16 - `_.curryRight`
                 *   32 - `_.partial`
                 *   64 - `_.partialRight`
                 *  128 - `_.rearg`
                 *  256 - `_.ary`
                 *  512 - `_.flip`
                 * @param {*} [thisArg] The `this` binding of `func`.
                 * @param {Array} [partials] The arguments to be partially applied.
                 * @param {Array} [holders] The `partials` placeholder indexes.
                 * @param {Array} [argPos] The argument positions of the new function.
                 * @param {number} [ary] The arity cap of `func`.
                 * @param {number} [arity] The arity of `func`.
                 * @returns {Function} Returns the new wrapped function.
                 */
                function createWrap(
                  func,
                  bitmask,
                  thisArg,
                  partials,
                  holders,
                  argPos,
                  ary,
                  arity
                ) {
                  var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
                  if (!isBindKey && typeof func != "function") {
                    throw new TypeError(FUNC_ERROR_TEXT);
                  }
                  var length = partials ? partials.length : 0;
                  if (!length) {
                    bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
                    partials = holders = undefined;
                  }
                  ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
                  arity = arity === undefined ? arity : toInteger(arity);
                  length -= holders ? holders.length : 0;

                  if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
                    var partialsRight = partials,
                      holdersRight = holders;

                    partials = holders = undefined;
                  }
                  var data = isBindKey ? undefined : getData(func);

                  var newData = [
                    func,
                    bitmask,
                    thisArg,
                    partials,
                    holders,
                    partialsRight,
                    holdersRight,
                    argPos,
                    ary,
                    arity,
                  ];

                  if (data) {
                    mergeData(newData, data);
                  }
                  func = newData[0];
                  bitmask = newData[1];
                  thisArg = newData[2];
                  partials = newData[3];
                  holders = newData[4];
                  arity = newData[9] =
                    newData[9] === undefined
                      ? isBindKey
                        ? 0
                        : func.length
                      : nativeMax(newData[9] - length, 0);

                  if (
                    !arity &&
                    bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)
                  ) {
                    bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
                  }
                  if (!bitmask || bitmask == WRAP_BIND_FLAG) {
                    var result = createBind(func, bitmask, thisArg);
                  } else if (
                    bitmask == WRAP_CURRY_FLAG ||
                    bitmask == WRAP_CURRY_RIGHT_FLAG
                  ) {
                    result = createCurry(func, bitmask, arity);
                  } else if (
                    (bitmask == WRAP_PARTIAL_FLAG ||
                      bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) &&
                    !holders.length
                  ) {
                    result = createPartial(func, bitmask, thisArg, partials);
                  } else {
                    result = createHybrid.apply(undefined, newData);
                  }
                  var setter = data ? baseSetData : setData;
                  return setWrapToString(
                    setter(result, newData),
                    func,
                    bitmask
                  );
                }

                /**
                 * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
                 * of source objects to the destination object for all destination properties
                 * that resolve to `undefined`.
                 *
                 * @private
                 * @param {*} objValue The destination value.
                 * @param {*} srcValue The source value.
                 * @param {string} key The key of the property to assign.
                 * @param {Object} object The parent object of `objValue`.
                 * @returns {*} Returns the value to assign.
                 */
                function customDefaultsAssignIn(
                  objValue,
                  srcValue,
                  key,
                  object
                ) {
                  if (
                    objValue === undefined ||
                    (eq(objValue, objectProto[key]) &&
                      !hasOwnProperty.call(object, key))
                  ) {
                    return srcValue;
                  }
                  return objValue;
                }

                /**
                 * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
                 * objects into destination objects that are passed thru.
                 *
                 * @private
                 * @param {*} objValue The destination value.
                 * @param {*} srcValue The source value.
                 * @param {string} key The key of the property to merge.
                 * @param {Object} object The parent object of `objValue`.
                 * @param {Object} source The parent object of `srcValue`.
                 * @param {Object} [stack] Tracks traversed source values and their merged
                 *  counterparts.
                 * @returns {*} Returns the value to assign.
                 */
                function customDefaultsMerge(
                  objValue,
                  srcValue,
                  key,
                  object,
                  source,
                  stack
                ) {
                  if (isObject(objValue) && isObject(srcValue)) {
                    // Recursively merge objects and arrays (susceptible to call stack limits).
                    stack.set(srcValue, objValue);
                    baseMerge(
                      objValue,
                      srcValue,
                      undefined,
                      customDefaultsMerge,
                      stack
                    );
                    stack["delete"](srcValue);
                  }
                  return objValue;
                }

                /**
                 * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
                 * objects.
                 *
                 * @private
                 * @param {*} value The value to inspect.
                 * @param {string} key The key of the property to inspect.
                 * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
                 */
                function customOmitClone(value) {
                  return isPlainObject(value) ? undefined : value;
                }

                /**
                 * A specialized version of `baseIsEqualDeep` for arrays with support for
                 * partial deep comparisons.
                 *
                 * @private
                 * @param {Array} array The array to compare.
                 * @param {Array} other The other array to compare.
                 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
                 * @param {Function} customizer The function to customize comparisons.
                 * @param {Function} equalFunc The function to determine equivalents of values.
                 * @param {Object} stack Tracks traversed `array` and `other` objects.
                 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
                 */
                function equalArrays(
                  array,
                  other,
                  bitmask,
                  customizer,
                  equalFunc,
                  stack
                ) {
                  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
                    arrLength = array.length,
                    othLength = other.length;

                  if (
                    arrLength != othLength &&
                    !(isPartial && othLength > arrLength)
                  ) {
                    return false;
                  }
                  // Check that cyclic values are equal.
                  var arrStacked = stack.get(array);
                  var othStacked = stack.get(other);
                  if (arrStacked && othStacked) {
                    return arrStacked == other && othStacked == array;
                  }
                  var index = -1,
                    result = true,
                    seen =
                      bitmask & COMPARE_UNORDERED_FLAG
                        ? new SetCache()
                        : undefined;

                  stack.set(array, other);
                  stack.set(other, array);

                  // Ignore non-index properties.
                  while (++index < arrLength) {
                    var arrValue = array[index],
                      othValue = other[index];

                    if (customizer) {
                      var compared = isPartial
                        ? customizer(
                            othValue,
                            arrValue,
                            index,
                            other,
                            array,
                            stack
                          )
                        : customizer(
                            arrValue,
                            othValue,
                            index,
                            array,
                            other,
                            stack
                          );
                    }
                    if (compared !== undefined) {
                      if (compared) {
                        continue;
                      }
                      result = false;
                      break;
                    }
                    // Recursively compare arrays (susceptible to call stack limits).
                    if (seen) {
                      if (
                        !arraySome(other, function (othValue, othIndex) {
                          if (
                            !cacheHas(seen, othIndex) &&
                            (arrValue === othValue ||
                              equalFunc(
                                arrValue,
                                othValue,
                                bitmask,
                                customizer,
                                stack
                              ))
                          ) {
                            return seen.push(othIndex);
                          }
                        })
                      ) {
                        result = false;
                        break;
                      }
                    } else if (
                      !(
                        arrValue === othValue ||
                        equalFunc(
                          arrValue,
                          othValue,
                          bitmask,
                          customizer,
                          stack
                        )
                      )
                    ) {
                      result = false;
                      break;
                    }
                  }
                  stack["delete"](array);
                  stack["delete"](other);
                  return result;
                }

                /**
                 * A specialized version of `baseIsEqualDeep` for comparing objects of
                 * the same `toStringTag`.
                 *
                 * **Note:** This function only supports comparing values with tags of
                 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
                 *
                 * @private
                 * @param {Object} object The object to compare.
                 * @param {Object} other The other object to compare.
                 * @param {string} tag The `toStringTag` of the objects to compare.
                 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
                 * @param {Function} customizer The function to customize comparisons.
                 * @param {Function} equalFunc The function to determine equivalents of values.
                 * @param {Object} stack Tracks traversed `object` and `other` objects.
                 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
                 */
                function equalByTag(
                  object,
                  other,
                  tag,
                  bitmask,
                  customizer,
                  equalFunc,
                  stack
                ) {
                  switch (tag) {
                    case dataViewTag:
                      if (
                        object.byteLength != other.byteLength ||
                        object.byteOffset != other.byteOffset
                      ) {
                        return false;
                      }
                      object = object.buffer;
                      other = other.buffer;

                    case arrayBufferTag:
                      if (
                        object.byteLength != other.byteLength ||
                        !equalFunc(
                          new Uint8Array(object),
                          new Uint8Array(other)
                        )
                      ) {
                        return false;
                      }
                      return true;

                    case boolTag:
                    case dateTag:
                    case numberTag:
                      // Coerce booleans to `1` or `0` and dates to milliseconds.
                      // Invalid dates are coerced to `NaN`.
                      return eq(+object, +other);

                    case errorTag:
                      return (
                        object.name == other.name &&
                        object.message == other.message
                      );

                    case regexpTag:
                    case stringTag:
                      // Coerce regexes to strings and treat strings, primitives and objects,
                      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
                      // for more details.
                      return object == other + "";

                    case mapTag:
                      var convert = mapToArray;

                    case setTag:
                      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
                      convert || (convert = setToArray);

                      if (object.size != other.size && !isPartial) {
                        return false;
                      }
                      // Assume cyclic values are equal.
                      var stacked = stack.get(object);
                      if (stacked) {
                        return stacked == other;
                      }
                      bitmask |= COMPARE_UNORDERED_FLAG;

                      // Recursively compare objects (susceptible to call stack limits).
                      stack.set(object, other);
                      var result = equalArrays(
                        convert(object),
                        convert(other),
                        bitmask,
                        customizer,
                        equalFunc,
                        stack
                      );
                      stack["delete"](object);
                      return result;

                    case symbolTag:
                      if (symbolValueOf) {
                        return (
                          symbolValueOf.call(object) ==
                          symbolValueOf.call(other)
                        );
                      }
                  }
                  return false;
                }

                /**
                 * A specialized version of `baseIsEqualDeep` for objects with support for
                 * partial deep comparisons.
                 *
                 * @private
                 * @param {Object} object The object to compare.
                 * @param {Object} other The other object to compare.
                 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
                 * @param {Function} customizer The function to customize comparisons.
                 * @param {Function} equalFunc The function to determine equivalents of values.
                 * @param {Object} stack Tracks traversed `object` and `other` objects.
                 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
                 */
                function equalObjects(
                  object,
                  other,
                  bitmask,
                  customizer,
                  equalFunc,
                  stack
                ) {
                  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
                    objProps = getAllKeys(object),
                    objLength = objProps.length,
                    othProps = getAllKeys(other),
                    othLength = othProps.length;

                  if (objLength != othLength && !isPartial) {
                    return false;
                  }
                  var index = objLength;
                  while (index--) {
                    var key = objProps[index];
                    if (
                      !(isPartial
                        ? key in other
                        : hasOwnProperty.call(other, key))
                    ) {
                      return false;
                    }
                  }
                  // Check that cyclic values are equal.
                  var objStacked = stack.get(object);
                  var othStacked = stack.get(other);
                  if (objStacked && othStacked) {
                    return objStacked == other && othStacked == object;
                  }
                  var result = true;
                  stack.set(object, other);
                  stack.set(other, object);

                  var skipCtor = isPartial;
                  while (++index < objLength) {
                    key = objProps[index];
                    var objValue = object[key],
                      othValue = other[key];

                    if (customizer) {
                      var compared = isPartial
                        ? customizer(
                            othValue,
                            objValue,
                            key,
                            other,
                            object,
                            stack
                          )
                        : customizer(
                            objValue,
                            othValue,
                            key,
                            object,
                            other,
                            stack
                          );
                    }
                    // Recursively compare objects (susceptible to call stack limits).
                    if (
                      !(compared === undefined
                        ? objValue === othValue ||
                          equalFunc(
                            objValue,
                            othValue,
                            bitmask,
                            customizer,
                            stack
                          )
                        : compared)
                    ) {
                      result = false;
                      break;
                    }
                    skipCtor || (skipCtor = key == "constructor");
                  }
                  if (result && !skipCtor) {
                    var objCtor = object.constructor,
                      othCtor = other.constructor;

                    // Non `Object` object instances with different constructors are not equal.
                    if (
                      objCtor != othCtor &&
                      "constructor" in object &&
                      "constructor" in other &&
                      !(
                        typeof objCtor == "function" &&
                        objCtor instanceof objCtor &&
                        typeof othCtor == "function" &&
                        othCtor instanceof othCtor
                      )
                    ) {
                      result = false;
                    }
                  }
                  stack["delete"](object);
                  stack["delete"](other);
                  return result;
                }

                /**
                 * A specialized version of `baseRest` which flattens the rest array.
                 *
                 * @private
                 * @param {Function} func The function to apply a rest parameter to.
                 * @returns {Function} Returns the new function.
                 */
                function flatRest(func) {
                  return setToString(
                    overRest(func, undefined, flatten),
                    func + ""
                  );
                }

                /**
                 * Creates an array of own enumerable property names and symbols of `object`.
                 *
                 * @private
                 * @param {Object} object The object to query.
                 * @returns {Array} Returns the array of property names and symbols.
                 */
                function getAllKeys(object) {
                  return baseGetAllKeys(object, keys, getSymbols);
                }

                /**
                 * Creates an array of own and inherited enumerable property names and
                 * symbols of `object`.
                 *
                 * @private
                 * @param {Object} object The object to query.
                 * @returns {Array} Returns the array of property names and symbols.
                 */
                function getAllKeysIn(object) {
                  return baseGetAllKeys(object, keysIn, getSymbolsIn);
                }

                /**
                 * Gets metadata for `func`.
                 *
                 * @private
                 * @param {Function} func The function to query.
                 * @returns {*} Returns the metadata for `func`.
                 */
                var getData = !metaMap
                  ? noop
                  : function (func) {
                      return metaMap.get(func);
                    };

                /**
                 * Gets the name of `func`.
                 *
                 * @private
                 * @param {Function} func The function to query.
                 * @returns {string} Returns the function name.
                 */
                function getFuncName(func) {
                  var result = func.name + "",
                    array = realNames[result],
                    length = hasOwnProperty.call(realNames, result)
                      ? array.length
                      : 0;

                  while (length--) {
                    var data = array[length],
                      otherFunc = data.func;
                    if (otherFunc == null || otherFunc == func) {
                      return data.name;
                    }
                  }
                  return result;
                }

                /**
                 * Gets the argument placeholder value for `func`.
                 *
                 * @private
                 * @param {Function} func The function to inspect.
                 * @returns {*} Returns the placeholder value.
                 */
                function getHolder(func) {
                  var object = hasOwnProperty.call(lodash, "placeholder")
                    ? lodash
                    : func;
                  return object.placeholder;
                }

                /**
                 * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
                 * this function returns the custom method, otherwise it returns `baseIteratee`.
                 * If arguments are provided, the chosen function is invoked with them and
                 * its result is returned.
                 *
                 * @private
                 * @param {*} [value] The value to convert to an iteratee.
                 * @param {number} [arity] The arity of the created iteratee.
                 * @returns {Function} Returns the chosen function or its result.
                 */
                function getIteratee() {
                  var result = lodash.iteratee || iteratee;
                  result = result === iteratee ? baseIteratee : result;
                  return arguments.length
                    ? result(arguments[0], arguments[1])
                    : result;
                }

                /**
                 * Gets the data for `map`.
                 *
                 * @private
                 * @param {Object} map The map to query.
                 * @param {string} key The reference key.
                 * @returns {*} Returns the map data.
                 */
                function getMapData(map, key) {
                  var data = map.__data__;
                  return isKeyable(key)
                    ? data[typeof key == "string" ? "string" : "hash"]
                    : data.map;
                }

                /**
                 * Gets the property names, values, and compare flags of `object`.
                 *
                 * @private
                 * @param {Object} object The object to query.
                 * @returns {Array} Returns the match data of `object`.
                 */
                function getMatchData(object) {
                  var result = keys(object),
                    length = result.length;

                  while (length--) {
                    var key = result[length],
                      value = object[key];

                    result[length] = [key, value, isStrictComparable(value)];
                  }
                  return result;
                }

                /**
                 * Gets the native function at `key` of `object`.
                 *
                 * @private
                 * @param {Object} object The object to query.
                 * @param {string} key The key of the method to get.
                 * @returns {*} Returns the function if it's native, else `undefined`.
                 */
                function getNative(object, key) {
                  var value = getValue(object, key);
                  return baseIsNative(value) ? value : undefined;
                }

                /**
                 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
                 *
                 * @private
                 * @param {*} value The value to query.
                 * @returns {string} Returns the raw `toStringTag`.
                 */
                function getRawTag(value) {
                  var isOwn = hasOwnProperty.call(value, symToStringTag),
                    tag = value[symToStringTag];

                  try {
                    value[symToStringTag] = undefined;
                    var unmasked = true;
                  } catch (e) {}

                  var result = nativeObjectToString.call(value);
                  if (unmasked) {
                    if (isOwn) {
                      value[symToStringTag] = tag;
                    } else {
                      delete value[symToStringTag];
                    }
                  }
                  return result;
                }

                /**
                 * Creates an array of the own enumerable symbols of `object`.
                 *
                 * @private
                 * @param {Object} object The object to query.
                 * @returns {Array} Returns the array of symbols.
                 */
                var getSymbols = !nativeGetSymbols
                  ? stubArray
                  : function (object) {
                      if (object == null) {
                        return [];
                      }
                      object = Object(object);
                      return arrayFilter(nativeGetSymbols(object), function (
                        symbol
                      ) {
                        return propertyIsEnumerable.call(object, symbol);
                      });
                    };

                /**
                 * Creates an array of the own and inherited enumerable symbols of `object`.
                 *
                 * @private
                 * @param {Object} object The object to query.
                 * @returns {Array} Returns the array of symbols.
                 */
                var getSymbolsIn = !nativeGetSymbols
                  ? stubArray
                  : function (object) {
                      var result = [];
                      while (object) {
                        arrayPush(result, getSymbols(object));
                        object = getPrototype(object);
                      }
                      return result;
                    };

                /**
                 * Gets the `toStringTag` of `value`.
                 *
                 * @private
                 * @param {*} value The value to query.
                 * @returns {string} Returns the `toStringTag`.
                 */
                var getTag = baseGetTag;

                // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
                if (
                  (DataView &&
                    getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
                  (Map && getTag(new Map()) != mapTag) ||
                  (Promise && getTag(Promise.resolve()) != promiseTag) ||
                  (Set && getTag(new Set()) != setTag) ||
                  (WeakMap && getTag(new WeakMap()) != weakMapTag)
                ) {
                  getTag = function (value) {
                    var result = baseGetTag(value),
                      Ctor =
                        result == objectTag ? value.constructor : undefined,
                      ctorString = Ctor ? toSource(Ctor) : "";

                    if (ctorString) {
                      switch (ctorString) {
                        case dataViewCtorString:
                          return dataViewTag;
                        case mapCtorString:
                          return mapTag;
                        case promiseCtorString:
                          return promiseTag;
                        case setCtorString:
                          return setTag;
                        case weakMapCtorString:
                          return weakMapTag;
                      }
                    }
                    return result;
                  };
                }

                /**
                 * Gets the view, applying any `transforms` to the `start` and `end` positions.
                 *
                 * @private
                 * @param {number} start The start of the view.
                 * @param {number} end The end of the view.
                 * @param {Array} transforms The transformations to apply to the view.
                 * @returns {Object} Returns an object containing the `start` and `end`
                 *  positions of the view.
                 */
                function getView(start, end, transforms) {
                  var index = -1,
                    length = transforms.length;

                  while (++index < length) {
                    var data = transforms[index],
                      size = data.size;

                    switch (data.type) {
                      case "drop":
                        start += size;
                        break;
                      case "dropRight":
                        end -= size;
                        break;
                      case "take":
                        end = nativeMin(end, start + size);
                        break;
                      case "takeRight":
                        start = nativeMax(start, end - size);
                        break;
                    }
                  }
                  return { start: start, end: end };
                }

                /**
                 * Extracts wrapper details from the `source` body comment.
                 *
                 * @private
                 * @param {string} source The source to inspect.
                 * @returns {Array} Returns the wrapper details.
                 */
                function getWrapDetails(source) {
                  var match = source.match(reWrapDetails);
                  return match ? match[1].split(reSplitDetails) : [];
                }

                /**
                 * Checks if `path` exists on `object`.
                 *
                 * @private
                 * @param {Object} object The object to query.
                 * @param {Array|string} path The path to check.
                 * @param {Function} hasFunc The function to check properties.
                 * @returns {boolean} Returns `true` if `path` exists, else `false`.
                 */
                function hasPath(object, path, hasFunc) {
                  path = castPath(path, object);

                  var index = -1,
                    length = path.length,
                    result = false;

                  while (++index < length) {
                    var key = toKey(path[index]);
                    if (!(result = object != null && hasFunc(object, key))) {
                      break;
                    }
                    object = object[key];
                  }
                  if (result || ++index != length) {
                    return result;
                  }
                  length = object == null ? 0 : object.length;
                  return (
                    !!length &&
                    isLength(length) &&
                    isIndex(key, length) &&
                    (isArray(object) || isArguments(object))
                  );
                }

                /**
                 * Initializes an array clone.
                 *
                 * @private
                 * @param {Array} array The array to clone.
                 * @returns {Array} Returns the initialized clone.
                 */
                function initCloneArray(array) {
                  var length = array.length,
                    result = new array.constructor(length);

                  // Add properties assigned by `RegExp#exec`.
                  if (
                    length &&
                    typeof array[0] == "string" &&
                    hasOwnProperty.call(array, "index")
                  ) {
                    result.index = array.index;
                    result.input = array.input;
                  }
                  return result;
                }

                /**
                 * Initializes an object clone.
                 *
                 * @private
                 * @param {Object} object The object to clone.
                 * @returns {Object} Returns the initialized clone.
                 */
                function initCloneObject(object) {
                  return typeof object.constructor == "function" &&
                    !isPrototype(object)
                    ? baseCreate(getPrototype(object))
                    : {};
                }

                /**
                 * Initializes an object clone based on its `toStringTag`.
                 *
                 * **Note:** This function only supports cloning values with tags of
                 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
                 *
                 * @private
                 * @param {Object} object The object to clone.
                 * @param {string} tag The `toStringTag` of the object to clone.
                 * @param {boolean} [isDeep] Specify a deep clone.
                 * @returns {Object} Returns the initialized clone.
                 */
                function initCloneByTag(object, tag, isDeep) {
                  var Ctor = object.constructor;
                  switch (tag) {
                    case arrayBufferTag:
                      return cloneArrayBuffer(object);

                    case boolTag:
                    case dateTag:
                      return new Ctor(+object);

                    case dataViewTag:
                      return cloneDataView(object, isDeep);

                    case float32Tag:
                    case float64Tag:
                    case int8Tag:
                    case int16Tag:
                    case int32Tag:
                    case uint8Tag:
                    case uint8ClampedTag:
                    case uint16Tag:
                    case uint32Tag:
                      return cloneTypedArray(object, isDeep);

                    case mapTag:
                      return new Ctor();

                    case numberTag:
                    case stringTag:
                      return new Ctor(object);

                    case regexpTag:
                      return cloneRegExp(object);

                    case setTag:
                      return new Ctor();

                    case symbolTag:
                      return cloneSymbol(object);
                  }
                }

                /**
                 * Inserts wrapper `details` in a comment at the top of the `source` body.
                 *
                 * @private
                 * @param {string} source The source to modify.
                 * @returns {Array} details The details to insert.
                 * @returns {string} Returns the modified source.
                 */
                function insertWrapDetails(source, details) {
                  var length = details.length;
                  if (!length) {
                    return source;
                  }
                  var lastIndex = length - 1;
                  details[lastIndex] =
                    (length > 1 ? "& " : "") + details[lastIndex];
                  details = details.join(length > 2 ? ", " : " ");
                  return source.replace(
                    reWrapComment,
                    "{\n/* [wrapped with " + details + "] */\n"
                  );
                }

                /**
                 * Checks if `value` is a flattenable `arguments` object or array.
                 *
                 * @private
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
                 */
                function isFlattenable(value) {
                  return (
                    isArray(value) ||
                    isArguments(value) ||
                    !!(spreadableSymbol && value && value[spreadableSymbol])
                  );
                }

                /**
                 * Checks if `value` is a valid array-like index.
                 *
                 * @private
                 * @param {*} value The value to check.
                 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
                 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
                 */
                function isIndex(value, length) {
                  var type = typeof value;
                  length = length == null ? MAX_SAFE_INTEGER : length;

                  return (
                    !!length &&
                    (type == "number" ||
                      (type != "symbol" && reIsUint.test(value))) &&
                    value > -1 &&
                    value % 1 == 0 &&
                    value < length
                  );
                }

                /**
                 * Checks if the given arguments are from an iteratee call.
                 *
                 * @private
                 * @param {*} value The potential iteratee value argument.
                 * @param {*} index The potential iteratee index or key argument.
                 * @param {*} object The potential iteratee object argument.
                 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
                 *  else `false`.
                 */
                function isIterateeCall(value, index, object) {
                  if (!isObject(object)) {
                    return false;
                  }
                  var type = typeof index;
                  if (
                    type == "number"
                      ? isArrayLike(object) && isIndex(index, object.length)
                      : type == "string" && index in object
                  ) {
                    return eq(object[index], value);
                  }
                  return false;
                }

                /**
                 * Checks if `value` is a property name and not a property path.
                 *
                 * @private
                 * @param {*} value The value to check.
                 * @param {Object} [object] The object to query keys on.
                 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
                 */
                function isKey(value, object) {
                  if (isArray(value)) {
                    return false;
                  }
                  var type = typeof value;
                  if (
                    type == "number" ||
                    type == "symbol" ||
                    type == "boolean" ||
                    value == null ||
                    isSymbol(value)
                  ) {
                    return true;
                  }
                  return (
                    reIsPlainProp.test(value) ||
                    !reIsDeepProp.test(value) ||
                    (object != null && value in Object(object))
                  );
                }

                /**
                 * Checks if `value` is suitable for use as unique object key.
                 *
                 * @private
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
                 */
                function isKeyable(value) {
                  var type = typeof value;
                  return type == "string" ||
                    type == "number" ||
                    type == "symbol" ||
                    type == "boolean"
                    ? value !== "__proto__"
                    : value === null;
                }

                /**
                 * Checks if `func` has a lazy counterpart.
                 *
                 * @private
                 * @param {Function} func The function to check.
                 * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
                 *  else `false`.
                 */
                function isLaziable(func) {
                  var funcName = getFuncName(func),
                    other = lodash[funcName];

                  if (
                    typeof other != "function" ||
                    !(funcName in LazyWrapper.prototype)
                  ) {
                    return false;
                  }
                  if (func === other) {
                    return true;
                  }
                  var data = getData(other);
                  return !!data && func === data[0];
                }

                /**
                 * Checks if `func` has its source masked.
                 *
                 * @private
                 * @param {Function} func The function to check.
                 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
                 */
                function isMasked(func) {
                  return !!maskSrcKey && maskSrcKey in func;
                }

                /**
                 * Checks if `func` is capable of being masked.
                 *
                 * @private
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
                 */
                var isMaskable = coreJsData ? isFunction : stubFalse;

                /**
                 * Checks if `value` is likely a prototype object.
                 *
                 * @private
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
                 */
                function isPrototype(value) {
                  var Ctor = value && value.constructor,
                    proto =
                      (typeof Ctor == "function" && Ctor.prototype) ||
                      objectProto;

                  return value === proto;
                }

                /**
                 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
                 *
                 * @private
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` if suitable for strict
                 *  equality comparisons, else `false`.
                 */
                function isStrictComparable(value) {
                  return value === value && !isObject(value);
                }

                /**
                 * A specialized version of `matchesProperty` for source values suitable
                 * for strict equality comparisons, i.e. `===`.
                 *
                 * @private
                 * @param {string} key The key of the property to get.
                 * @param {*} srcValue The value to match.
                 * @returns {Function} Returns the new spec function.
                 */
                function matchesStrictComparable(key, srcValue) {
                  return function (object) {
                    if (object == null) {
                      return false;
                    }
                    return (
                      object[key] === srcValue &&
                      (srcValue !== undefined || key in Object(object))
                    );
                  };
                }

                /**
                 * A specialized version of `_.memoize` which clears the memoized function's
                 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
                 *
                 * @private
                 * @param {Function} func The function to have its output memoized.
                 * @returns {Function} Returns the new memoized function.
                 */
                function memoizeCapped(func) {
                  var result = memoize(func, function (key) {
                    if (cache.size === MAX_MEMOIZE_SIZE) {
                      cache.clear();
                    }
                    return key;
                  });

                  var cache = result.cache;
                  return result;
                }

                /**
                 * Merges the function metadata of `source` into `data`.
                 *
                 * Merging metadata reduces the number of wrappers used to invoke a function.
                 * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
                 * may be applied regardless of execution order. Methods like `_.ary` and
                 * `_.rearg` modify function arguments, making the order in which they are
                 * executed important, preventing the merging of metadata. However, we make
                 * an exception for a safe combined case where curried functions have `_.ary`
                 * and or `_.rearg` applied.
                 *
                 * @private
                 * @param {Array} data The destination metadata.
                 * @param {Array} source The source metadata.
                 * @returns {Array} Returns `data`.
                 */
                function mergeData(data, source) {
                  var bitmask = data[1],
                    srcBitmask = source[1],
                    newBitmask = bitmask | srcBitmask,
                    isCommon =
                      newBitmask <
                      (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);

                  var isCombo =
                    (srcBitmask == WRAP_ARY_FLAG &&
                      bitmask == WRAP_CURRY_FLAG) ||
                    (srcBitmask == WRAP_ARY_FLAG &&
                      bitmask == WRAP_REARG_FLAG &&
                      data[7].length <= source[8]) ||
                    (srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) &&
                      source[7].length <= source[8] &&
                      bitmask == WRAP_CURRY_FLAG);

                  // Exit early if metadata can't be merged.
                  if (!(isCommon || isCombo)) {
                    return data;
                  }
                  // Use source `thisArg` if available.
                  if (srcBitmask & WRAP_BIND_FLAG) {
                    data[2] = source[2];
                    // Set when currying a bound function.
                    newBitmask |=
                      bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
                  }
                  // Compose partial arguments.
                  var value = source[3];
                  if (value) {
                    var partials = data[3];
                    data[3] = partials
                      ? composeArgs(partials, value, source[4])
                      : value;
                    data[4] = partials
                      ? replaceHolders(data[3], PLACEHOLDER)
                      : source[4];
                  }
                  // Compose partial right arguments.
                  value = source[5];
                  if (value) {
                    partials = data[5];
                    data[5] = partials
                      ? composeArgsRight(partials, value, source[6])
                      : value;
                    data[6] = partials
                      ? replaceHolders(data[5], PLACEHOLDER)
                      : source[6];
                  }
                  // Use source `argPos` if available.
                  value = source[7];
                  if (value) {
                    data[7] = value;
                  }
                  // Use source `ary` if it's smaller.
                  if (srcBitmask & WRAP_ARY_FLAG) {
                    data[8] =
                      data[8] == null
                        ? source[8]
                        : nativeMin(data[8], source[8]);
                  }
                  // Use source `arity` if one is not provided.
                  if (data[9] == null) {
                    data[9] = source[9];
                  }
                  // Use source `func` and merge bitmasks.
                  data[0] = source[0];
                  data[1] = newBitmask;

                  return data;
                }

                /**
                 * This function is like
                 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
                 * except that it includes inherited enumerable properties.
                 *
                 * @private
                 * @param {Object} object The object to query.
                 * @returns {Array} Returns the array of property names.
                 */
                function nativeKeysIn(object) {
                  var result = [];
                  if (object != null) {
                    for (var key in Object(object)) {
                      result.push(key);
                    }
                  }
                  return result;
                }

                /**
                 * Converts `value` to a string using `Object.prototype.toString`.
                 *
                 * @private
                 * @param {*} value The value to convert.
                 * @returns {string} Returns the converted string.
                 */
                function objectToString(value) {
                  return nativeObjectToString.call(value);
                }

                /**
                 * A specialized version of `baseRest` which transforms the rest array.
                 *
                 * @private
                 * @param {Function} func The function to apply a rest parameter to.
                 * @param {number} [start=func.length-1] The start position of the rest parameter.
                 * @param {Function} transform The rest array transform.
                 * @returns {Function} Returns the new function.
                 */
                function overRest(func, start, transform) {
                  start = nativeMax(
                    start === undefined ? func.length - 1 : start,
                    0
                  );
                  return function () {
                    var args = arguments,
                      index = -1,
                      length = nativeMax(args.length - start, 0),
                      array = Array(length);

                    while (++index < length) {
                      array[index] = args[start + index];
                    }
                    index = -1;
                    var otherArgs = Array(start + 1);
                    while (++index < start) {
                      otherArgs[index] = args[index];
                    }
                    otherArgs[start] = transform(array);
                    return apply(func, this, otherArgs);
                  };
                }

                /**
                 * Gets the parent value at `path` of `object`.
                 *
                 * @private
                 * @param {Object} object The object to query.
                 * @param {Array} path The path to get the parent value of.
                 * @returns {*} Returns the parent value.
                 */
                function parent(object, path) {
                  return path.length < 2
                    ? object
                    : baseGet(object, baseSlice(path, 0, -1));
                }

                /**
                 * Reorder `array` according to the specified indexes where the element at
                 * the first index is assigned as the first element, the element at
                 * the second index is assigned as the second element, and so on.
                 *
                 * @private
                 * @param {Array} array The array to reorder.
                 * @param {Array} indexes The arranged array indexes.
                 * @returns {Array} Returns `array`.
                 */
                function reorder(array, indexes) {
                  var arrLength = array.length,
                    length = nativeMin(indexes.length, arrLength),
                    oldArray = copyArray(array);

                  while (length--) {
                    var index = indexes[length];
                    array[length] = isIndex(index, arrLength)
                      ? oldArray[index]
                      : undefined;
                  }
                  return array;
                }

                /**
                 * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
                 *
                 * @private
                 * @param {Object} object The object to query.
                 * @param {string} key The key of the property to get.
                 * @returns {*} Returns the property value.
                 */
                function safeGet(object, key) {
                  if (
                    key === "constructor" &&
                    typeof object[key] === "function"
                  ) {
                    return;
                  }

                  if (key == "__proto__") {
                    return;
                  }

                  return object[key];
                }

                /**
                 * Sets metadata for `func`.
                 *
                 * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
                 * period of time, it will trip its breaker and transition to an identity
                 * function to avoid garbage collection pauses in V8. See
                 * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
                 * for more details.
                 *
                 * @private
                 * @param {Function} func The function to associate metadata with.
                 * @param {*} data The metadata.
                 * @returns {Function} Returns `func`.
                 */
                var setData = shortOut(baseSetData);

                /**
                 * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
                 *
                 * @private
                 * @param {Function} func The function to delay.
                 * @param {number} wait The number of milliseconds to delay invocation.
                 * @returns {number|Object} Returns the timer id or timeout object.
                 */
                var setTimeout =
                  ctxSetTimeout ||
                  function (func, wait) {
                    return root.setTimeout(func, wait);
                  };

                /**
                 * Sets the `toString` method of `func` to return `string`.
                 *
                 * @private
                 * @param {Function} func The function to modify.
                 * @param {Function} string The `toString` result.
                 * @returns {Function} Returns `func`.
                 */
                var setToString = shortOut(baseSetToString);

                /**
                 * Sets the `toString` method of `wrapper` to mimic the source of `reference`
                 * with wrapper details in a comment at the top of the source body.
                 *
                 * @private
                 * @param {Function} wrapper The function to modify.
                 * @param {Function} reference The reference function.
                 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
                 * @returns {Function} Returns `wrapper`.
                 */
                function setWrapToString(wrapper, reference, bitmask) {
                  var source = reference + "";
                  return setToString(
                    wrapper,
                    insertWrapDetails(
                      source,
                      updateWrapDetails(getWrapDetails(source), bitmask)
                    )
                  );
                }

                /**
                 * Creates a function that'll short out and invoke `identity` instead
                 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
                 * milliseconds.
                 *
                 * @private
                 * @param {Function} func The function to restrict.
                 * @returns {Function} Returns the new shortable function.
                 */
                function shortOut(func) {
                  var count = 0,
                    lastCalled = 0;

                  return function () {
                    var stamp = nativeNow(),
                      remaining = HOT_SPAN - (stamp - lastCalled);

                    lastCalled = stamp;
                    if (remaining > 0) {
                      if (++count >= HOT_COUNT) {
                        return arguments[0];
                      }
                    } else {
                      count = 0;
                    }
                    return func.apply(undefined, arguments);
                  };
                }

                /**
                 * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
                 *
                 * @private
                 * @param {Array} array The array to shuffle.
                 * @param {number} [size=array.length] The size of `array`.
                 * @returns {Array} Returns `array`.
                 */
                function shuffleSelf(array, size) {
                  var index = -1,
                    length = array.length,
                    lastIndex = length - 1;

                  size = size === undefined ? length : size;
                  while (++index < size) {
                    var rand = baseRandom(index, lastIndex),
                      value = array[rand];

                    array[rand] = array[index];
                    array[index] = value;
                  }
                  array.length = size;
                  return array;
                }

                /**
                 * Converts `string` to a property path array.
                 *
                 * @private
                 * @param {string} string The string to convert.
                 * @returns {Array} Returns the property path array.
                 */
                var stringToPath = memoizeCapped(function (string) {
                  var result = [];
                  if (string.charCodeAt(0) === 46 /* . */) {
                    result.push("");
                  }
                  string.replace(rePropName, function (
                    match,
                    number,
                    quote,
                    subString
                  ) {
                    result.push(
                      quote
                        ? subString.replace(reEscapeChar, "$1")
                        : number || match
                    );
                  });
                  return result;
                });

                /**
                 * Converts `value` to a string key if it's not a string or symbol.
                 *
                 * @private
                 * @param {*} value The value to inspect.
                 * @returns {string|symbol} Returns the key.
                 */
                function toKey(value) {
                  if (typeof value == "string" || isSymbol(value)) {
                    return value;
                  }
                  var result = value + "";
                  return result == "0" && 1 / value == -INFINITY
                    ? "-0"
                    : result;
                }

                /**
                 * Converts `func` to its source code.
                 *
                 * @private
                 * @param {Function} func The function to convert.
                 * @returns {string} Returns the source code.
                 */
                function toSource(func) {
                  if (func != null) {
                    try {
                      return funcToString.call(func);
                    } catch (e) {}
                    try {
                      return func + "";
                    } catch (e) {}
                  }
                  return "";
                }

                /**
                 * Updates wrapper `details` based on `bitmask` flags.
                 *
                 * @private
                 * @returns {Array} details The details to modify.
                 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
                 * @returns {Array} Returns `details`.
                 */
                function updateWrapDetails(details, bitmask) {
                  arrayEach(wrapFlags, function (pair) {
                    var value = "_." + pair[0];
                    if (bitmask & pair[1] && !arrayIncludes(details, value)) {
                      details.push(value);
                    }
                  });
                  return details.sort();
                }

                /**
                 * Creates a clone of `wrapper`.
                 *
                 * @private
                 * @param {Object} wrapper The wrapper to clone.
                 * @returns {Object} Returns the cloned wrapper.
                 */
                function wrapperClone(wrapper) {
                  if (wrapper instanceof LazyWrapper) {
                    return wrapper.clone();
                  }
                  var result = new LodashWrapper(
                    wrapper.__wrapped__,
                    wrapper.__chain__
                  );
                  result.__actions__ = copyArray(wrapper.__actions__);
                  result.__index__ = wrapper.__index__;
                  result.__values__ = wrapper.__values__;
                  return result;
                }

                /*------------------------------------------------------------------------*/

                /**
                 * Creates an array of elements split into groups the length of `size`.
                 * If `array` can't be split evenly, the final chunk will be the remaining
                 * elements.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category Array
                 * @param {Array} array The array to process.
                 * @param {number} [size=1] The length of each chunk
                 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
                 * @returns {Array} Returns the new array of chunks.
                 * @example
                 *
                 * _.chunk(['a', 'b', 'c', 'd'], 2);
                 * // => [['a', 'b'], ['c', 'd']]
                 *
                 * _.chunk(['a', 'b', 'c', 'd'], 3);
                 * // => [['a', 'b', 'c'], ['d']]
                 */
                function chunk(array, size, guard) {
                  if (
                    guard
                      ? isIterateeCall(array, size, guard)
                      : size === undefined
                  ) {
                    size = 1;
                  } else {
                    size = nativeMax(toInteger(size), 0);
                  }
                  var length = array == null ? 0 : array.length;
                  if (!length || size < 1) {
                    return [];
                  }
                  var index = 0,
                    resIndex = 0,
                    result = Array(nativeCeil(length / size));

                  while (index < length) {
                    result[resIndex++] = baseSlice(
                      array,
                      index,
                      (index += size)
                    );
                  }
                  return result;
                }

                /**
                 * Creates an array with all falsey values removed. The values `false`, `null`,
                 * `0`, `""`, `undefined`, and `NaN` are falsey.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Array
                 * @param {Array} array The array to compact.
                 * @returns {Array} Returns the new array of filtered values.
                 * @example
                 *
                 * _.compact([0, 1, false, 2, '', 3]);
                 * // => [1, 2, 3]
                 */
                function compact(array) {
                  var index = -1,
                    length = array == null ? 0 : array.length,
                    resIndex = 0,
                    result = [];

                  while (++index < length) {
                    var value = array[index];
                    if (value) {
                      result[resIndex++] = value;
                    }
                  }
                  return result;
                }

                /**
                 * Creates a new array concatenating `array` with any additional arrays
                 * and/or values.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Array
                 * @param {Array} array The array to concatenate.
                 * @param {...*} [values] The values to concatenate.
                 * @returns {Array} Returns the new concatenated array.
                 * @example
                 *
                 * var array = [1];
                 * var other = _.concat(array, 2, [3], [[4]]);
                 *
                 * console.log(other);
                 * // => [1, 2, 3, [4]]
                 *
                 * console.log(array);
                 * // => [1]
                 */
                function concat() {
                  var length = arguments.length;
                  if (!length) {
                    return [];
                  }
                  var args = Array(length - 1),
                    array = arguments[0],
                    index = length;

                  while (index--) {
                    args[index - 1] = arguments[index];
                  }
                  return arrayPush(
                    isArray(array) ? copyArray(array) : [array],
                    baseFlatten(args, 1)
                  );
                }

                /**
                 * Creates an array of `array` values not included in the other given arrays
                 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
                 * for equality comparisons. The order and references of result values are
                 * determined by the first array.
                 *
                 * **Note:** Unlike `_.pullAll`, this method returns a new array.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Array
                 * @param {Array} array The array to inspect.
                 * @param {...Array} [values] The values to exclude.
                 * @returns {Array} Returns the new array of filtered values.
                 * @see _.without, _.xor
                 * @example
                 *
                 * _.difference([2, 1], [2, 3]);
                 * // => [1]
                 */
                var difference = baseRest(function (array, values) {
                  return isArrayLikeObject(array)
                    ? baseDifference(
                        array,
                        baseFlatten(values, 1, isArrayLikeObject, true)
                      )
                    : [];
                });

                /**
                 * This method is like `_.difference` except that it accepts `iteratee` which
                 * is invoked for each element of `array` and `values` to generate the criterion
                 * by which they're compared. The order and references of result values are
                 * determined by the first array. The iteratee is invoked with one argument:
                 * (value).
                 *
                 * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Array
                 * @param {Array} array The array to inspect.
                 * @param {...Array} [values] The values to exclude.
                 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
                 * @returns {Array} Returns the new array of filtered values.
                 * @example
                 *
                 * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
                 * // => [1.2]
                 *
                 * // The `_.property` iteratee shorthand.
                 * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
                 * // => [{ 'x': 2 }]
                 */
                var differenceBy = baseRest(function (array, values) {
                  var iteratee = last(values);
                  if (isArrayLikeObject(iteratee)) {
                    iteratee = undefined;
                  }
                  return isArrayLikeObject(array)
                    ? baseDifference(
                        array,
                        baseFlatten(values, 1, isArrayLikeObject, true),
                        getIteratee(iteratee, 2)
                      )
                    : [];
                });

                /**
                 * This method is like `_.difference` except that it accepts `comparator`
                 * which is invoked to compare elements of `array` to `values`. The order and
                 * references of result values are determined by the first array. The comparator
                 * is invoked with two arguments: (arrVal, othVal).
                 *
                 * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Array
                 * @param {Array} array The array to inspect.
                 * @param {...Array} [values] The values to exclude.
                 * @param {Function} [comparator] The comparator invoked per element.
                 * @returns {Array} Returns the new array of filtered values.
                 * @example
                 *
                 * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
                 *
                 * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
                 * // => [{ 'x': 2, 'y': 1 }]
                 */
                var differenceWith = baseRest(function (array, values) {
                  var comparator = last(values);
                  if (isArrayLikeObject(comparator)) {
                    comparator = undefined;
                  }
                  return isArrayLikeObject(array)
                    ? baseDifference(
                        array,
                        baseFlatten(values, 1, isArrayLikeObject, true),
                        undefined,
                        comparator
                      )
                    : [];
                });

                /**
                 * Creates a slice of `array` with `n` elements dropped from the beginning.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.5.0
                 * @category Array
                 * @param {Array} array The array to query.
                 * @param {number} [n=1] The number of elements to drop.
                 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
                 * @returns {Array} Returns the slice of `array`.
                 * @example
                 *
                 * _.drop([1, 2, 3]);
                 * // => [2, 3]
                 *
                 * _.drop([1, 2, 3], 2);
                 * // => [3]
                 *
                 * _.drop([1, 2, 3], 5);
                 * // => []
                 *
                 * _.drop([1, 2, 3], 0);
                 * // => [1, 2, 3]
                 */
                function drop(array, n, guard) {
                  var length = array == null ? 0 : array.length;
                  if (!length) {
                    return [];
                  }
                  n = guard || n === undefined ? 1 : toInteger(n);
                  return baseSlice(array, n < 0 ? 0 : n, length);
                }

                /**
                 * Creates a slice of `array` with `n` elements dropped from the end.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category Array
                 * @param {Array} array The array to query.
                 * @param {number} [n=1] The number of elements to drop.
                 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
                 * @returns {Array} Returns the slice of `array`.
                 * @example
                 *
                 * _.dropRight([1, 2, 3]);
                 * // => [1, 2]
                 *
                 * _.dropRight([1, 2, 3], 2);
                 * // => [1]
                 *
                 * _.dropRight([1, 2, 3], 5);
                 * // => []
                 *
                 * _.dropRight([1, 2, 3], 0);
                 * // => [1, 2, 3]
                 */
                function dropRight(array, n, guard) {
                  var length = array == null ? 0 : array.length;
                  if (!length) {
                    return [];
                  }
                  n = guard || n === undefined ? 1 : toInteger(n);
                  n = length - n;
                  return baseSlice(array, 0, n < 0 ? 0 : n);
                }

                /**
                 * Creates a slice of `array` excluding elements dropped from the end.
                 * Elements are dropped until `predicate` returns falsey. The predicate is
                 * invoked with three arguments: (value, index, array).
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category Array
                 * @param {Array} array The array to query.
                 * @param {Function} [predicate=_.identity] The function invoked per iteration.
                 * @returns {Array} Returns the slice of `array`.
                 * @example
                 *
                 * var users = [
                 *   { 'user': 'barney',  'active': true },
                 *   { 'user': 'fred',    'active': false },
                 *   { 'user': 'pebbles', 'active': false }
                 * ];
                 *
                 * _.dropRightWhile(users, function(o) { return !o.active; });
                 * // => objects for ['barney']
                 *
                 * // The `_.matches` iteratee shorthand.
                 * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
                 * // => objects for ['barney', 'fred']
                 *
                 * // The `_.matchesProperty` iteratee shorthand.
                 * _.dropRightWhile(users, ['active', false]);
                 * // => objects for ['barney']
                 *
                 * // The `_.property` iteratee shorthand.
                 * _.dropRightWhile(users, 'active');
                 * // => objects for ['barney', 'fred', 'pebbles']
                 */
                function dropRightWhile(array, predicate) {
                  return array && array.length
                    ? baseWhile(array, getIteratee(predicate, 3), true, true)
                    : [];
                }

                /**
                 * Creates a slice of `array` excluding elements dropped from the beginning.
                 * Elements are dropped until `predicate` returns falsey. The predicate is
                 * invoked with three arguments: (value, index, array).
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category Array
                 * @param {Array} array The array to query.
                 * @param {Function} [predicate=_.identity] The function invoked per iteration.
                 * @returns {Array} Returns the slice of `array`.
                 * @example
                 *
                 * var users = [
                 *   { 'user': 'barney',  'active': false },
                 *   { 'user': 'fred',    'active': false },
                 *   { 'user': 'pebbles', 'active': true }
                 * ];
                 *
                 * _.dropWhile(users, function(o) { return !o.active; });
                 * // => objects for ['pebbles']
                 *
                 * // The `_.matches` iteratee shorthand.
                 * _.dropWhile(users, { 'user': 'barney', 'active': false });
                 * // => objects for ['fred', 'pebbles']
                 *
                 * // The `_.matchesProperty` iteratee shorthand.
                 * _.dropWhile(users, ['active', false]);
                 * // => objects for ['pebbles']
                 *
                 * // The `_.property` iteratee shorthand.
                 * _.dropWhile(users, 'active');
                 * // => objects for ['barney', 'fred', 'pebbles']
                 */
                function dropWhile(array, predicate) {
                  return array && array.length
                    ? baseWhile(array, getIteratee(predicate, 3), true)
                    : [];
                }

                /**
                 * Fills elements of `array` with `value` from `start` up to, but not
                 * including, `end`.
                 *
                 * **Note:** This method mutates `array`.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.2.0
                 * @category Array
                 * @param {Array} array The array to fill.
                 * @param {*} value The value to fill `array` with.
                 * @param {number} [start=0] The start position.
                 * @param {number} [end=array.length] The end position.
                 * @returns {Array} Returns `array`.
                 * @example
                 *
                 * var array = [1, 2, 3];
                 *
                 * _.fill(array, 'a');
                 * console.log(array);
                 * // => ['a', 'a', 'a']
                 *
                 * _.fill(Array(3), 2);
                 * // => [2, 2, 2]
                 *
                 * _.fill([4, 6, 8, 10], '*', 1, 3);
                 * // => [4, '*', '*', 10]
                 */
                function fill(array, value, start, end) {
                  var length = array == null ? 0 : array.length;
                  if (!length) {
                    return [];
                  }
                  if (
                    start &&
                    typeof start != "number" &&
                    isIterateeCall(array, value, start)
                  ) {
                    start = 0;
                    end = length;
                  }
                  return baseFill(array, value, start, end);
                }

                /**
                 * This method is like `_.find` except that it returns the index of the first
                 * element `predicate` returns truthy for instead of the element itself.
                 *
                 * @static
                 * @memberOf _
                 * @since 1.1.0
                 * @category Array
                 * @param {Array} array The array to inspect.
                 * @param {Function} [predicate=_.identity] The function invoked per iteration.
                 * @param {number} [fromIndex=0] The index to search from.
                 * @returns {number} Returns the index of the found element, else `-1`.
                 * @example
                 *
                 * var users = [
                 *   { 'user': 'barney',  'active': false },
                 *   { 'user': 'fred',    'active': false },
                 *   { 'user': 'pebbles', 'active': true }
                 * ];
                 *
                 * _.findIndex(users, function(o) { return o.user == 'barney'; });
                 * // => 0
                 *
                 * // The `_.matches` iteratee shorthand.
                 * _.findIndex(users, { 'user': 'fred', 'active': false });
                 * // => 1
                 *
                 * // The `_.matchesProperty` iteratee shorthand.
                 * _.findIndex(users, ['active', false]);
                 * // => 0
                 *
                 * // The `_.property` iteratee shorthand.
                 * _.findIndex(users, 'active');
                 * // => 2
                 */
                function findIndex(array, predicate, fromIndex) {
                  var length = array == null ? 0 : array.length;
                  if (!length) {
                    return -1;
                  }
                  var index = fromIndex == null ? 0 : toInteger(fromIndex);
                  if (index < 0) {
                    index = nativeMax(length + index, 0);
                  }
                  return baseFindIndex(array, getIteratee(predicate, 3), index);
                }

                /**
                 * This method is like `_.findIndex` except that it iterates over elements
                 * of `collection` from right to left.
                 *
                 * @static
                 * @memberOf _
                 * @since 2.0.0
                 * @category Array
                 * @param {Array} array The array to inspect.
                 * @param {Function} [predicate=_.identity] The function invoked per iteration.
                 * @param {number} [fromIndex=array.length-1] The index to search from.
                 * @returns {number} Returns the index of the found element, else `-1`.
                 * @example
                 *
                 * var users = [
                 *   { 'user': 'barney',  'active': true },
                 *   { 'user': 'fred',    'active': false },
                 *   { 'user': 'pebbles', 'active': false }
                 * ];
                 *
                 * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
                 * // => 2
                 *
                 * // The `_.matches` iteratee shorthand.
                 * _.findLastIndex(users, { 'user': 'barney', 'active': true });
                 * // => 0
                 *
                 * // The `_.matchesProperty` iteratee shorthand.
                 * _.findLastIndex(users, ['active', false]);
                 * // => 2
                 *
                 * // The `_.property` iteratee shorthand.
                 * _.findLastIndex(users, 'active');
                 * // => 0
                 */
                function findLastIndex(array, predicate, fromIndex) {
                  var length = array == null ? 0 : array.length;
                  if (!length) {
                    return -1;
                  }
                  var index = length - 1;
                  if (fromIndex !== undefined) {
                    index = toInteger(fromIndex);
                    index =
                      fromIndex < 0
                        ? nativeMax(length + index, 0)
                        : nativeMin(index, length - 1);
                  }
                  return baseFindIndex(
                    array,
                    getIteratee(predicate, 3),
                    index,
                    true
                  );
                }

                /**
                 * Flattens `array` a single level deep.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Array
                 * @param {Array} array The array to flatten.
                 * @returns {Array} Returns the new flattened array.
                 * @example
                 *
                 * _.flatten([1, [2, [3, [4]], 5]]);
                 * // => [1, 2, [3, [4]], 5]
                 */
                function flatten(array) {
                  var length = array == null ? 0 : array.length;
                  return length ? baseFlatten(array, 1) : [];
                }

                /**
                 * Recursively flattens `array`.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category Array
                 * @param {Array} array The array to flatten.
                 * @returns {Array} Returns the new flattened array.
                 * @example
                 *
                 * _.flattenDeep([1, [2, [3, [4]], 5]]);
                 * // => [1, 2, 3, 4, 5]
                 */
                function flattenDeep(array) {
                  var length = array == null ? 0 : array.length;
                  return length ? baseFlatten(array, INFINITY) : [];
                }

                /**
                 * Recursively flatten `array` up to `depth` times.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.4.0
                 * @category Array
                 * @param {Array} array The array to flatten.
                 * @param {number} [depth=1] The maximum recursion depth.
                 * @returns {Array} Returns the new flattened array.
                 * @example
                 *
                 * var array = [1, [2, [3, [4]], 5]];
                 *
                 * _.flattenDepth(array, 1);
                 * // => [1, 2, [3, [4]], 5]
                 *
                 * _.flattenDepth(array, 2);
                 * // => [1, 2, 3, [4], 5]
                 */
                function flattenDepth(array, depth) {
                  var length = array == null ? 0 : array.length;
                  if (!length) {
                    return [];
                  }
                  depth = depth === undefined ? 1 : toInteger(depth);
                  return baseFlatten(array, depth);
                }

                /**
                 * The inverse of `_.toPairs`; this method returns an object composed
                 * from key-value `pairs`.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Array
                 * @param {Array} pairs The key-value pairs.
                 * @returns {Object} Returns the new object.
                 * @example
                 *
                 * _.fromPairs([['a', 1], ['b', 2]]);
                 * // => { 'a': 1, 'b': 2 }
                 */
                function fromPairs(pairs) {
                  var index = -1,
                    length = pairs == null ? 0 : pairs.length,
                    result = {};

                  while (++index < length) {
                    var pair = pairs[index];
                    result[pair[0]] = pair[1];
                  }
                  return result;
                }

                /**
                 * Gets the first element of `array`.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @alias first
                 * @category Array
                 * @param {Array} array The array to query.
                 * @returns {*} Returns the first element of `array`.
                 * @example
                 *
                 * _.head([1, 2, 3]);
                 * // => 1
                 *
                 * _.head([]);
                 * // => undefined
                 */
                function head(array) {
                  return array && array.length ? array[0] : undefined;
                }

                /**
                 * Gets the index at which the first occurrence of `value` is found in `array`
                 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
                 * for equality comparisons. If `fromIndex` is negative, it's used as the
                 * offset from the end of `array`.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Array
                 * @param {Array} array The array to inspect.
                 * @param {*} value The value to search for.
                 * @param {number} [fromIndex=0] The index to search from.
                 * @returns {number} Returns the index of the matched value, else `-1`.
                 * @example
                 *
                 * _.indexOf([1, 2, 1, 2], 2);
                 * // => 1
                 *
                 * // Search from the `fromIndex`.
                 * _.indexOf([1, 2, 1, 2], 2, 2);
                 * // => 3
                 */
                function indexOf(array, value, fromIndex) {
                  var length = array == null ? 0 : array.length;
                  if (!length) {
                    return -1;
                  }
                  var index = fromIndex == null ? 0 : toInteger(fromIndex);
                  if (index < 0) {
                    index = nativeMax(length + index, 0);
                  }
                  return baseIndexOf(array, value, index);
                }

                /**
                 * Gets all but the last element of `array`.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Array
                 * @param {Array} array The array to query.
                 * @returns {Array} Returns the slice of `array`.
                 * @example
                 *
                 * _.initial([1, 2, 3]);
                 * // => [1, 2]
                 */
                function initial(array) {
                  var length = array == null ? 0 : array.length;
                  return length ? baseSlice(array, 0, -1) : [];
                }

                /**
                 * Creates an array of unique values that are included in all given arrays
                 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
                 * for equality comparisons. The order and references of result values are
                 * determined by the first array.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Array
                 * @param {...Array} [arrays] The arrays to inspect.
                 * @returns {Array} Returns the new array of intersecting values.
                 * @example
                 *
                 * _.intersection([2, 1], [2, 3]);
                 * // => [2]
                 */
                var intersection = baseRest(function (arrays) {
                  var mapped = arrayMap(arrays, castArrayLikeObject);
                  return mapped.length && mapped[0] === arrays[0]
                    ? baseIntersection(mapped)
                    : [];
                });

                /**
                 * This method is like `_.intersection` except that it accepts `iteratee`
                 * which is invoked for each element of each `arrays` to generate the criterion
                 * by which they're compared. The order and references of result values are
                 * determined by the first array. The iteratee is invoked with one argument:
                 * (value).
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Array
                 * @param {...Array} [arrays] The arrays to inspect.
                 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
                 * @returns {Array} Returns the new array of intersecting values.
                 * @example
                 *
                 * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
                 * // => [2.1]
                 *
                 * // The `_.property` iteratee shorthand.
                 * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
                 * // => [{ 'x': 1 }]
                 */
                var intersectionBy = baseRest(function (arrays) {
                  var iteratee = last(arrays),
                    mapped = arrayMap(arrays, castArrayLikeObject);

                  if (iteratee === last(mapped)) {
                    iteratee = undefined;
                  } else {
                    mapped.pop();
                  }
                  return mapped.length && mapped[0] === arrays[0]
                    ? baseIntersection(mapped, getIteratee(iteratee, 2))
                    : [];
                });

                /**
                 * This method is like `_.intersection` except that it accepts `comparator`
                 * which is invoked to compare elements of `arrays`. The order and references
                 * of result values are determined by the first array. The comparator is
                 * invoked with two arguments: (arrVal, othVal).
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Array
                 * @param {...Array} [arrays] The arrays to inspect.
                 * @param {Function} [comparator] The comparator invoked per element.
                 * @returns {Array} Returns the new array of intersecting values.
                 * @example
                 *
                 * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
                 * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
                 *
                 * _.intersectionWith(objects, others, _.isEqual);
                 * // => [{ 'x': 1, 'y': 2 }]
                 */
                var intersectionWith = baseRest(function (arrays) {
                  var comparator = last(arrays),
                    mapped = arrayMap(arrays, castArrayLikeObject);

                  comparator =
                    typeof comparator == "function" ? comparator : undefined;
                  if (comparator) {
                    mapped.pop();
                  }
                  return mapped.length && mapped[0] === arrays[0]
                    ? baseIntersection(mapped, undefined, comparator)
                    : [];
                });

                /**
                 * Converts all elements in `array` into a string separated by `separator`.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Array
                 * @param {Array} array The array to convert.
                 * @param {string} [separator=','] The element separator.
                 * @returns {string} Returns the joined string.
                 * @example
                 *
                 * _.join(['a', 'b', 'c'], '~');
                 * // => 'a~b~c'
                 */
                function join(array, separator) {
                  return array == null ? "" : nativeJoin.call(array, separator);
                }

                /**
                 * Gets the last element of `array`.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Array
                 * @param {Array} array The array to query.
                 * @returns {*} Returns the last element of `array`.
                 * @example
                 *
                 * _.last([1, 2, 3]);
                 * // => 3
                 */
                function last(array) {
                  var length = array == null ? 0 : array.length;
                  return length ? array[length - 1] : undefined;
                }

                /**
                 * This method is like `_.indexOf` except that it iterates over elements of
                 * `array` from right to left.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Array
                 * @param {Array} array The array to inspect.
                 * @param {*} value The value to search for.
                 * @param {number} [fromIndex=array.length-1] The index to search from.
                 * @returns {number} Returns the index of the matched value, else `-1`.
                 * @example
                 *
                 * _.lastIndexOf([1, 2, 1, 2], 2);
                 * // => 3
                 *
                 * // Search from the `fromIndex`.
                 * _.lastIndexOf([1, 2, 1, 2], 2, 2);
                 * // => 1
                 */
                function lastIndexOf(array, value, fromIndex) {
                  var length = array == null ? 0 : array.length;
                  if (!length) {
                    return -1;
                  }
                  var index = length;
                  if (fromIndex !== undefined) {
                    index = toInteger(fromIndex);
                    index =
                      index < 0
                        ? nativeMax(length + index, 0)
                        : nativeMin(index, length - 1);
                  }
                  return value === value
                    ? strictLastIndexOf(array, value, index)
                    : baseFindIndex(array, baseIsNaN, index, true);
                }

                /**
                 * Gets the element at index `n` of `array`. If `n` is negative, the nth
                 * element from the end is returned.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.11.0
                 * @category Array
                 * @param {Array} array The array to query.
                 * @param {number} [n=0] The index of the element to return.
                 * @returns {*} Returns the nth element of `array`.
                 * @example
                 *
                 * var array = ['a', 'b', 'c', 'd'];
                 *
                 * _.nth(array, 1);
                 * // => 'b'
                 *
                 * _.nth(array, -2);
                 * // => 'c';
                 */
                function nth(array, n) {
                  return array && array.length
                    ? baseNth(array, toInteger(n))
                    : undefined;
                }

                /**
                 * Removes all given values from `array` using
                 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
                 * for equality comparisons.
                 *
                 * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
                 * to remove elements from an array by predicate.
                 *
                 * @static
                 * @memberOf _
                 * @since 2.0.0
                 * @category Array
                 * @param {Array} array The array to modify.
                 * @param {...*} [values] The values to remove.
                 * @returns {Array} Returns `array`.
                 * @example
                 *
                 * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
                 *
                 * _.pull(array, 'a', 'c');
                 * console.log(array);
                 * // => ['b', 'b']
                 */
                var pull = baseRest(pullAll);

                /**
                 * This method is like `_.pull` except that it accepts an array of values to remove.
                 *
                 * **Note:** Unlike `_.difference`, this method mutates `array`.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Array
                 * @param {Array} array The array to modify.
                 * @param {Array} values The values to remove.
                 * @returns {Array} Returns `array`.
                 * @example
                 *
                 * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
                 *
                 * _.pullAll(array, ['a', 'c']);
                 * console.log(array);
                 * // => ['b', 'b']
                 */
                function pullAll(array, values) {
                  return array && array.length && values && values.length
                    ? basePullAll(array, values)
                    : array;
                }

                /**
                 * This method is like `_.pullAll` except that it accepts `iteratee` which is
                 * invoked for each element of `array` and `values` to generate the criterion
                 * by which they're compared. The iteratee is invoked with one argument: (value).
                 *
                 * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Array
                 * @param {Array} array The array to modify.
                 * @param {Array} values The values to remove.
                 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
                 * @returns {Array} Returns `array`.
                 * @example
                 *
                 * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
                 *
                 * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
                 * console.log(array);
                 * // => [{ 'x': 2 }]
                 */
                function pullAllBy(array, values, iteratee) {
                  return array && array.length && values && values.length
                    ? basePullAll(array, values, getIteratee(iteratee, 2))
                    : array;
                }

                /**
                 * This method is like `_.pullAll` except that it accepts `comparator` which
                 * is invoked to compare elements of `array` to `values`. The comparator is
                 * invoked with two arguments: (arrVal, othVal).
                 *
                 * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.6.0
                 * @category Array
                 * @param {Array} array The array to modify.
                 * @param {Array} values The values to remove.
                 * @param {Function} [comparator] The comparator invoked per element.
                 * @returns {Array} Returns `array`.
                 * @example
                 *
                 * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
                 *
                 * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
                 * console.log(array);
                 * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
                 */
                function pullAllWith(array, values, comparator) {
                  return array && array.length && values && values.length
                    ? basePullAll(array, values, undefined, comparator)
                    : array;
                }

                /**
                 * Removes elements from `array` corresponding to `indexes` and returns an
                 * array of removed elements.
                 *
                 * **Note:** Unlike `_.at`, this method mutates `array`.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category Array
                 * @param {Array} array The array to modify.
                 * @param {...(number|number[])} [indexes] The indexes of elements to remove.
                 * @returns {Array} Returns the new array of removed elements.
                 * @example
                 *
                 * var array = ['a', 'b', 'c', 'd'];
                 * var pulled = _.pullAt(array, [1, 3]);
                 *
                 * console.log(array);
                 * // => ['a', 'c']
                 *
                 * console.log(pulled);
                 * // => ['b', 'd']
                 */
                var pullAt = flatRest(function (array, indexes) {
                  var length = array == null ? 0 : array.length,
                    result = baseAt(array, indexes);

                  basePullAt(
                    array,
                    arrayMap(indexes, function (index) {
                      return isIndex(index, length) ? +index : index;
                    }).sort(compareAscending)
                  );

                  return result;
                });

                /**
                 * Removes all elements from `array` that `predicate` returns truthy for
                 * and returns an array of the removed elements. The predicate is invoked
                 * with three arguments: (value, index, array).
                 *
                 * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
                 * to pull elements from an array by value.
                 *
                 * @static
                 * @memberOf _
                 * @since 2.0.0
                 * @category Array
                 * @param {Array} array The array to modify.
                 * @param {Function} [predicate=_.identity] The function invoked per iteration.
                 * @returns {Array} Returns the new array of removed elements.
                 * @example
                 *
                 * var array = [1, 2, 3, 4];
                 * var evens = _.remove(array, function(n) {
                 *   return n % 2 == 0;
                 * });
                 *
                 * console.log(array);
                 * // => [1, 3]
                 *
                 * console.log(evens);
                 * // => [2, 4]
                 */
                function remove(array, predicate) {
                  var result = [];
                  if (!(array && array.length)) {
                    return result;
                  }
                  var index = -1,
                    indexes = [],
                    length = array.length;

                  predicate = getIteratee(predicate, 3);
                  while (++index < length) {
                    var value = array[index];
                    if (predicate(value, index, array)) {
                      result.push(value);
                      indexes.push(index);
                    }
                  }
                  basePullAt(array, indexes);
                  return result;
                }

                /**
                 * Reverses `array` so that the first element becomes the last, the second
                 * element becomes the second to last, and so on.
                 *
                 * **Note:** This method mutates `array` and is based on
                 * [`Array#reverse`](https://mdn.io/Array/reverse).
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Array
                 * @param {Array} array The array to modify.
                 * @returns {Array} Returns `array`.
                 * @example
                 *
                 * var array = [1, 2, 3];
                 *
                 * _.reverse(array);
                 * // => [3, 2, 1]
                 *
                 * console.log(array);
                 * // => [3, 2, 1]
                 */
                function reverse(array) {
                  return array == null ? array : nativeReverse.call(array);
                }

                /**
                 * Creates a slice of `array` from `start` up to, but not including, `end`.
                 *
                 * **Note:** This method is used instead of
                 * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
                 * returned.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category Array
                 * @param {Array} array The array to slice.
                 * @param {number} [start=0] The start position.
                 * @param {number} [end=array.length] The end position.
                 * @returns {Array} Returns the slice of `array`.
                 */
                function slice(array, start, end) {
                  var length = array == null ? 0 : array.length;
                  if (!length) {
                    return [];
                  }
                  if (
                    end &&
                    typeof end != "number" &&
                    isIterateeCall(array, start, end)
                  ) {
                    start = 0;
                    end = length;
                  } else {
                    start = start == null ? 0 : toInteger(start);
                    end = end === undefined ? length : toInteger(end);
                  }
                  return baseSlice(array, start, end);
                }

                /**
                 * Uses a binary search to determine the lowest index at which `value`
                 * should be inserted into `array` in order to maintain its sort order.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Array
                 * @param {Array} array The sorted array to inspect.
                 * @param {*} value The value to evaluate.
                 * @returns {number} Returns the index at which `value` should be inserted
                 *  into `array`.
                 * @example
                 *
                 * _.sortedIndex([30, 50], 40);
                 * // => 1
                 */
                function sortedIndex(array, value) {
                  return baseSortedIndex(array, value);
                }

                /**
                 * This method is like `_.sortedIndex` except that it accepts `iteratee`
                 * which is invoked for `value` and each element of `array` to compute their
                 * sort ranking. The iteratee is invoked with one argument: (value).
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Array
                 * @param {Array} array The sorted array to inspect.
                 * @param {*} value The value to evaluate.
                 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
                 * @returns {number} Returns the index at which `value` should be inserted
                 *  into `array`.
                 * @example
                 *
                 * var objects = [{ 'x': 4 }, { 'x': 5 }];
                 *
                 * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
                 * // => 0
                 *
                 * // The `_.property` iteratee shorthand.
                 * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
                 * // => 0
                 */
                function sortedIndexBy(array, value, iteratee) {
                  return baseSortedIndexBy(
                    array,
                    value,
                    getIteratee(iteratee, 2)
                  );
                }

                /**
                 * This method is like `_.indexOf` except that it performs a binary
                 * search on a sorted `array`.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Array
                 * @param {Array} array The array to inspect.
                 * @param {*} value The value to search for.
                 * @returns {number} Returns the index of the matched value, else `-1`.
                 * @example
                 *
                 * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
                 * // => 1
                 */
                function sortedIndexOf(array, value) {
                  var length = array == null ? 0 : array.length;
                  if (length) {
                    var index = baseSortedIndex(array, value);
                    if (index < length && eq(array[index], value)) {
                      return index;
                    }
                  }
                  return -1;
                }

                /**
                 * This method is like `_.sortedIndex` except that it returns the highest
                 * index at which `value` should be inserted into `array` in order to
                 * maintain its sort order.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category Array
                 * @param {Array} array The sorted array to inspect.
                 * @param {*} value The value to evaluate.
                 * @returns {number} Returns the index at which `value` should be inserted
                 *  into `array`.
                 * @example
                 *
                 * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
                 * // => 4
                 */
                function sortedLastIndex(array, value) {
                  return baseSortedIndex(array, value, true);
                }

                /**
                 * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
                 * which is invoked for `value` and each element of `array` to compute their
                 * sort ranking. The iteratee is invoked with one argument: (value).
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Array
                 * @param {Array} array The sorted array to inspect.
                 * @param {*} value The value to evaluate.
                 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
                 * @returns {number} Returns the index at which `value` should be inserted
                 *  into `array`.
                 * @example
                 *
                 * var objects = [{ 'x': 4 }, { 'x': 5 }];
                 *
                 * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
                 * // => 1
                 *
                 * // The `_.property` iteratee shorthand.
                 * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
                 * // => 1
                 */
                function sortedLastIndexBy(array, value, iteratee) {
                  return baseSortedIndexBy(
                    array,
                    value,
                    getIteratee(iteratee, 2),
                    true
                  );
                }

                /**
                 * This method is like `_.lastIndexOf` except that it performs a binary
                 * search on a sorted `array`.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Array
                 * @param {Array} array The array to inspect.
                 * @param {*} value The value to search for.
                 * @returns {number} Returns the index of the matched value, else `-1`.
                 * @example
                 *
                 * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
                 * // => 3
                 */
                function sortedLastIndexOf(array, value) {
                  var length = array == null ? 0 : array.length;
                  if (length) {
                    var index = baseSortedIndex(array, value, true) - 1;
                    if (eq(array[index], value)) {
                      return index;
                    }
                  }
                  return -1;
                }

                /**
                 * This method is like `_.uniq` except that it's designed and optimized
                 * for sorted arrays.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Array
                 * @param {Array} array The array to inspect.
                 * @returns {Array} Returns the new duplicate free array.
                 * @example
                 *
                 * _.sortedUniq([1, 1, 2]);
                 * // => [1, 2]
                 */
                function sortedUniq(array) {
                  return array && array.length ? baseSortedUniq(array) : [];
                }

                /**
                 * This method is like `_.uniqBy` except that it's designed and optimized
                 * for sorted arrays.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Array
                 * @param {Array} array The array to inspect.
                 * @param {Function} [iteratee] The iteratee invoked per element.
                 * @returns {Array} Returns the new duplicate free array.
                 * @example
                 *
                 * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
                 * // => [1.1, 2.3]
                 */
                function sortedUniqBy(array, iteratee) {
                  return array && array.length
                    ? baseSortedUniq(array, getIteratee(iteratee, 2))
                    : [];
                }

                /**
                 * Gets all but the first element of `array`.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Array
                 * @param {Array} array The array to query.
                 * @returns {Array} Returns the slice of `array`.
                 * @example
                 *
                 * _.tail([1, 2, 3]);
                 * // => [2, 3]
                 */
                function tail(array) {
                  var length = array == null ? 0 : array.length;
                  return length ? baseSlice(array, 1, length) : [];
                }

                /**
                 * Creates a slice of `array` with `n` elements taken from the beginning.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Array
                 * @param {Array} array The array to query.
                 * @param {number} [n=1] The number of elements to take.
                 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
                 * @returns {Array} Returns the slice of `array`.
                 * @example
                 *
                 * _.take([1, 2, 3]);
                 * // => [1]
                 *
                 * _.take([1, 2, 3], 2);
                 * // => [1, 2]
                 *
                 * _.take([1, 2, 3], 5);
                 * // => [1, 2, 3]
                 *
                 * _.take([1, 2, 3], 0);
                 * // => []
                 */
                function take(array, n, guard) {
                  if (!(array && array.length)) {
                    return [];
                  }
                  n = guard || n === undefined ? 1 : toInteger(n);
                  return baseSlice(array, 0, n < 0 ? 0 : n);
                }

                /**
                 * Creates a slice of `array` with `n` elements taken from the end.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category Array
                 * @param {Array} array The array to query.
                 * @param {number} [n=1] The number of elements to take.
                 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
                 * @returns {Array} Returns the slice of `array`.
                 * @example
                 *
                 * _.takeRight([1, 2, 3]);
                 * // => [3]
                 *
                 * _.takeRight([1, 2, 3], 2);
                 * // => [2, 3]
                 *
                 * _.takeRight([1, 2, 3], 5);
                 * // => [1, 2, 3]
                 *
                 * _.takeRight([1, 2, 3], 0);
                 * // => []
                 */
                function takeRight(array, n, guard) {
                  var length = array == null ? 0 : array.length;
                  if (!length) {
                    return [];
                  }
                  n = guard || n === undefined ? 1 : toInteger(n);
                  n = length - n;
                  return baseSlice(array, n < 0 ? 0 : n, length);
                }

                /**
                 * Creates a slice of `array` with elements taken from the end. Elements are
                 * taken until `predicate` returns falsey. The predicate is invoked with
                 * three arguments: (value, index, array).
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category Array
                 * @param {Array} array The array to query.
                 * @param {Function} [predicate=_.identity] The function invoked per iteration.
                 * @returns {Array} Returns the slice of `array`.
                 * @example
                 *
                 * var users = [
                 *   { 'user': 'barney',  'active': true },
                 *   { 'user': 'fred',    'active': false },
                 *   { 'user': 'pebbles', 'active': false }
                 * ];
                 *
                 * _.takeRightWhile(users, function(o) { return !o.active; });
                 * // => objects for ['fred', 'pebbles']
                 *
                 * // The `_.matches` iteratee shorthand.
                 * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
                 * // => objects for ['pebbles']
                 *
                 * // The `_.matchesProperty` iteratee shorthand.
                 * _.takeRightWhile(users, ['active', false]);
                 * // => objects for ['fred', 'pebbles']
                 *
                 * // The `_.property` iteratee shorthand.
                 * _.takeRightWhile(users, 'active');
                 * // => []
                 */
                function takeRightWhile(array, predicate) {
                  return array && array.length
                    ? baseWhile(array, getIteratee(predicate, 3), false, true)
                    : [];
                }

                /**
                 * Creates a slice of `array` with elements taken from the beginning. Elements
                 * are taken until `predicate` returns falsey. The predicate is invoked with
                 * three arguments: (value, index, array).
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category Array
                 * @param {Array} array The array to query.
                 * @param {Function} [predicate=_.identity] The function invoked per iteration.
                 * @returns {Array} Returns the slice of `array`.
                 * @example
                 *
                 * var users = [
                 *   { 'user': 'barney',  'active': false },
                 *   { 'user': 'fred',    'active': false },
                 *   { 'user': 'pebbles', 'active': true }
                 * ];
                 *
                 * _.takeWhile(users, function(o) { return !o.active; });
                 * // => objects for ['barney', 'fred']
                 *
                 * // The `_.matches` iteratee shorthand.
                 * _.takeWhile(users, { 'user': 'barney', 'active': false });
                 * // => objects for ['barney']
                 *
                 * // The `_.matchesProperty` iteratee shorthand.
                 * _.takeWhile(users, ['active', false]);
                 * // => objects for ['barney', 'fred']
                 *
                 * // The `_.property` iteratee shorthand.
                 * _.takeWhile(users, 'active');
                 * // => []
                 */
                function takeWhile(array, predicate) {
                  return array && array.length
                    ? baseWhile(array, getIteratee(predicate, 3))
                    : [];
                }

                /**
                 * Creates an array of unique values, in order, from all given arrays using
                 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
                 * for equality comparisons.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Array
                 * @param {...Array} [arrays] The arrays to inspect.
                 * @returns {Array} Returns the new array of combined values.
                 * @example
                 *
                 * _.union([2], [1, 2]);
                 * // => [2, 1]
                 */
                var union = baseRest(function (arrays) {
                  return baseUniq(
                    baseFlatten(arrays, 1, isArrayLikeObject, true)
                  );
                });

                /**
                 * This method is like `_.union` except that it accepts `iteratee` which is
                 * invoked for each element of each `arrays` to generate the criterion by
                 * which uniqueness is computed. Result values are chosen from the first
                 * array in which the value occurs. The iteratee is invoked with one argument:
                 * (value).
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Array
                 * @param {...Array} [arrays] The arrays to inspect.
                 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
                 * @returns {Array} Returns the new array of combined values.
                 * @example
                 *
                 * _.unionBy([2.1], [1.2, 2.3], Math.floor);
                 * // => [2.1, 1.2]
                 *
                 * // The `_.property` iteratee shorthand.
                 * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
                 * // => [{ 'x': 1 }, { 'x': 2 }]
                 */
                var unionBy = baseRest(function (arrays) {
                  var iteratee = last(arrays);
                  if (isArrayLikeObject(iteratee)) {
                    iteratee = undefined;
                  }
                  return baseUniq(
                    baseFlatten(arrays, 1, isArrayLikeObject, true),
                    getIteratee(iteratee, 2)
                  );
                });

                /**
                 * This method is like `_.union` except that it accepts `comparator` which
                 * is invoked to compare elements of `arrays`. Result values are chosen from
                 * the first array in which the value occurs. The comparator is invoked
                 * with two arguments: (arrVal, othVal).
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Array
                 * @param {...Array} [arrays] The arrays to inspect.
                 * @param {Function} [comparator] The comparator invoked per element.
                 * @returns {Array} Returns the new array of combined values.
                 * @example
                 *
                 * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
                 * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
                 *
                 * _.unionWith(objects, others, _.isEqual);
                 * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
                 */
                var unionWith = baseRest(function (arrays) {
                  var comparator = last(arrays);
                  comparator =
                    typeof comparator == "function" ? comparator : undefined;
                  return baseUniq(
                    baseFlatten(arrays, 1, isArrayLikeObject, true),
                    undefined,
                    comparator
                  );
                });

                /**
                 * Creates a duplicate-free version of an array, using
                 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
                 * for equality comparisons, in which only the first occurrence of each element
                 * is kept. The order of result values is determined by the order they occur
                 * in the array.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Array
                 * @param {Array} array The array to inspect.
                 * @returns {Array} Returns the new duplicate free array.
                 * @example
                 *
                 * _.uniq([2, 1, 2]);
                 * // => [2, 1]
                 */
                function uniq(array) {
                  return array && array.length ? baseUniq(array) : [];
                }

                /**
                 * This method is like `_.uniq` except that it accepts `iteratee` which is
                 * invoked for each element in `array` to generate the criterion by which
                 * uniqueness is computed. The order of result values is determined by the
                 * order they occur in the array. The iteratee is invoked with one argument:
                 * (value).
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Array
                 * @param {Array} array The array to inspect.
                 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
                 * @returns {Array} Returns the new duplicate free array.
                 * @example
                 *
                 * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
                 * // => [2.1, 1.2]
                 *
                 * // The `_.property` iteratee shorthand.
                 * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
                 * // => [{ 'x': 1 }, { 'x': 2 }]
                 */
                function uniqBy(array, iteratee) {
                  return array && array.length
                    ? baseUniq(array, getIteratee(iteratee, 2))
                    : [];
                }

                /**
                 * This method is like `_.uniq` except that it accepts `comparator` which
                 * is invoked to compare elements of `array`. The order of result values is
                 * determined by the order they occur in the array.The comparator is invoked
                 * with two arguments: (arrVal, othVal).
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Array
                 * @param {Array} array The array to inspect.
                 * @param {Function} [comparator] The comparator invoked per element.
                 * @returns {Array} Returns the new duplicate free array.
                 * @example
                 *
                 * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
                 *
                 * _.uniqWith(objects, _.isEqual);
                 * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
                 */
                function uniqWith(array, comparator) {
                  comparator =
                    typeof comparator == "function" ? comparator : undefined;
                  return array && array.length
                    ? baseUniq(array, undefined, comparator)
                    : [];
                }

                /**
                 * This method is like `_.zip` except that it accepts an array of grouped
                 * elements and creates an array regrouping the elements to their pre-zip
                 * configuration.
                 *
                 * @static
                 * @memberOf _
                 * @since 1.2.0
                 * @category Array
                 * @param {Array} array The array of grouped elements to process.
                 * @returns {Array} Returns the new array of regrouped elements.
                 * @example
                 *
                 * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
                 * // => [['a', 1, true], ['b', 2, false]]
                 *
                 * _.unzip(zipped);
                 * // => [['a', 'b'], [1, 2], [true, false]]
                 */
                function unzip(array) {
                  if (!(array && array.length)) {
                    return [];
                  }
                  var length = 0;
                  array = arrayFilter(array, function (group) {
                    if (isArrayLikeObject(group)) {
                      length = nativeMax(group.length, length);
                      return true;
                    }
                  });
                  return baseTimes(length, function (index) {
                    return arrayMap(array, baseProperty(index));
                  });
                }

                /**
                 * This method is like `_.unzip` except that it accepts `iteratee` to specify
                 * how regrouped values should be combined. The iteratee is invoked with the
                 * elements of each group: (...group).
                 *
                 * @static
                 * @memberOf _
                 * @since 3.8.0
                 * @category Array
                 * @param {Array} array The array of grouped elements to process.
                 * @param {Function} [iteratee=_.identity] The function to combine
                 *  regrouped values.
                 * @returns {Array} Returns the new array of regrouped elements.
                 * @example
                 *
                 * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
                 * // => [[1, 10, 100], [2, 20, 200]]
                 *
                 * _.unzipWith(zipped, _.add);
                 * // => [3, 30, 300]
                 */
                function unzipWith(array, iteratee) {
                  if (!(array && array.length)) {
                    return [];
                  }
                  var result = unzip(array);
                  if (iteratee == null) {
                    return result;
                  }
                  return arrayMap(result, function (group) {
                    return apply(iteratee, undefined, group);
                  });
                }

                /**
                 * Creates an array excluding all given values using
                 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
                 * for equality comparisons.
                 *
                 * **Note:** Unlike `_.pull`, this method returns a new array.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Array
                 * @param {Array} array The array to inspect.
                 * @param {...*} [values] The values to exclude.
                 * @returns {Array} Returns the new array of filtered values.
                 * @see _.difference, _.xor
                 * @example
                 *
                 * _.without([2, 1, 2, 3], 1, 2);
                 * // => [3]
                 */
                var without = baseRest(function (array, values) {
                  return isArrayLikeObject(array)
                    ? baseDifference(array, values)
                    : [];
                });

                /**
                 * Creates an array of unique values that is the
                 * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
                 * of the given arrays. The order of result values is determined by the order
                 * they occur in the arrays.
                 *
                 * @static
                 * @memberOf _
                 * @since 2.4.0
                 * @category Array
                 * @param {...Array} [arrays] The arrays to inspect.
                 * @returns {Array} Returns the new array of filtered values.
                 * @see _.difference, _.without
                 * @example
                 *
                 * _.xor([2, 1], [2, 3]);
                 * // => [1, 3]
                 */
                var xor = baseRest(function (arrays) {
                  return baseXor(arrayFilter(arrays, isArrayLikeObject));
                });

                /**
                 * This method is like `_.xor` except that it accepts `iteratee` which is
                 * invoked for each element of each `arrays` to generate the criterion by
                 * which by which they're compared. The order of result values is determined
                 * by the order they occur in the arrays. The iteratee is invoked with one
                 * argument: (value).
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Array
                 * @param {...Array} [arrays] The arrays to inspect.
                 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
                 * @returns {Array} Returns the new array of filtered values.
                 * @example
                 *
                 * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
                 * // => [1.2, 3.4]
                 *
                 * // The `_.property` iteratee shorthand.
                 * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
                 * // => [{ 'x': 2 }]
                 */
                var xorBy = baseRest(function (arrays) {
                  var iteratee = last(arrays);
                  if (isArrayLikeObject(iteratee)) {
                    iteratee = undefined;
                  }
                  return baseXor(
                    arrayFilter(arrays, isArrayLikeObject),
                    getIteratee(iteratee, 2)
                  );
                });

                /**
                 * This method is like `_.xor` except that it accepts `comparator` which is
                 * invoked to compare elements of `arrays`. The order of result values is
                 * determined by the order they occur in the arrays. The comparator is invoked
                 * with two arguments: (arrVal, othVal).
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Array
                 * @param {...Array} [arrays] The arrays to inspect.
                 * @param {Function} [comparator] The comparator invoked per element.
                 * @returns {Array} Returns the new array of filtered values.
                 * @example
                 *
                 * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
                 * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
                 *
                 * _.xorWith(objects, others, _.isEqual);
                 * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
                 */
                var xorWith = baseRest(function (arrays) {
                  var comparator = last(arrays);
                  comparator =
                    typeof comparator == "function" ? comparator : undefined;
                  return baseXor(
                    arrayFilter(arrays, isArrayLikeObject),
                    undefined,
                    comparator
                  );
                });

                /**
                 * Creates an array of grouped elements, the first of which contains the
                 * first elements of the given arrays, the second of which contains the
                 * second elements of the given arrays, and so on.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Array
                 * @param {...Array} [arrays] The arrays to process.
                 * @returns {Array} Returns the new array of grouped elements.
                 * @example
                 *
                 * _.zip(['a', 'b'], [1, 2], [true, false]);
                 * // => [['a', 1, true], ['b', 2, false]]
                 */
                var zip = baseRest(unzip);

                /**
                 * This method is like `_.fromPairs` except that it accepts two arrays,
                 * one of property identifiers and one of corresponding values.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.4.0
                 * @category Array
                 * @param {Array} [props=[]] The property identifiers.
                 * @param {Array} [values=[]] The property values.
                 * @returns {Object} Returns the new object.
                 * @example
                 *
                 * _.zipObject(['a', 'b'], [1, 2]);
                 * // => { 'a': 1, 'b': 2 }
                 */
                function zipObject(props, values) {
                  return baseZipObject(props || [], values || [], assignValue);
                }

                /**
                 * This method is like `_.zipObject` except that it supports property paths.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.1.0
                 * @category Array
                 * @param {Array} [props=[]] The property identifiers.
                 * @param {Array} [values=[]] The property values.
                 * @returns {Object} Returns the new object.
                 * @example
                 *
                 * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
                 * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
                 */
                function zipObjectDeep(props, values) {
                  return baseZipObject(props || [], values || [], baseSet);
                }

                /**
                 * This method is like `_.zip` except that it accepts `iteratee` to specify
                 * how grouped values should be combined. The iteratee is invoked with the
                 * elements of each group: (...group).
                 *
                 * @static
                 * @memberOf _
                 * @since 3.8.0
                 * @category Array
                 * @param {...Array} [arrays] The arrays to process.
                 * @param {Function} [iteratee=_.identity] The function to combine
                 *  grouped values.
                 * @returns {Array} Returns the new array of grouped elements.
                 * @example
                 *
                 * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
                 *   return a + b + c;
                 * });
                 * // => [111, 222]
                 */
                var zipWith = baseRest(function (arrays) {
                  var length = arrays.length,
                    iteratee = length > 1 ? arrays[length - 1] : undefined;

                  iteratee =
                    typeof iteratee == "function"
                      ? (arrays.pop(), iteratee)
                      : undefined;
                  return unzipWith(arrays, iteratee);
                });

                /*------------------------------------------------------------------------*/

                /**
                 * Creates a `lodash` wrapper instance that wraps `value` with explicit method
                 * chain sequences enabled. The result of such sequences must be unwrapped
                 * with `_#value`.
                 *
                 * @static
                 * @memberOf _
                 * @since 1.3.0
                 * @category Seq
                 * @param {*} value The value to wrap.
                 * @returns {Object} Returns the new `lodash` wrapper instance.
                 * @example
                 *
                 * var users = [
                 *   { 'user': 'barney',  'age': 36 },
                 *   { 'user': 'fred',    'age': 40 },
                 *   { 'user': 'pebbles', 'age': 1 }
                 * ];
                 *
                 * var youngest = _
                 *   .chain(users)
                 *   .sortBy('age')
                 *   .map(function(o) {
                 *     return o.user + ' is ' + o.age;
                 *   })
                 *   .head()
                 *   .value();
                 * // => 'pebbles is 1'
                 */
                function chain(value) {
                  var result = lodash(value);
                  result.__chain__ = true;
                  return result;
                }

                /**
                 * This method invokes `interceptor` and returns `value`. The interceptor
                 * is invoked with one argument; (value). The purpose of this method is to
                 * "tap into" a method chain sequence in order to modify intermediate results.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Seq
                 * @param {*} value The value to provide to `interceptor`.
                 * @param {Function} interceptor The function to invoke.
                 * @returns {*} Returns `value`.
                 * @example
                 *
                 * _([1, 2, 3])
                 *  .tap(function(array) {
                 *    // Mutate input array.
                 *    array.pop();
                 *  })
                 *  .reverse()
                 *  .value();
                 * // => [2, 1]
                 */
                function tap(value, interceptor) {
                  interceptor(value);
                  return value;
                }

                /**
                 * This method is like `_.tap` except that it returns the result of `interceptor`.
                 * The purpose of this method is to "pass thru" values replacing intermediate
                 * results in a method chain sequence.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category Seq
                 * @param {*} value The value to provide to `interceptor`.
                 * @param {Function} interceptor The function to invoke.
                 * @returns {*} Returns the result of `interceptor`.
                 * @example
                 *
                 * _('  abc  ')
                 *  .chain()
                 *  .trim()
                 *  .thru(function(value) {
                 *    return [value];
                 *  })
                 *  .value();
                 * // => ['abc']
                 */
                function thru(value, interceptor) {
                  return interceptor(value);
                }

                /**
                 * This method is the wrapper version of `_.at`.
                 *
                 * @name at
                 * @memberOf _
                 * @since 1.0.0
                 * @category Seq
                 * @param {...(string|string[])} [paths] The property paths to pick.
                 * @returns {Object} Returns the new `lodash` wrapper instance.
                 * @example
                 *
                 * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
                 *
                 * _(object).at(['a[0].b.c', 'a[1]']).value();
                 * // => [3, 4]
                 */
                var wrapperAt = flatRest(function (paths) {
                  var length = paths.length,
                    start = length ? paths[0] : 0,
                    value = this.__wrapped__,
                    interceptor = function (object) {
                      return baseAt(object, paths);
                    };

                  if (
                    length > 1 ||
                    this.__actions__.length ||
                    !(value instanceof LazyWrapper) ||
                    !isIndex(start)
                  ) {
                    return this.thru(interceptor);
                  }
                  value = value.slice(start, +start + (length ? 1 : 0));
                  value.__actions__.push({
                    func: thru,
                    args: [interceptor],
                    thisArg: undefined,
                  });
                  return new LodashWrapper(value, this.__chain__).thru(
                    function (array) {
                      if (length && !array.length) {
                        array.push(undefined);
                      }
                      return array;
                    }
                  );
                });

                /**
                 * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
                 *
                 * @name chain
                 * @memberOf _
                 * @since 0.1.0
                 * @category Seq
                 * @returns {Object} Returns the new `lodash` wrapper instance.
                 * @example
                 *
                 * var users = [
                 *   { 'user': 'barney', 'age': 36 },
                 *   { 'user': 'fred',   'age': 40 }
                 * ];
                 *
                 * // A sequence without explicit chaining.
                 * _(users).head();
                 * // => { 'user': 'barney', 'age': 36 }
                 *
                 * // A sequence with explicit chaining.
                 * _(users)
                 *   .chain()
                 *   .head()
                 *   .pick('user')
                 *   .value();
                 * // => { 'user': 'barney' }
                 */
                function wrapperChain() {
                  return chain(this);
                }

                /**
                 * Executes the chain sequence and returns the wrapped result.
                 *
                 * @name commit
                 * @memberOf _
                 * @since 3.2.0
                 * @category Seq
                 * @returns {Object} Returns the new `lodash` wrapper instance.
                 * @example
                 *
                 * var array = [1, 2];
                 * var wrapped = _(array).push(3);
                 *
                 * console.log(array);
                 * // => [1, 2]
                 *
                 * wrapped = wrapped.commit();
                 * console.log(array);
                 * // => [1, 2, 3]
                 *
                 * wrapped.last();
                 * // => 3
                 *
                 * console.log(array);
                 * // => [1, 2, 3]
                 */
                function wrapperCommit() {
                  return new LodashWrapper(this.value(), this.__chain__);
                }

                /**
                 * Gets the next value on a wrapped object following the
                 * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
                 *
                 * @name next
                 * @memberOf _
                 * @since 4.0.0
                 * @category Seq
                 * @returns {Object} Returns the next iterator value.
                 * @example
                 *
                 * var wrapped = _([1, 2]);
                 *
                 * wrapped.next();
                 * // => { 'done': false, 'value': 1 }
                 *
                 * wrapped.next();
                 * // => { 'done': false, 'value': 2 }
                 *
                 * wrapped.next();
                 * // => { 'done': true, 'value': undefined }
                 */
                function wrapperNext() {
                  if (this.__values__ === undefined) {
                    this.__values__ = toArray(this.value());
                  }
                  var done = this.__index__ >= this.__values__.length,
                    value = done
                      ? undefined
                      : this.__values__[this.__index__++];

                  return { done: done, value: value };
                }

                /**
                 * Enables the wrapper to be iterable.
                 *
                 * @name Symbol.iterator
                 * @memberOf _
                 * @since 4.0.0
                 * @category Seq
                 * @returns {Object} Returns the wrapper object.
                 * @example
                 *
                 * var wrapped = _([1, 2]);
                 *
                 * wrapped[Symbol.iterator]() === wrapped;
                 * // => true
                 *
                 * Array.from(wrapped);
                 * // => [1, 2]
                 */
                function wrapperToIterator() {
                  return this;
                }

                /**
                 * Creates a clone of the chain sequence planting `value` as the wrapped value.
                 *
                 * @name plant
                 * @memberOf _
                 * @since 3.2.0
                 * @category Seq
                 * @param {*} value The value to plant.
                 * @returns {Object} Returns the new `lodash` wrapper instance.
                 * @example
                 *
                 * function square(n) {
                 *   return n * n;
                 * }
                 *
                 * var wrapped = _([1, 2]).map(square);
                 * var other = wrapped.plant([3, 4]);
                 *
                 * other.value();
                 * // => [9, 16]
                 *
                 * wrapped.value();
                 * // => [1, 4]
                 */
                function wrapperPlant(value) {
                  var result,
                    parent = this;

                  while (parent instanceof baseLodash) {
                    var clone = wrapperClone(parent);
                    clone.__index__ = 0;
                    clone.__values__ = undefined;
                    if (result) {
                      previous.__wrapped__ = clone;
                    } else {
                      result = clone;
                    }
                    var previous = clone;
                    parent = parent.__wrapped__;
                  }
                  previous.__wrapped__ = value;
                  return result;
                }

                /**
                 * This method is the wrapper version of `_.reverse`.
                 *
                 * **Note:** This method mutates the wrapped array.
                 *
                 * @name reverse
                 * @memberOf _
                 * @since 0.1.0
                 * @category Seq
                 * @returns {Object} Returns the new `lodash` wrapper instance.
                 * @example
                 *
                 * var array = [1, 2, 3];
                 *
                 * _(array).reverse().value()
                 * // => [3, 2, 1]
                 *
                 * console.log(array);
                 * // => [3, 2, 1]
                 */
                function wrapperReverse() {
                  var value = this.__wrapped__;
                  if (value instanceof LazyWrapper) {
                    var wrapped = value;
                    if (this.__actions__.length) {
                      wrapped = new LazyWrapper(this);
                    }
                    wrapped = wrapped.reverse();
                    wrapped.__actions__.push({
                      func: thru,
                      args: [reverse],
                      thisArg: undefined,
                    });
                    return new LodashWrapper(wrapped, this.__chain__);
                  }
                  return this.thru(reverse);
                }

                /**
                 * Executes the chain sequence to resolve the unwrapped value.
                 *
                 * @name value
                 * @memberOf _
                 * @since 0.1.0
                 * @alias toJSON, valueOf
                 * @category Seq
                 * @returns {*} Returns the resolved unwrapped value.
                 * @example
                 *
                 * _([1, 2, 3]).value();
                 * // => [1, 2, 3]
                 */
                function wrapperValue() {
                  return baseWrapperValue(this.__wrapped__, this.__actions__);
                }

                /*------------------------------------------------------------------------*/

                /**
                 * Creates an object composed of keys generated from the results of running
                 * each element of `collection` thru `iteratee`. The corresponding value of
                 * each key is the number of times the key was returned by `iteratee`. The
                 * iteratee is invoked with one argument: (value).
                 *
                 * @static
                 * @memberOf _
                 * @since 0.5.0
                 * @category Collection
                 * @param {Array|Object} collection The collection to iterate over.
                 * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
                 * @returns {Object} Returns the composed aggregate object.
                 * @example
                 *
                 * _.countBy([6.1, 4.2, 6.3], Math.floor);
                 * // => { '4': 1, '6': 2 }
                 *
                 * // The `_.property` iteratee shorthand.
                 * _.countBy(['one', 'two', 'three'], 'length');
                 * // => { '3': 2, '5': 1 }
                 */
                var countBy = createAggregator(function (result, value, key) {
                  if (hasOwnProperty.call(result, key)) {
                    ++result[key];
                  } else {
                    baseAssignValue(result, key, 1);
                  }
                });

                /**
                 * Checks if `predicate` returns truthy for **all** elements of `collection`.
                 * Iteration is stopped once `predicate` returns falsey. The predicate is
                 * invoked with three arguments: (value, index|key, collection).
                 *
                 * **Note:** This method returns `true` for
                 * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
                 * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
                 * elements of empty collections.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Collection
                 * @param {Array|Object} collection The collection to iterate over.
                 * @param {Function} [predicate=_.identity] The function invoked per iteration.
                 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
                 * @returns {boolean} Returns `true` if all elements pass the predicate check,
                 *  else `false`.
                 * @example
                 *
                 * _.every([true, 1, null, 'yes'], Boolean);
                 * // => false
                 *
                 * var users = [
                 *   { 'user': 'barney', 'age': 36, 'active': false },
                 *   { 'user': 'fred',   'age': 40, 'active': false }
                 * ];
                 *
                 * // The `_.matches` iteratee shorthand.
                 * _.every(users, { 'user': 'barney', 'active': false });
                 * // => false
                 *
                 * // The `_.matchesProperty` iteratee shorthand.
                 * _.every(users, ['active', false]);
                 * // => true
                 *
                 * // The `_.property` iteratee shorthand.
                 * _.every(users, 'active');
                 * // => false
                 */
                function every(collection, predicate, guard) {
                  var func = isArray(collection) ? arrayEvery : baseEvery;
                  if (guard && isIterateeCall(collection, predicate, guard)) {
                    predicate = undefined;
                  }
                  return func(collection, getIteratee(predicate, 3));
                }

                /**
                 * Iterates over elements of `collection`, returning an array of all elements
                 * `predicate` returns truthy for. The predicate is invoked with three
                 * arguments: (value, index|key, collection).
                 *
                 * **Note:** Unlike `_.remove`, this method returns a new array.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Collection
                 * @param {Array|Object} collection The collection to iterate over.
                 * @param {Function} [predicate=_.identity] The function invoked per iteration.
                 * @returns {Array} Returns the new filtered array.
                 * @see _.reject
                 * @example
                 *
                 * var users = [
                 *   { 'user': 'barney', 'age': 36, 'active': true },
                 *   { 'user': 'fred',   'age': 40, 'active': false }
                 * ];
                 *
                 * _.filter(users, function(o) { return !o.active; });
                 * // => objects for ['fred']
                 *
                 * // The `_.matches` iteratee shorthand.
                 * _.filter(users, { 'age': 36, 'active': true });
                 * // => objects for ['barney']
                 *
                 * // The `_.matchesProperty` iteratee shorthand.
                 * _.filter(users, ['active', false]);
                 * // => objects for ['fred']
                 *
                 * // The `_.property` iteratee shorthand.
                 * _.filter(users, 'active');
                 * // => objects for ['barney']
                 *
                 * // Combining several predicates using `_.overEvery` or `_.overSome`.
                 * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));
                 * // => objects for ['fred', 'barney']
                 */
                function filter(collection, predicate) {
                  var func = isArray(collection) ? arrayFilter : baseFilter;
                  return func(collection, getIteratee(predicate, 3));
                }

                /**
                 * Iterates over elements of `collection`, returning the first element
                 * `predicate` returns truthy for. The predicate is invoked with three
                 * arguments: (value, index|key, collection).
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Collection
                 * @param {Array|Object} collection The collection to inspect.
                 * @param {Function} [predicate=_.identity] The function invoked per iteration.
                 * @param {number} [fromIndex=0] The index to search from.
                 * @returns {*} Returns the matched element, else `undefined`.
                 * @example
                 *
                 * var users = [
                 *   { 'user': 'barney',  'age': 36, 'active': true },
                 *   { 'user': 'fred',    'age': 40, 'active': false },
                 *   { 'user': 'pebbles', 'age': 1,  'active': true }
                 * ];
                 *
                 * _.find(users, function(o) { return o.age < 40; });
                 * // => object for 'barney'
                 *
                 * // The `_.matches` iteratee shorthand.
                 * _.find(users, { 'age': 1, 'active': true });
                 * // => object for 'pebbles'
                 *
                 * // The `_.matchesProperty` iteratee shorthand.
                 * _.find(users, ['active', false]);
                 * // => object for 'fred'
                 *
                 * // The `_.property` iteratee shorthand.
                 * _.find(users, 'active');
                 * // => object for 'barney'
                 */
                var find = createFind(findIndex);

                /**
                 * This method is like `_.find` except that it iterates over elements of
                 * `collection` from right to left.
                 *
                 * @static
                 * @memberOf _
                 * @since 2.0.0
                 * @category Collection
                 * @param {Array|Object} collection The collection to inspect.
                 * @param {Function} [predicate=_.identity] The function invoked per iteration.
                 * @param {number} [fromIndex=collection.length-1] The index to search from.
                 * @returns {*} Returns the matched element, else `undefined`.
                 * @example
                 *
                 * _.findLast([1, 2, 3, 4], function(n) {
                 *   return n % 2 == 1;
                 * });
                 * // => 3
                 */
                var findLast = createFind(findLastIndex);

                /**
                 * Creates a flattened array of values by running each element in `collection`
                 * thru `iteratee` and flattening the mapped results. The iteratee is invoked
                 * with three arguments: (value, index|key, collection).
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Collection
                 * @param {Array|Object} collection The collection to iterate over.
                 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                 * @returns {Array} Returns the new flattened array.
                 * @example
                 *
                 * function duplicate(n) {
                 *   return [n, n];
                 * }
                 *
                 * _.flatMap([1, 2], duplicate);
                 * // => [1, 1, 2, 2]
                 */
                function flatMap(collection, iteratee) {
                  return baseFlatten(map(collection, iteratee), 1);
                }

                /**
                 * This method is like `_.flatMap` except that it recursively flattens the
                 * mapped results.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.7.0
                 * @category Collection
                 * @param {Array|Object} collection The collection to iterate over.
                 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                 * @returns {Array} Returns the new flattened array.
                 * @example
                 *
                 * function duplicate(n) {
                 *   return [[[n, n]]];
                 * }
                 *
                 * _.flatMapDeep([1, 2], duplicate);
                 * // => [1, 1, 2, 2]
                 */
                function flatMapDeep(collection, iteratee) {
                  return baseFlatten(map(collection, iteratee), INFINITY);
                }

                /**
                 * This method is like `_.flatMap` except that it recursively flattens the
                 * mapped results up to `depth` times.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.7.0
                 * @category Collection
                 * @param {Array|Object} collection The collection to iterate over.
                 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                 * @param {number} [depth=1] The maximum recursion depth.
                 * @returns {Array} Returns the new flattened array.
                 * @example
                 *
                 * function duplicate(n) {
                 *   return [[[n, n]]];
                 * }
                 *
                 * _.flatMapDepth([1, 2], duplicate, 2);
                 * // => [[1, 1], [2, 2]]
                 */
                function flatMapDepth(collection, iteratee, depth) {
                  depth = depth === undefined ? 1 : toInteger(depth);
                  return baseFlatten(map(collection, iteratee), depth);
                }

                /**
                 * Iterates over elements of `collection` and invokes `iteratee` for each element.
                 * The iteratee is invoked with three arguments: (value, index|key, collection).
                 * Iteratee functions may exit iteration early by explicitly returning `false`.
                 *
                 * **Note:** As with other "Collections" methods, objects with a "length"
                 * property are iterated like arrays. To avoid this behavior use `_.forIn`
                 * or `_.forOwn` for object iteration.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @alias each
                 * @category Collection
                 * @param {Array|Object} collection The collection to iterate over.
                 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                 * @returns {Array|Object} Returns `collection`.
                 * @see _.forEachRight
                 * @example
                 *
                 * _.forEach([1, 2], function(value) {
                 *   console.log(value);
                 * });
                 * // => Logs `1` then `2`.
                 *
                 * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
                 *   console.log(key);
                 * });
                 * // => Logs 'a' then 'b' (iteration order is not guaranteed).
                 */
                function forEach(collection, iteratee) {
                  var func = isArray(collection) ? arrayEach : baseEach;
                  return func(collection, getIteratee(iteratee, 3));
                }

                /**
                 * This method is like `_.forEach` except that it iterates over elements of
                 * `collection` from right to left.
                 *
                 * @static
                 * @memberOf _
                 * @since 2.0.0
                 * @alias eachRight
                 * @category Collection
                 * @param {Array|Object} collection The collection to iterate over.
                 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                 * @returns {Array|Object} Returns `collection`.
                 * @see _.forEach
                 * @example
                 *
                 * _.forEachRight([1, 2], function(value) {
                 *   console.log(value);
                 * });
                 * // => Logs `2` then `1`.
                 */
                function forEachRight(collection, iteratee) {
                  var func = isArray(collection)
                    ? arrayEachRight
                    : baseEachRight;
                  return func(collection, getIteratee(iteratee, 3));
                }

                /**
                 * Creates an object composed of keys generated from the results of running
                 * each element of `collection` thru `iteratee`. The order of grouped values
                 * is determined by the order they occur in `collection`. The corresponding
                 * value of each key is an array of elements responsible for generating the
                 * key. The iteratee is invoked with one argument: (value).
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Collection
                 * @param {Array|Object} collection The collection to iterate over.
                 * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
                 * @returns {Object} Returns the composed aggregate object.
                 * @example
                 *
                 * _.groupBy([6.1, 4.2, 6.3], Math.floor);
                 * // => { '4': [4.2], '6': [6.1, 6.3] }
                 *
                 * // The `_.property` iteratee shorthand.
                 * _.groupBy(['one', 'two', 'three'], 'length');
                 * // => { '3': ['one', 'two'], '5': ['three'] }
                 */
                var groupBy = createAggregator(function (result, value, key) {
                  if (hasOwnProperty.call(result, key)) {
                    result[key].push(value);
                  } else {
                    baseAssignValue(result, key, [value]);
                  }
                });

                /**
                 * Checks if `value` is in `collection`. If `collection` is a string, it's
                 * checked for a substring of `value`, otherwise
                 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
                 * is used for equality comparisons. If `fromIndex` is negative, it's used as
                 * the offset from the end of `collection`.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Collection
                 * @param {Array|Object|string} collection The collection to inspect.
                 * @param {*} value The value to search for.
                 * @param {number} [fromIndex=0] The index to search from.
                 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
                 * @returns {boolean} Returns `true` if `value` is found, else `false`.
                 * @example
                 *
                 * _.includes([1, 2, 3], 1);
                 * // => true
                 *
                 * _.includes([1, 2, 3], 1, 2);
                 * // => false
                 *
                 * _.includes({ 'a': 1, 'b': 2 }, 1);
                 * // => true
                 *
                 * _.includes('abcd', 'bc');
                 * // => true
                 */
                function includes(collection, value, fromIndex, guard) {
                  collection = isArrayLike(collection)
                    ? collection
                    : values(collection);
                  fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;

                  var length = collection.length;
                  if (fromIndex < 0) {
                    fromIndex = nativeMax(length + fromIndex, 0);
                  }
                  return isString(collection)
                    ? fromIndex <= length &&
                        collection.indexOf(value, fromIndex) > -1
                    : !!length &&
                        baseIndexOf(collection, value, fromIndex) > -1;
                }

                /**
                 * Invokes the method at `path` of each element in `collection`, returning
                 * an array of the results of each invoked method. Any additional arguments
                 * are provided to each invoked method. If `path` is a function, it's invoked
                 * for, and `this` bound to, each element in `collection`.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Collection
                 * @param {Array|Object} collection The collection to iterate over.
                 * @param {Array|Function|string} path The path of the method to invoke or
                 *  the function invoked per iteration.
                 * @param {...*} [args] The arguments to invoke each method with.
                 * @returns {Array} Returns the array of results.
                 * @example
                 *
                 * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
                 * // => [[1, 5, 7], [1, 2, 3]]
                 *
                 * _.invokeMap([123, 456], String.prototype.split, '');
                 * // => [['1', '2', '3'], ['4', '5', '6']]
                 */
                var invokeMap = baseRest(function (collection, path, args) {
                  var index = -1,
                    isFunc = typeof path == "function",
                    result = isArrayLike(collection)
                      ? Array(collection.length)
                      : [];

                  baseEach(collection, function (value) {
                    result[++index] = isFunc
                      ? apply(path, value, args)
                      : baseInvoke(value, path, args);
                  });
                  return result;
                });

                /**
                 * Creates an object composed of keys generated from the results of running
                 * each element of `collection` thru `iteratee`. The corresponding value of
                 * each key is the last element responsible for generating the key. The
                 * iteratee is invoked with one argument: (value).
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Collection
                 * @param {Array|Object} collection The collection to iterate over.
                 * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
                 * @returns {Object} Returns the composed aggregate object.
                 * @example
                 *
                 * var array = [
                 *   { 'dir': 'left', 'code': 97 },
                 *   { 'dir': 'right', 'code': 100 }
                 * ];
                 *
                 * _.keyBy(array, function(o) {
                 *   return String.fromCharCode(o.code);
                 * });
                 * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
                 *
                 * _.keyBy(array, 'dir');
                 * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
                 */
                var keyBy = createAggregator(function (result, value, key) {
                  baseAssignValue(result, key, value);
                });

                /**
                 * Creates an array of values by running each element in `collection` thru
                 * `iteratee`. The iteratee is invoked with three arguments:
                 * (value, index|key, collection).
                 *
                 * Many lodash methods are guarded to work as iteratees for methods like
                 * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
                 *
                 * The guarded methods are:
                 * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
                 * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
                 * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
                 * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Collection
                 * @param {Array|Object} collection The collection to iterate over.
                 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                 * @returns {Array} Returns the new mapped array.
                 * @example
                 *
                 * function square(n) {
                 *   return n * n;
                 * }
                 *
                 * _.map([4, 8], square);
                 * // => [16, 64]
                 *
                 * _.map({ 'a': 4, 'b': 8 }, square);
                 * // => [16, 64] (iteration order is not guaranteed)
                 *
                 * var users = [
                 *   { 'user': 'barney' },
                 *   { 'user': 'fred' }
                 * ];
                 *
                 * // The `_.property` iteratee shorthand.
                 * _.map(users, 'user');
                 * // => ['barney', 'fred']
                 */
                function map(collection, iteratee) {
                  var func = isArray(collection) ? arrayMap : baseMap;
                  return func(collection, getIteratee(iteratee, 3));
                }

                /**
                 * This method is like `_.sortBy` except that it allows specifying the sort
                 * orders of the iteratees to sort by. If `orders` is unspecified, all values
                 * are sorted in ascending order. Otherwise, specify an order of "desc" for
                 * descending or "asc" for ascending sort order of corresponding values.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Collection
                 * @param {Array|Object} collection The collection to iterate over.
                 * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
                 *  The iteratees to sort by.
                 * @param {string[]} [orders] The sort orders of `iteratees`.
                 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
                 * @returns {Array} Returns the new sorted array.
                 * @example
                 *
                 * var users = [
                 *   { 'user': 'fred',   'age': 48 },
                 *   { 'user': 'barney', 'age': 34 },
                 *   { 'user': 'fred',   'age': 40 },
                 *   { 'user': 'barney', 'age': 36 }
                 * ];
                 *
                 * // Sort by `user` in ascending order and by `age` in descending order.
                 * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
                 * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
                 */
                function orderBy(collection, iteratees, orders, guard) {
                  if (collection == null) {
                    return [];
                  }
                  if (!isArray(iteratees)) {
                    iteratees = iteratees == null ? [] : [iteratees];
                  }
                  orders = guard ? undefined : orders;
                  if (!isArray(orders)) {
                    orders = orders == null ? [] : [orders];
                  }
                  return baseOrderBy(collection, iteratees, orders);
                }

                /**
                 * Creates an array of elements split into two groups, the first of which
                 * contains elements `predicate` returns truthy for, the second of which
                 * contains elements `predicate` returns falsey for. The predicate is
                 * invoked with one argument: (value).
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category Collection
                 * @param {Array|Object} collection The collection to iterate over.
                 * @param {Function} [predicate=_.identity] The function invoked per iteration.
                 * @returns {Array} Returns the array of grouped elements.
                 * @example
                 *
                 * var users = [
                 *   { 'user': 'barney',  'age': 36, 'active': false },
                 *   { 'user': 'fred',    'age': 40, 'active': true },
                 *   { 'user': 'pebbles', 'age': 1,  'active': false }
                 * ];
                 *
                 * _.partition(users, function(o) { return o.active; });
                 * // => objects for [['fred'], ['barney', 'pebbles']]
                 *
                 * // The `_.matches` iteratee shorthand.
                 * _.partition(users, { 'age': 1, 'active': false });
                 * // => objects for [['pebbles'], ['barney', 'fred']]
                 *
                 * // The `_.matchesProperty` iteratee shorthand.
                 * _.partition(users, ['active', false]);
                 * // => objects for [['barney', 'pebbles'], ['fred']]
                 *
                 * // The `_.property` iteratee shorthand.
                 * _.partition(users, 'active');
                 * // => objects for [['fred'], ['barney', 'pebbles']]
                 */
                var partition = createAggregator(
                  function (result, value, key) {
                    result[key ? 0 : 1].push(value);
                  },
                  function () {
                    return [[], []];
                  }
                );

                /**
                 * Reduces `collection` to a value which is the accumulated result of running
                 * each element in `collection` thru `iteratee`, where each successive
                 * invocation is supplied the return value of the previous. If `accumulator`
                 * is not given, the first element of `collection` is used as the initial
                 * value. The iteratee is invoked with four arguments:
                 * (accumulator, value, index|key, collection).
                 *
                 * Many lodash methods are guarded to work as iteratees for methods like
                 * `_.reduce`, `_.reduceRight`, and `_.transform`.
                 *
                 * The guarded methods are:
                 * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
                 * and `sortBy`
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Collection
                 * @param {Array|Object} collection The collection to iterate over.
                 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                 * @param {*} [accumulator] The initial value.
                 * @returns {*} Returns the accumulated value.
                 * @see _.reduceRight
                 * @example
                 *
                 * _.reduce([1, 2], function(sum, n) {
                 *   return sum + n;
                 * }, 0);
                 * // => 3
                 *
                 * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
                 *   (result[value] || (result[value] = [])).push(key);
                 *   return result;
                 * }, {});
                 * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
                 */
                function reduce(collection, iteratee, accumulator) {
                  var func = isArray(collection) ? arrayReduce : baseReduce,
                    initAccum = arguments.length < 3;

                  return func(
                    collection,
                    getIteratee(iteratee, 4),
                    accumulator,
                    initAccum,
                    baseEach
                  );
                }

                /**
                 * This method is like `_.reduce` except that it iterates over elements of
                 * `collection` from right to left.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Collection
                 * @param {Array|Object} collection The collection to iterate over.
                 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                 * @param {*} [accumulator] The initial value.
                 * @returns {*} Returns the accumulated value.
                 * @see _.reduce
                 * @example
                 *
                 * var array = [[0, 1], [2, 3], [4, 5]];
                 *
                 * _.reduceRight(array, function(flattened, other) {
                 *   return flattened.concat(other);
                 * }, []);
                 * // => [4, 5, 2, 3, 0, 1]
                 */
                function reduceRight(collection, iteratee, accumulator) {
                  var func = isArray(collection)
                      ? arrayReduceRight
                      : baseReduce,
                    initAccum = arguments.length < 3;

                  return func(
                    collection,
                    getIteratee(iteratee, 4),
                    accumulator,
                    initAccum,
                    baseEachRight
                  );
                }

                /**
                 * The opposite of `_.filter`; this method returns the elements of `collection`
                 * that `predicate` does **not** return truthy for.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Collection
                 * @param {Array|Object} collection The collection to iterate over.
                 * @param {Function} [predicate=_.identity] The function invoked per iteration.
                 * @returns {Array} Returns the new filtered array.
                 * @see _.filter
                 * @example
                 *
                 * var users = [
                 *   { 'user': 'barney', 'age': 36, 'active': false },
                 *   { 'user': 'fred',   'age': 40, 'active': true }
                 * ];
                 *
                 * _.reject(users, function(o) { return !o.active; });
                 * // => objects for ['fred']
                 *
                 * // The `_.matches` iteratee shorthand.
                 * _.reject(users, { 'age': 40, 'active': true });
                 * // => objects for ['barney']
                 *
                 * // The `_.matchesProperty` iteratee shorthand.
                 * _.reject(users, ['active', false]);
                 * // => objects for ['fred']
                 *
                 * // The `_.property` iteratee shorthand.
                 * _.reject(users, 'active');
                 * // => objects for ['barney']
                 */
                function reject(collection, predicate) {
                  var func = isArray(collection) ? arrayFilter : baseFilter;
                  return func(collection, negate(getIteratee(predicate, 3)));
                }

                /**
                 * Gets a random element from `collection`.
                 *
                 * @static
                 * @memberOf _
                 * @since 2.0.0
                 * @category Collection
                 * @param {Array|Object} collection The collection to sample.
                 * @returns {*} Returns the random element.
                 * @example
                 *
                 * _.sample([1, 2, 3, 4]);
                 * // => 2
                 */
                function sample(collection) {
                  var func = isArray(collection) ? arraySample : baseSample;
                  return func(collection);
                }

                /**
                 * Gets `n` random elements at unique keys from `collection` up to the
                 * size of `collection`.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Collection
                 * @param {Array|Object} collection The collection to sample.
                 * @param {number} [n=1] The number of elements to sample.
                 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
                 * @returns {Array} Returns the random elements.
                 * @example
                 *
                 * _.sampleSize([1, 2, 3], 2);
                 * // => [3, 1]
                 *
                 * _.sampleSize([1, 2, 3], 4);
                 * // => [2, 3, 1]
                 */
                function sampleSize(collection, n, guard) {
                  if (
                    guard
                      ? isIterateeCall(collection, n, guard)
                      : n === undefined
                  ) {
                    n = 1;
                  } else {
                    n = toInteger(n);
                  }
                  var func = isArray(collection)
                    ? arraySampleSize
                    : baseSampleSize;
                  return func(collection, n);
                }

                /**
                 * Creates an array of shuffled values, using a version of the
                 * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Collection
                 * @param {Array|Object} collection The collection to shuffle.
                 * @returns {Array} Returns the new shuffled array.
                 * @example
                 *
                 * _.shuffle([1, 2, 3, 4]);
                 * // => [4, 1, 3, 2]
                 */
                function shuffle(collection) {
                  var func = isArray(collection) ? arrayShuffle : baseShuffle;
                  return func(collection);
                }

                /**
                 * Gets the size of `collection` by returning its length for array-like
                 * values or the number of own enumerable string keyed properties for objects.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Collection
                 * @param {Array|Object|string} collection The collection to inspect.
                 * @returns {number} Returns the collection size.
                 * @example
                 *
                 * _.size([1, 2, 3]);
                 * // => 3
                 *
                 * _.size({ 'a': 1, 'b': 2 });
                 * // => 2
                 *
                 * _.size('pebbles');
                 * // => 7
                 */
                function size(collection) {
                  if (collection == null) {
                    return 0;
                  }
                  if (isArrayLike(collection)) {
                    return isString(collection)
                      ? stringSize(collection)
                      : collection.length;
                  }
                  var tag = getTag(collection);
                  if (tag == mapTag || tag == setTag) {
                    return collection.size;
                  }
                  return baseKeys(collection).length;
                }

                /**
                 * Checks if `predicate` returns truthy for **any** element of `collection`.
                 * Iteration is stopped once `predicate` returns truthy. The predicate is
                 * invoked with three arguments: (value, index|key, collection).
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Collection
                 * @param {Array|Object} collection The collection to iterate over.
                 * @param {Function} [predicate=_.identity] The function invoked per iteration.
                 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
                 * @returns {boolean} Returns `true` if any element passes the predicate check,
                 *  else `false`.
                 * @example
                 *
                 * _.some([null, 0, 'yes', false], Boolean);
                 * // => true
                 *
                 * var users = [
                 *   { 'user': 'barney', 'active': true },
                 *   { 'user': 'fred',   'active': false }
                 * ];
                 *
                 * // The `_.matches` iteratee shorthand.
                 * _.some(users, { 'user': 'barney', 'active': false });
                 * // => false
                 *
                 * // The `_.matchesProperty` iteratee shorthand.
                 * _.some(users, ['active', false]);
                 * // => true
                 *
                 * // The `_.property` iteratee shorthand.
                 * _.some(users, 'active');
                 * // => true
                 */
                function some(collection, predicate, guard) {
                  var func = isArray(collection) ? arraySome : baseSome;
                  if (guard && isIterateeCall(collection, predicate, guard)) {
                    predicate = undefined;
                  }
                  return func(collection, getIteratee(predicate, 3));
                }

                /**
                 * Creates an array of elements, sorted in ascending order by the results of
                 * running each element in a collection thru each iteratee. This method
                 * performs a stable sort, that is, it preserves the original sort order of
                 * equal elements. The iteratees are invoked with one argument: (value).
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Collection
                 * @param {Array|Object} collection The collection to iterate over.
                 * @param {...(Function|Function[])} [iteratees=[_.identity]]
                 *  The iteratees to sort by.
                 * @returns {Array} Returns the new sorted array.
                 * @example
                 *
                 * var users = [
                 *   { 'user': 'fred',   'age': 48 },
                 *   { 'user': 'barney', 'age': 36 },
                 *   { 'user': 'fred',   'age': 30 },
                 *   { 'user': 'barney', 'age': 34 }
                 * ];
                 *
                 * _.sortBy(users, [function(o) { return o.user; }]);
                 * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
                 *
                 * _.sortBy(users, ['user', 'age']);
                 * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
                 */
                var sortBy = baseRest(function (collection, iteratees) {
                  if (collection == null) {
                    return [];
                  }
                  var length = iteratees.length;
                  if (
                    length > 1 &&
                    isIterateeCall(collection, iteratees[0], iteratees[1])
                  ) {
                    iteratees = [];
                  } else if (
                    length > 2 &&
                    isIterateeCall(iteratees[0], iteratees[1], iteratees[2])
                  ) {
                    iteratees = [iteratees[0]];
                  }
                  return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
                });

                /*------------------------------------------------------------------------*/

                /**
                 * Gets the timestamp of the number of milliseconds that have elapsed since
                 * the Unix epoch (1 January 1970 00:00:00 UTC).
                 *
                 * @static
                 * @memberOf _
                 * @since 2.4.0
                 * @category Date
                 * @returns {number} Returns the timestamp.
                 * @example
                 *
                 * _.defer(function(stamp) {
                 *   console.log(_.now() - stamp);
                 * }, _.now());
                 * // => Logs the number of milliseconds it took for the deferred invocation.
                 */
                var now =
                  ctxNow ||
                  function () {
                    return root.Date.now();
                  };

                /*------------------------------------------------------------------------*/

                /**
                 * The opposite of `_.before`; this method creates a function that invokes
                 * `func` once it's called `n` or more times.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Function
                 * @param {number} n The number of calls before `func` is invoked.
                 * @param {Function} func The function to restrict.
                 * @returns {Function} Returns the new restricted function.
                 * @example
                 *
                 * var saves = ['profile', 'settings'];
                 *
                 * var done = _.after(saves.length, function() {
                 *   console.log('done saving!');
                 * });
                 *
                 * _.forEach(saves, function(type) {
                 *   asyncSave({ 'type': type, 'complete': done });
                 * });
                 * // => Logs 'done saving!' after the two async saves have completed.
                 */
                function after(n, func) {
                  if (typeof func != "function") {
                    throw new TypeError(FUNC_ERROR_TEXT);
                  }
                  n = toInteger(n);
                  return function () {
                    if (--n < 1) {
                      return func.apply(this, arguments);
                    }
                  };
                }

                /**
                 * Creates a function that invokes `func`, with up to `n` arguments,
                 * ignoring any additional arguments.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category Function
                 * @param {Function} func The function to cap arguments for.
                 * @param {number} [n=func.length] The arity cap.
                 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
                 * @returns {Function} Returns the new capped function.
                 * @example
                 *
                 * _.map(['6', '8', '10'], _.ary(parseInt, 1));
                 * // => [6, 8, 10]
                 */
                function ary(func, n, guard) {
                  n = guard ? undefined : n;
                  n = func && n == null ? func.length : n;
                  return createWrap(
                    func,
                    WRAP_ARY_FLAG,
                    undefined,
                    undefined,
                    undefined,
                    undefined,
                    n
                  );
                }

                /**
                 * Creates a function that invokes `func`, with the `this` binding and arguments
                 * of the created function, while it's called less than `n` times. Subsequent
                 * calls to the created function return the result of the last `func` invocation.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category Function
                 * @param {number} n The number of calls at which `func` is no longer invoked.
                 * @param {Function} func The function to restrict.
                 * @returns {Function} Returns the new restricted function.
                 * @example
                 *
                 * jQuery(element).on('click', _.before(5, addContactToList));
                 * // => Allows adding up to 4 contacts to the list.
                 */
                function before(n, func) {
                  var result;
                  if (typeof func != "function") {
                    throw new TypeError(FUNC_ERROR_TEXT);
                  }
                  n = toInteger(n);
                  return function () {
                    if (--n > 0) {
                      result = func.apply(this, arguments);
                    }
                    if (n <= 1) {
                      func = undefined;
                    }
                    return result;
                  };
                }

                /**
                 * Creates a function that invokes `func` with the `this` binding of `thisArg`
                 * and `partials` prepended to the arguments it receives.
                 *
                 * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
                 * may be used as a placeholder for partially applied arguments.
                 *
                 * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
                 * property of bound functions.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Function
                 * @param {Function} func The function to bind.
                 * @param {*} thisArg The `this` binding of `func`.
                 * @param {...*} [partials] The arguments to be partially applied.
                 * @returns {Function} Returns the new bound function.
                 * @example
                 *
                 * function greet(greeting, punctuation) {
                 *   return greeting + ' ' + this.user + punctuation;
                 * }
                 *
                 * var object = { 'user': 'fred' };
                 *
                 * var bound = _.bind(greet, object, 'hi');
                 * bound('!');
                 * // => 'hi fred!'
                 *
                 * // Bound with placeholders.
                 * var bound = _.bind(greet, object, _, '!');
                 * bound('hi');
                 * // => 'hi fred!'
                 */
                var bind = baseRest(function (func, thisArg, partials) {
                  var bitmask = WRAP_BIND_FLAG;
                  if (partials.length) {
                    var holders = replaceHolders(partials, getHolder(bind));
                    bitmask |= WRAP_PARTIAL_FLAG;
                  }
                  return createWrap(func, bitmask, thisArg, partials, holders);
                });

                /**
                 * Creates a function that invokes the method at `object[key]` with `partials`
                 * prepended to the arguments it receives.
                 *
                 * This method differs from `_.bind` by allowing bound functions to reference
                 * methods that may be redefined or don't yet exist. See
                 * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
                 * for more details.
                 *
                 * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
                 * builds, may be used as a placeholder for partially applied arguments.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.10.0
                 * @category Function
                 * @param {Object} object The object to invoke the method on.
                 * @param {string} key The key of the method.
                 * @param {...*} [partials] The arguments to be partially applied.
                 * @returns {Function} Returns the new bound function.
                 * @example
                 *
                 * var object = {
                 *   'user': 'fred',
                 *   'greet': function(greeting, punctuation) {
                 *     return greeting + ' ' + this.user + punctuation;
                 *   }
                 * };
                 *
                 * var bound = _.bindKey(object, 'greet', 'hi');
                 * bound('!');
                 * // => 'hi fred!'
                 *
                 * object.greet = function(greeting, punctuation) {
                 *   return greeting + 'ya ' + this.user + punctuation;
                 * };
                 *
                 * bound('!');
                 * // => 'hiya fred!'
                 *
                 * // Bound with placeholders.
                 * var bound = _.bindKey(object, 'greet', _, '!');
                 * bound('hi');
                 * // => 'hiya fred!'
                 */
                var bindKey = baseRest(function (object, key, partials) {
                  var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
                  if (partials.length) {
                    var holders = replaceHolders(partials, getHolder(bindKey));
                    bitmask |= WRAP_PARTIAL_FLAG;
                  }
                  return createWrap(key, bitmask, object, partials, holders);
                });

                /**
                 * Creates a function that accepts arguments of `func` and either invokes
                 * `func` returning its result, if at least `arity` number of arguments have
                 * been provided, or returns a function that accepts the remaining `func`
                 * arguments, and so on. The arity of `func` may be specified if `func.length`
                 * is not sufficient.
                 *
                 * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
                 * may be used as a placeholder for provided arguments.
                 *
                 * **Note:** This method doesn't set the "length" property of curried functions.
                 *
                 * @static
                 * @memberOf _
                 * @since 2.0.0
                 * @category Function
                 * @param {Function} func The function to curry.
                 * @param {number} [arity=func.length] The arity of `func`.
                 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
                 * @returns {Function} Returns the new curried function.
                 * @example
                 *
                 * var abc = function(a, b, c) {
                 *   return [a, b, c];
                 * };
                 *
                 * var curried = _.curry(abc);
                 *
                 * curried(1)(2)(3);
                 * // => [1, 2, 3]
                 *
                 * curried(1, 2)(3);
                 * // => [1, 2, 3]
                 *
                 * curried(1, 2, 3);
                 * // => [1, 2, 3]
                 *
                 * // Curried with placeholders.
                 * curried(1)(_, 3)(2);
                 * // => [1, 2, 3]
                 */
                function curry(func, arity, guard) {
                  arity = guard ? undefined : arity;
                  var result = createWrap(
                    func,
                    WRAP_CURRY_FLAG,
                    undefined,
                    undefined,
                    undefined,
                    undefined,
                    undefined,
                    arity
                  );
                  result.placeholder = curry.placeholder;
                  return result;
                }

                /**
                 * This method is like `_.curry` except that arguments are applied to `func`
                 * in the manner of `_.partialRight` instead of `_.partial`.
                 *
                 * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
                 * builds, may be used as a placeholder for provided arguments.
                 *
                 * **Note:** This method doesn't set the "length" property of curried functions.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category Function
                 * @param {Function} func The function to curry.
                 * @param {number} [arity=func.length] The arity of `func`.
                 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
                 * @returns {Function} Returns the new curried function.
                 * @example
                 *
                 * var abc = function(a, b, c) {
                 *   return [a, b, c];
                 * };
                 *
                 * var curried = _.curryRight(abc);
                 *
                 * curried(3)(2)(1);
                 * // => [1, 2, 3]
                 *
                 * curried(2, 3)(1);
                 * // => [1, 2, 3]
                 *
                 * curried(1, 2, 3);
                 * // => [1, 2, 3]
                 *
                 * // Curried with placeholders.
                 * curried(3)(1, _)(2);
                 * // => [1, 2, 3]
                 */
                function curryRight(func, arity, guard) {
                  arity = guard ? undefined : arity;
                  var result = createWrap(
                    func,
                    WRAP_CURRY_RIGHT_FLAG,
                    undefined,
                    undefined,
                    undefined,
                    undefined,
                    undefined,
                    arity
                  );
                  result.placeholder = curryRight.placeholder;
                  return result;
                }

                /**
                 * Creates a debounced function that delays invoking `func` until after `wait`
                 * milliseconds have elapsed since the last time the debounced function was
                 * invoked. The debounced function comes with a `cancel` method to cancel
                 * delayed `func` invocations and a `flush` method to immediately invoke them.
                 * Provide `options` to indicate whether `func` should be invoked on the
                 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
                 * with the last arguments provided to the debounced function. Subsequent
                 * calls to the debounced function return the result of the last `func`
                 * invocation.
                 *
                 * **Note:** If `leading` and `trailing` options are `true`, `func` is
                 * invoked on the trailing edge of the timeout only if the debounced function
                 * is invoked more than once during the `wait` timeout.
                 *
                 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
                 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
                 *
                 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
                 * for details over the differences between `_.debounce` and `_.throttle`.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Function
                 * @param {Function} func The function to debounce.
                 * @param {number} [wait=0] The number of milliseconds to delay.
                 * @param {Object} [options={}] The options object.
                 * @param {boolean} [options.leading=false]
                 *  Specify invoking on the leading edge of the timeout.
                 * @param {number} [options.maxWait]
                 *  The maximum time `func` is allowed to be delayed before it's invoked.
                 * @param {boolean} [options.trailing=true]
                 *  Specify invoking on the trailing edge of the timeout.
                 * @returns {Function} Returns the new debounced function.
                 * @example
                 *
                 * // Avoid costly calculations while the window size is in flux.
                 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
                 *
                 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
                 * jQuery(element).on('click', _.debounce(sendMail, 300, {
                 *   'leading': true,
                 *   'trailing': false
                 * }));
                 *
                 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
                 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
                 * var source = new EventSource('/stream');
                 * jQuery(source).on('message', debounced);
                 *
                 * // Cancel the trailing debounced invocation.
                 * jQuery(window).on('popstate', debounced.cancel);
                 */
                function debounce(func, wait, options) {
                  var lastArgs,
                    lastThis,
                    maxWait,
                    result,
                    timerId,
                    lastCallTime,
                    lastInvokeTime = 0,
                    leading = false,
                    maxing = false,
                    trailing = true;

                  if (typeof func != "function") {
                    throw new TypeError(FUNC_ERROR_TEXT);
                  }
                  wait = toNumber(wait) || 0;
                  if (isObject(options)) {
                    leading = !!options.leading;
                    maxing = "maxWait" in options;
                    maxWait = maxing
                      ? nativeMax(toNumber(options.maxWait) || 0, wait)
                      : maxWait;
                    trailing =
                      "trailing" in options ? !!options.trailing : trailing;
                  }

                  function invokeFunc(time) {
                    var args = lastArgs,
                      thisArg = lastThis;

                    lastArgs = lastThis = undefined;
                    lastInvokeTime = time;
                    result = func.apply(thisArg, args);
                    return result;
                  }

                  function leadingEdge(time) {
                    // Reset any `maxWait` timer.
                    lastInvokeTime = time;
                    // Start the timer for the trailing edge.
                    timerId = setTimeout(timerExpired, wait);
                    // Invoke the leading edge.
                    return leading ? invokeFunc(time) : result;
                  }

                  function remainingWait(time) {
                    var timeSinceLastCall = time - lastCallTime,
                      timeSinceLastInvoke = time - lastInvokeTime,
                      timeWaiting = wait - timeSinceLastCall;

                    return maxing
                      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
                      : timeWaiting;
                  }

                  function shouldInvoke(time) {
                    var timeSinceLastCall = time - lastCallTime,
                      timeSinceLastInvoke = time - lastInvokeTime;

                    // Either this is the first call, activity has stopped and we're at the
                    // trailing edge, the system time has gone backwards and we're treating
                    // it as the trailing edge, or we've hit the `maxWait` limit.
                    return (
                      lastCallTime === undefined ||
                      timeSinceLastCall >= wait ||
                      timeSinceLastCall < 0 ||
                      (maxing && timeSinceLastInvoke >= maxWait)
                    );
                  }

                  function timerExpired() {
                    var time = now();
                    if (shouldInvoke(time)) {
                      return trailingEdge(time);
                    }
                    // Restart the timer.
                    timerId = setTimeout(timerExpired, remainingWait(time));
                  }

                  function trailingEdge(time) {
                    timerId = undefined;

                    // Only invoke if we have `lastArgs` which means `func` has been
                    // debounced at least once.
                    if (trailing && lastArgs) {
                      return invokeFunc(time);
                    }
                    lastArgs = lastThis = undefined;
                    return result;
                  }

                  function cancel() {
                    if (timerId !== undefined) {
                      clearTimeout(timerId);
                    }
                    lastInvokeTime = 0;
                    lastArgs = lastCallTime = lastThis = timerId = undefined;
                  }

                  function flush() {
                    return timerId === undefined ? result : trailingEdge(now());
                  }

                  function debounced() {
                    var time = now(),
                      isInvoking = shouldInvoke(time);

                    lastArgs = arguments;
                    lastThis = this;
                    lastCallTime = time;

                    if (isInvoking) {
                      if (timerId === undefined) {
                        return leadingEdge(lastCallTime);
                      }
                      if (maxing) {
                        // Handle invocations in a tight loop.
                        clearTimeout(timerId);
                        timerId = setTimeout(timerExpired, wait);
                        return invokeFunc(lastCallTime);
                      }
                    }
                    if (timerId === undefined) {
                      timerId = setTimeout(timerExpired, wait);
                    }
                    return result;
                  }
                  debounced.cancel = cancel;
                  debounced.flush = flush;
                  return debounced;
                }

                /**
                 * Defers invoking the `func` until the current call stack has cleared. Any
                 * additional arguments are provided to `func` when it's invoked.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Function
                 * @param {Function} func The function to defer.
                 * @param {...*} [args] The arguments to invoke `func` with.
                 * @returns {number} Returns the timer id.
                 * @example
                 *
                 * _.defer(function(text) {
                 *   console.log(text);
                 * }, 'deferred');
                 * // => Logs 'deferred' after one millisecond.
                 */
                var defer = baseRest(function (func, args) {
                  return baseDelay(func, 1, args);
                });

                /**
                 * Invokes `func` after `wait` milliseconds. Any additional arguments are
                 * provided to `func` when it's invoked.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Function
                 * @param {Function} func The function to delay.
                 * @param {number} wait The number of milliseconds to delay invocation.
                 * @param {...*} [args] The arguments to invoke `func` with.
                 * @returns {number} Returns the timer id.
                 * @example
                 *
                 * _.delay(function(text) {
                 *   console.log(text);
                 * }, 1000, 'later');
                 * // => Logs 'later' after one second.
                 */
                var delay = baseRest(function (func, wait, args) {
                  return baseDelay(func, toNumber(wait) || 0, args);
                });

                /**
                 * Creates a function that invokes `func` with arguments reversed.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Function
                 * @param {Function} func The function to flip arguments for.
                 * @returns {Function} Returns the new flipped function.
                 * @example
                 *
                 * var flipped = _.flip(function() {
                 *   return _.toArray(arguments);
                 * });
                 *
                 * flipped('a', 'b', 'c', 'd');
                 * // => ['d', 'c', 'b', 'a']
                 */
                function flip(func) {
                  return createWrap(func, WRAP_FLIP_FLAG);
                }

                /**
                 * Creates a function that memoizes the result of `func`. If `resolver` is
                 * provided, it determines the cache key for storing the result based on the
                 * arguments provided to the memoized function. By default, the first argument
                 * provided to the memoized function is used as the map cache key. The `func`
                 * is invoked with the `this` binding of the memoized function.
                 *
                 * **Note:** The cache is exposed as the `cache` property on the memoized
                 * function. Its creation may be customized by replacing the `_.memoize.Cache`
                 * constructor with one whose instances implement the
                 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
                 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Function
                 * @param {Function} func The function to have its output memoized.
                 * @param {Function} [resolver] The function to resolve the cache key.
                 * @returns {Function} Returns the new memoized function.
                 * @example
                 *
                 * var object = { 'a': 1, 'b': 2 };
                 * var other = { 'c': 3, 'd': 4 };
                 *
                 * var values = _.memoize(_.values);
                 * values(object);
                 * // => [1, 2]
                 *
                 * values(other);
                 * // => [3, 4]
                 *
                 * object.a = 2;
                 * values(object);
                 * // => [1, 2]
                 *
                 * // Modify the result cache.
                 * values.cache.set(object, ['a', 'b']);
                 * values(object);
                 * // => ['a', 'b']
                 *
                 * // Replace `_.memoize.Cache`.
                 * _.memoize.Cache = WeakMap;
                 */
                function memoize(func, resolver) {
                  if (
                    typeof func != "function" ||
                    (resolver != null && typeof resolver != "function")
                  ) {
                    throw new TypeError(FUNC_ERROR_TEXT);
                  }
                  var memoized = function () {
                    var args = arguments,
                      key = resolver ? resolver.apply(this, args) : args[0],
                      cache = memoized.cache;

                    if (cache.has(key)) {
                      return cache.get(key);
                    }
                    var result = func.apply(this, args);
                    memoized.cache = cache.set(key, result) || cache;
                    return result;
                  };
                  memoized.cache = new (memoize.Cache || MapCache)();
                  return memoized;
                }

                // Expose `MapCache`.
                memoize.Cache = MapCache;

                /**
                 * Creates a function that negates the result of the predicate `func`. The
                 * `func` predicate is invoked with the `this` binding and arguments of the
                 * created function.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category Function
                 * @param {Function} predicate The predicate to negate.
                 * @returns {Function} Returns the new negated function.
                 * @example
                 *
                 * function isEven(n) {
                 *   return n % 2 == 0;
                 * }
                 *
                 * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
                 * // => [1, 3, 5]
                 */
                function negate(predicate) {
                  if (typeof predicate != "function") {
                    throw new TypeError(FUNC_ERROR_TEXT);
                  }
                  return function () {
                    var args = arguments;
                    switch (args.length) {
                      case 0:
                        return !predicate.call(this);
                      case 1:
                        return !predicate.call(this, args[0]);
                      case 2:
                        return !predicate.call(this, args[0], args[1]);
                      case 3:
                        return !predicate.call(this, args[0], args[1], args[2]);
                    }
                    return !predicate.apply(this, args);
                  };
                }

                /**
                 * Creates a function that is restricted to invoking `func` once. Repeat calls
                 * to the function return the value of the first invocation. The `func` is
                 * invoked with the `this` binding and arguments of the created function.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Function
                 * @param {Function} func The function to restrict.
                 * @returns {Function} Returns the new restricted function.
                 * @example
                 *
                 * var initialize = _.once(createApplication);
                 * initialize();
                 * initialize();
                 * // => `createApplication` is invoked once
                 */
                function once(func) {
                  return before(2, func);
                }

                /**
                 * Creates a function that invokes `func` with its arguments transformed.
                 *
                 * @static
                 * @since 4.0.0
                 * @memberOf _
                 * @category Function
                 * @param {Function} func The function to wrap.
                 * @param {...(Function|Function[])} [transforms=[_.identity]]
                 *  The argument transforms.
                 * @returns {Function} Returns the new function.
                 * @example
                 *
                 * function doubled(n) {
                 *   return n * 2;
                 * }
                 *
                 * function square(n) {
                 *   return n * n;
                 * }
                 *
                 * var func = _.overArgs(function(x, y) {
                 *   return [x, y];
                 * }, [square, doubled]);
                 *
                 * func(9, 3);
                 * // => [81, 6]
                 *
                 * func(10, 5);
                 * // => [100, 10]
                 */
                var overArgs = castRest(function (func, transforms) {
                  transforms =
                    transforms.length == 1 && isArray(transforms[0])
                      ? arrayMap(transforms[0], baseUnary(getIteratee()))
                      : arrayMap(
                          baseFlatten(transforms, 1),
                          baseUnary(getIteratee())
                        );

                  var funcsLength = transforms.length;
                  return baseRest(function (args) {
                    var index = -1,
                      length = nativeMin(args.length, funcsLength);

                    while (++index < length) {
                      args[index] = transforms[index].call(this, args[index]);
                    }
                    return apply(func, this, args);
                  });
                });

                /**
                 * Creates a function that invokes `func` with `partials` prepended to the
                 * arguments it receives. This method is like `_.bind` except it does **not**
                 * alter the `this` binding.
                 *
                 * The `_.partial.placeholder` value, which defaults to `_` in monolithic
                 * builds, may be used as a placeholder for partially applied arguments.
                 *
                 * **Note:** This method doesn't set the "length" property of partially
                 * applied functions.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.2.0
                 * @category Function
                 * @param {Function} func The function to partially apply arguments to.
                 * @param {...*} [partials] The arguments to be partially applied.
                 * @returns {Function} Returns the new partially applied function.
                 * @example
                 *
                 * function greet(greeting, name) {
                 *   return greeting + ' ' + name;
                 * }
                 *
                 * var sayHelloTo = _.partial(greet, 'hello');
                 * sayHelloTo('fred');
                 * // => 'hello fred'
                 *
                 * // Partially applied with placeholders.
                 * var greetFred = _.partial(greet, _, 'fred');
                 * greetFred('hi');
                 * // => 'hi fred'
                 */
                var partial = baseRest(function (func, partials) {
                  var holders = replaceHolders(partials, getHolder(partial));
                  return createWrap(
                    func,
                    WRAP_PARTIAL_FLAG,
                    undefined,
                    partials,
                    holders
                  );
                });

                /**
                 * This method is like `_.partial` except that partially applied arguments
                 * are appended to the arguments it receives.
                 *
                 * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
                 * builds, may be used as a placeholder for partially applied arguments.
                 *
                 * **Note:** This method doesn't set the "length" property of partially
                 * applied functions.
                 *
                 * @static
                 * @memberOf _
                 * @since 1.0.0
                 * @category Function
                 * @param {Function} func The function to partially apply arguments to.
                 * @param {...*} [partials] The arguments to be partially applied.
                 * @returns {Function} Returns the new partially applied function.
                 * @example
                 *
                 * function greet(greeting, name) {
                 *   return greeting + ' ' + name;
                 * }
                 *
                 * var greetFred = _.partialRight(greet, 'fred');
                 * greetFred('hi');
                 * // => 'hi fred'
                 *
                 * // Partially applied with placeholders.
                 * var sayHelloTo = _.partialRight(greet, 'hello', _);
                 * sayHelloTo('fred');
                 * // => 'hello fred'
                 */
                var partialRight = baseRest(function (func, partials) {
                  var holders = replaceHolders(
                    partials,
                    getHolder(partialRight)
                  );
                  return createWrap(
                    func,
                    WRAP_PARTIAL_RIGHT_FLAG,
                    undefined,
                    partials,
                    holders
                  );
                });

                /**
                 * Creates a function that invokes `func` with arguments arranged according
                 * to the specified `indexes` where the argument value at the first index is
                 * provided as the first argument, the argument value at the second index is
                 * provided as the second argument, and so on.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category Function
                 * @param {Function} func The function to rearrange arguments for.
                 * @param {...(number|number[])} indexes The arranged argument indexes.
                 * @returns {Function} Returns the new function.
                 * @example
                 *
                 * var rearged = _.rearg(function(a, b, c) {
                 *   return [a, b, c];
                 * }, [2, 0, 1]);
                 *
                 * rearged('b', 'c', 'a')
                 * // => ['a', 'b', 'c']
                 */
                var rearg = flatRest(function (func, indexes) {
                  return createWrap(
                    func,
                    WRAP_REARG_FLAG,
                    undefined,
                    undefined,
                    undefined,
                    indexes
                  );
                });

                /**
                 * Creates a function that invokes `func` with the `this` binding of the
                 * created function and arguments from `start` and beyond provided as
                 * an array.
                 *
                 * **Note:** This method is based on the
                 * [rest parameter](https://mdn.io/rest_parameters).
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Function
                 * @param {Function} func The function to apply a rest parameter to.
                 * @param {number} [start=func.length-1] The start position of the rest parameter.
                 * @returns {Function} Returns the new function.
                 * @example
                 *
                 * var say = _.rest(function(what, names) {
                 *   return what + ' ' + _.initial(names).join(', ') +
                 *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
                 * });
                 *
                 * say('hello', 'fred', 'barney', 'pebbles');
                 * // => 'hello fred, barney, & pebbles'
                 */
                function rest(func, start) {
                  if (typeof func != "function") {
                    throw new TypeError(FUNC_ERROR_TEXT);
                  }
                  start = start === undefined ? start : toInteger(start);
                  return baseRest(func, start);
                }

                /**
                 * Creates a function that invokes `func` with the `this` binding of the
                 * create function and an array of arguments much like
                 * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
                 *
                 * **Note:** This method is based on the
                 * [spread operator](https://mdn.io/spread_operator).
                 *
                 * @static
                 * @memberOf _
                 * @since 3.2.0
                 * @category Function
                 * @param {Function} func The function to spread arguments over.
                 * @param {number} [start=0] The start position of the spread.
                 * @returns {Function} Returns the new function.
                 * @example
                 *
                 * var say = _.spread(function(who, what) {
                 *   return who + ' says ' + what;
                 * });
                 *
                 * say(['fred', 'hello']);
                 * // => 'fred says hello'
                 *
                 * var numbers = Promise.all([
                 *   Promise.resolve(40),
                 *   Promise.resolve(36)
                 * ]);
                 *
                 * numbers.then(_.spread(function(x, y) {
                 *   return x + y;
                 * }));
                 * // => a Promise of 76
                 */
                function spread(func, start) {
                  if (typeof func != "function") {
                    throw new TypeError(FUNC_ERROR_TEXT);
                  }
                  start = start == null ? 0 : nativeMax(toInteger(start), 0);
                  return baseRest(function (args) {
                    var array = args[start],
                      otherArgs = castSlice(args, 0, start);

                    if (array) {
                      arrayPush(otherArgs, array);
                    }
                    return apply(func, this, otherArgs);
                  });
                }

                /**
                 * Creates a throttled function that only invokes `func` at most once per
                 * every `wait` milliseconds. The throttled function comes with a `cancel`
                 * method to cancel delayed `func` invocations and a `flush` method to
                 * immediately invoke them. Provide `options` to indicate whether `func`
                 * should be invoked on the leading and/or trailing edge of the `wait`
                 * timeout. The `func` is invoked with the last arguments provided to the
                 * throttled function. Subsequent calls to the throttled function return the
                 * result of the last `func` invocation.
                 *
                 * **Note:** If `leading` and `trailing` options are `true`, `func` is
                 * invoked on the trailing edge of the timeout only if the throttled function
                 * is invoked more than once during the `wait` timeout.
                 *
                 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
                 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
                 *
                 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
                 * for details over the differences between `_.throttle` and `_.debounce`.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Function
                 * @param {Function} func The function to throttle.
                 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
                 * @param {Object} [options={}] The options object.
                 * @param {boolean} [options.leading=true]
                 *  Specify invoking on the leading edge of the timeout.
                 * @param {boolean} [options.trailing=true]
                 *  Specify invoking on the trailing edge of the timeout.
                 * @returns {Function} Returns the new throttled function.
                 * @example
                 *
                 * // Avoid excessively updating the position while scrolling.
                 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
                 *
                 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
                 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
                 * jQuery(element).on('click', throttled);
                 *
                 * // Cancel the trailing throttled invocation.
                 * jQuery(window).on('popstate', throttled.cancel);
                 */
                function throttle(func, wait, options) {
                  var leading = true,
                    trailing = true;

                  if (typeof func != "function") {
                    throw new TypeError(FUNC_ERROR_TEXT);
                  }
                  if (isObject(options)) {
                    leading =
                      "leading" in options ? !!options.leading : leading;
                    trailing =
                      "trailing" in options ? !!options.trailing : trailing;
                  }
                  return debounce(func, wait, {
                    leading: leading,
                    maxWait: wait,
                    trailing: trailing,
                  });
                }

                /**
                 * Creates a function that accepts up to one argument, ignoring any
                 * additional arguments.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Function
                 * @param {Function} func The function to cap arguments for.
                 * @returns {Function} Returns the new capped function.
                 * @example
                 *
                 * _.map(['6', '8', '10'], _.unary(parseInt));
                 * // => [6, 8, 10]
                 */
                function unary(func) {
                  return ary(func, 1);
                }

                /**
                 * Creates a function that provides `value` to `wrapper` as its first
                 * argument. Any additional arguments provided to the function are appended
                 * to those provided to the `wrapper`. The wrapper is invoked with the `this`
                 * binding of the created function.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Function
                 * @param {*} value The value to wrap.
                 * @param {Function} [wrapper=identity] The wrapper function.
                 * @returns {Function} Returns the new function.
                 * @example
                 *
                 * var p = _.wrap(_.escape, function(func, text) {
                 *   return '<p>' + func(text) + '</p>';
                 * });
                 *
                 * p('fred, barney, & pebbles');
                 * // => '<p>fred, barney, &amp; pebbles</p>'
                 */
                function wrap(value, wrapper) {
                  return partial(castFunction(wrapper), value);
                }

                /*------------------------------------------------------------------------*/

                /**
                 * Casts `value` as an array if it's not one.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.4.0
                 * @category Lang
                 * @param {*} value The value to inspect.
                 * @returns {Array} Returns the cast array.
                 * @example
                 *
                 * _.castArray(1);
                 * // => [1]
                 *
                 * _.castArray({ 'a': 1 });
                 * // => [{ 'a': 1 }]
                 *
                 * _.castArray('abc');
                 * // => ['abc']
                 *
                 * _.castArray(null);
                 * // => [null]
                 *
                 * _.castArray(undefined);
                 * // => [undefined]
                 *
                 * _.castArray();
                 * // => []
                 *
                 * var array = [1, 2, 3];
                 * console.log(_.castArray(array) === array);
                 * // => true
                 */
                function castArray() {
                  if (!arguments.length) {
                    return [];
                  }
                  var value = arguments[0];
                  return isArray(value) ? value : [value];
                }

                /**
                 * Creates a shallow clone of `value`.
                 *
                 * **Note:** This method is loosely based on the
                 * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
                 * and supports cloning arrays, array buffers, booleans, date objects, maps,
                 * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
                 * arrays. The own enumerable properties of `arguments` objects are cloned
                 * as plain objects. An empty object is returned for uncloneable values such
                 * as error objects, functions, DOM nodes, and WeakMaps.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Lang
                 * @param {*} value The value to clone.
                 * @returns {*} Returns the cloned value.
                 * @see _.cloneDeep
                 * @example
                 *
                 * var objects = [{ 'a': 1 }, { 'b': 2 }];
                 *
                 * var shallow = _.clone(objects);
                 * console.log(shallow[0] === objects[0]);
                 * // => true
                 */
                function clone(value) {
                  return baseClone(value, CLONE_SYMBOLS_FLAG);
                }

                /**
                 * This method is like `_.clone` except that it accepts `customizer` which
                 * is invoked to produce the cloned value. If `customizer` returns `undefined`,
                 * cloning is handled by the method instead. The `customizer` is invoked with
                 * up to four arguments; (value [, index|key, object, stack]).
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Lang
                 * @param {*} value The value to clone.
                 * @param {Function} [customizer] The function to customize cloning.
                 * @returns {*} Returns the cloned value.
                 * @see _.cloneDeepWith
                 * @example
                 *
                 * function customizer(value) {
                 *   if (_.isElement(value)) {
                 *     return value.cloneNode(false);
                 *   }
                 * }
                 *
                 * var el = _.cloneWith(document.body, customizer);
                 *
                 * console.log(el === document.body);
                 * // => false
                 * console.log(el.nodeName);
                 * // => 'BODY'
                 * console.log(el.childNodes.length);
                 * // => 0
                 */
                function cloneWith(value, customizer) {
                  customizer =
                    typeof customizer == "function" ? customizer : undefined;
                  return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
                }

                /**
                 * This method is like `_.clone` except that it recursively clones `value`.
                 *
                 * @static
                 * @memberOf _
                 * @since 1.0.0
                 * @category Lang
                 * @param {*} value The value to recursively clone.
                 * @returns {*} Returns the deep cloned value.
                 * @see _.clone
                 * @example
                 *
                 * var objects = [{ 'a': 1 }, { 'b': 2 }];
                 *
                 * var deep = _.cloneDeep(objects);
                 * console.log(deep[0] === objects[0]);
                 * // => false
                 */
                function cloneDeep(value) {
                  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
                }

                /**
                 * This method is like `_.cloneWith` except that it recursively clones `value`.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Lang
                 * @param {*} value The value to recursively clone.
                 * @param {Function} [customizer] The function to customize cloning.
                 * @returns {*} Returns the deep cloned value.
                 * @see _.cloneWith
                 * @example
                 *
                 * function customizer(value) {
                 *   if (_.isElement(value)) {
                 *     return value.cloneNode(true);
                 *   }
                 * }
                 *
                 * var el = _.cloneDeepWith(document.body, customizer);
                 *
                 * console.log(el === document.body);
                 * // => false
                 * console.log(el.nodeName);
                 * // => 'BODY'
                 * console.log(el.childNodes.length);
                 * // => 20
                 */
                function cloneDeepWith(value, customizer) {
                  customizer =
                    typeof customizer == "function" ? customizer : undefined;
                  return baseClone(
                    value,
                    CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG,
                    customizer
                  );
                }

                /**
                 * Checks if `object` conforms to `source` by invoking the predicate
                 * properties of `source` with the corresponding property values of `object`.
                 *
                 * **Note:** This method is equivalent to `_.conforms` when `source` is
                 * partially applied.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.14.0
                 * @category Lang
                 * @param {Object} object The object to inspect.
                 * @param {Object} source The object of property predicates to conform to.
                 * @returns {boolean} Returns `true` if `object` conforms, else `false`.
                 * @example
                 *
                 * var object = { 'a': 1, 'b': 2 };
                 *
                 * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
                 * // => true
                 *
                 * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
                 * // => false
                 */
                function conformsTo(object, source) {
                  return (
                    source == null ||
                    baseConformsTo(object, source, keys(source))
                  );
                }

                /**
                 * Performs a
                 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
                 * comparison between two values to determine if they are equivalent.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Lang
                 * @param {*} value The value to compare.
                 * @param {*} other The other value to compare.
                 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
                 * @example
                 *
                 * var object = { 'a': 1 };
                 * var other = { 'a': 1 };
                 *
                 * _.eq(object, object);
                 * // => true
                 *
                 * _.eq(object, other);
                 * // => false
                 *
                 * _.eq('a', 'a');
                 * // => true
                 *
                 * _.eq('a', Object('a'));
                 * // => false
                 *
                 * _.eq(NaN, NaN);
                 * // => true
                 */
                function eq(value, other) {
                  return (
                    value === other || (value !== value && other !== other)
                  );
                }

                /**
                 * Checks if `value` is greater than `other`.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.9.0
                 * @category Lang
                 * @param {*} value The value to compare.
                 * @param {*} other The other value to compare.
                 * @returns {boolean} Returns `true` if `value` is greater than `other`,
                 *  else `false`.
                 * @see _.lt
                 * @example
                 *
                 * _.gt(3, 1);
                 * // => true
                 *
                 * _.gt(3, 3);
                 * // => false
                 *
                 * _.gt(1, 3);
                 * // => false
                 */
                var gt = createRelationalOperation(baseGt);

                /**
                 * Checks if `value` is greater than or equal to `other`.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.9.0
                 * @category Lang
                 * @param {*} value The value to compare.
                 * @param {*} other The other value to compare.
                 * @returns {boolean} Returns `true` if `value` is greater than or equal to
                 *  `other`, else `false`.
                 * @see _.lte
                 * @example
                 *
                 * _.gte(3, 1);
                 * // => true
                 *
                 * _.gte(3, 3);
                 * // => true
                 *
                 * _.gte(1, 3);
                 * // => false
                 */
                var gte = createRelationalOperation(function (value, other) {
                  return value >= other;
                });

                /**
                 * Checks if `value` is likely an `arguments` object.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
                 *  else `false`.
                 * @example
                 *
                 * _.isArguments(function() { return arguments; }());
                 * // => true
                 *
                 * _.isArguments([1, 2, 3]);
                 * // => false
                 */
                var isArguments = baseIsArguments(
                  (function () {
                    return arguments;
                  })()
                )
                  ? baseIsArguments
                  : function (value) {
                      return (
                        isObjectLike(value) &&
                        hasOwnProperty.call(value, "callee") &&
                        !propertyIsEnumerable.call(value, "callee")
                      );
                    };

                /**
                 * Checks if `value` is classified as an `Array` object.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
                 * @example
                 *
                 * _.isArray([1, 2, 3]);
                 * // => true
                 *
                 * _.isArray(document.body.children);
                 * // => false
                 *
                 * _.isArray('abc');
                 * // => false
                 *
                 * _.isArray(_.noop);
                 * // => false
                 */
                var isArray = Array.isArray;

                /**
                 * Checks if `value` is classified as an `ArrayBuffer` object.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.3.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
                 * @example
                 *
                 * _.isArrayBuffer(new ArrayBuffer(2));
                 * // => true
                 *
                 * _.isArrayBuffer(new Array(2));
                 * // => false
                 */
                var isArrayBuffer = nodeIsArrayBuffer
                  ? baseUnary(nodeIsArrayBuffer)
                  : baseIsArrayBuffer;

                /**
                 * Checks if `value` is array-like. A value is considered array-like if it's
                 * not a function and has a `value.length` that's an integer greater than or
                 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
                 * @example
                 *
                 * _.isArrayLike([1, 2, 3]);
                 * // => true
                 *
                 * _.isArrayLike(document.body.children);
                 * // => true
                 *
                 * _.isArrayLike('abc');
                 * // => true
                 *
                 * _.isArrayLike(_.noop);
                 * // => false
                 */
                function isArrayLike(value) {
                  return (
                    value != null &&
                    isLength(value.length) &&
                    !isFunction(value)
                  );
                }

                /**
                 * This method is like `_.isArrayLike` except that it also checks if `value`
                 * is an object.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is an array-like object,
                 *  else `false`.
                 * @example
                 *
                 * _.isArrayLikeObject([1, 2, 3]);
                 * // => true
                 *
                 * _.isArrayLikeObject(document.body.children);
                 * // => true
                 *
                 * _.isArrayLikeObject('abc');
                 * // => false
                 *
                 * _.isArrayLikeObject(_.noop);
                 * // => false
                 */
                function isArrayLikeObject(value) {
                  return isObjectLike(value) && isArrayLike(value);
                }

                /**
                 * Checks if `value` is classified as a boolean primitive or object.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
                 * @example
                 *
                 * _.isBoolean(false);
                 * // => true
                 *
                 * _.isBoolean(null);
                 * // => false
                 */
                function isBoolean(value) {
                  return (
                    value === true ||
                    value === false ||
                    (isObjectLike(value) && baseGetTag(value) == boolTag)
                  );
                }

                /**
                 * Checks if `value` is a buffer.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.3.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
                 * @example
                 *
                 * _.isBuffer(new Buffer(2));
                 * // => true
                 *
                 * _.isBuffer(new Uint8Array(2));
                 * // => false
                 */
                var isBuffer = nativeIsBuffer || stubFalse;

                /**
                 * Checks if `value` is classified as a `Date` object.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
                 * @example
                 *
                 * _.isDate(new Date);
                 * // => true
                 *
                 * _.isDate('Mon April 23 2012');
                 * // => false
                 */
                var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;

                /**
                 * Checks if `value` is likely a DOM element.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
                 * @example
                 *
                 * _.isElement(document.body);
                 * // => true
                 *
                 * _.isElement('<body>');
                 * // => false
                 */
                function isElement(value) {
                  return (
                    isObjectLike(value) &&
                    value.nodeType === 1 &&
                    !isPlainObject(value)
                  );
                }

                /**
                 * Checks if `value` is an empty object, collection, map, or set.
                 *
                 * Objects are considered empty if they have no own enumerable string keyed
                 * properties.
                 *
                 * Array-like values such as `arguments` objects, arrays, buffers, strings, or
                 * jQuery-like collections are considered empty if they have a `length` of `0`.
                 * Similarly, maps and sets are considered empty if they have a `size` of `0`.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is empty, else `false`.
                 * @example
                 *
                 * _.isEmpty(null);
                 * // => true
                 *
                 * _.isEmpty(true);
                 * // => true
                 *
                 * _.isEmpty(1);
                 * // => true
                 *
                 * _.isEmpty([1, 2, 3]);
                 * // => false
                 *
                 * _.isEmpty({ 'a': 1 });
                 * // => false
                 */
                function isEmpty(value) {
                  if (value == null) {
                    return true;
                  }
                  if (
                    isArrayLike(value) &&
                    (isArray(value) ||
                      typeof value == "string" ||
                      typeof value.splice == "function" ||
                      isBuffer(value) ||
                      isTypedArray(value) ||
                      isArguments(value))
                  ) {
                    return !value.length;
                  }
                  var tag = getTag(value);
                  if (tag == mapTag || tag == setTag) {
                    return !value.size;
                  }
                  if (isPrototype(value)) {
                    return !baseKeys(value).length;
                  }
                  for (var key in value) {
                    if (hasOwnProperty.call(value, key)) {
                      return false;
                    }
                  }
                  return true;
                }

                /**
                 * Performs a deep comparison between two values to determine if they are
                 * equivalent.
                 *
                 * **Note:** This method supports comparing arrays, array buffers, booleans,
                 * date objects, error objects, maps, numbers, `Object` objects, regexes,
                 * sets, strings, symbols, and typed arrays. `Object` objects are compared
                 * by their own, not inherited, enumerable properties. Functions and DOM
                 * nodes are compared by strict equality, i.e. `===`.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Lang
                 * @param {*} value The value to compare.
                 * @param {*} other The other value to compare.
                 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
                 * @example
                 *
                 * var object = { 'a': 1 };
                 * var other = { 'a': 1 };
                 *
                 * _.isEqual(object, other);
                 * // => true
                 *
                 * object === other;
                 * // => false
                 */
                function isEqual(value, other) {
                  return baseIsEqual(value, other);
                }

                /**
                 * This method is like `_.isEqual` except that it accepts `customizer` which
                 * is invoked to compare values. If `customizer` returns `undefined`, comparisons
                 * are handled by the method instead. The `customizer` is invoked with up to
                 * six arguments: (objValue, othValue [, index|key, object, other, stack]).
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Lang
                 * @param {*} value The value to compare.
                 * @param {*} other The other value to compare.
                 * @param {Function} [customizer] The function to customize comparisons.
                 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
                 * @example
                 *
                 * function isGreeting(value) {
                 *   return /^h(?:i|ello)$/.test(value);
                 * }
                 *
                 * function customizer(objValue, othValue) {
                 *   if (isGreeting(objValue) && isGreeting(othValue)) {
                 *     return true;
                 *   }
                 * }
                 *
                 * var array = ['hello', 'goodbye'];
                 * var other = ['hi', 'goodbye'];
                 *
                 * _.isEqualWith(array, other, customizer);
                 * // => true
                 */
                function isEqualWith(value, other, customizer) {
                  customizer =
                    typeof customizer == "function" ? customizer : undefined;
                  var result = customizer
                    ? customizer(value, other)
                    : undefined;
                  return result === undefined
                    ? baseIsEqual(value, other, undefined, customizer)
                    : !!result;
                }

                /**
                 * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
                 * `SyntaxError`, `TypeError`, or `URIError` object.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
                 * @example
                 *
                 * _.isError(new Error);
                 * // => true
                 *
                 * _.isError(Error);
                 * // => false
                 */
                function isError(value) {
                  if (!isObjectLike(value)) {
                    return false;
                  }
                  var tag = baseGetTag(value);
                  return (
                    tag == errorTag ||
                    tag == domExcTag ||
                    (typeof value.message == "string" &&
                      typeof value.name == "string" &&
                      !isPlainObject(value))
                  );
                }

                /**
                 * Checks if `value` is a finite primitive number.
                 *
                 * **Note:** This method is based on
                 * [`Number.isFinite`](https://mdn.io/Number/isFinite).
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
                 * @example
                 *
                 * _.isFinite(3);
                 * // => true
                 *
                 * _.isFinite(Number.MIN_VALUE);
                 * // => true
                 *
                 * _.isFinite(Infinity);
                 * // => false
                 *
                 * _.isFinite('3');
                 * // => false
                 */
                function isFinite(value) {
                  return typeof value == "number" && nativeIsFinite(value);
                }

                /**
                 * Checks if `value` is classified as a `Function` object.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
                 * @example
                 *
                 * _.isFunction(_);
                 * // => true
                 *
                 * _.isFunction(/abc/);
                 * // => false
                 */
                function isFunction(value) {
                  if (!isObject(value)) {
                    return false;
                  }
                  // The use of `Object#toString` avoids issues with the `typeof` operator
                  // in Safari 9 which returns 'object' for typed arrays and other constructors.
                  var tag = baseGetTag(value);
                  return (
                    tag == funcTag ||
                    tag == genTag ||
                    tag == asyncTag ||
                    tag == proxyTag
                  );
                }

                /**
                 * Checks if `value` is an integer.
                 *
                 * **Note:** This method is based on
                 * [`Number.isInteger`](https://mdn.io/Number/isInteger).
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
                 * @example
                 *
                 * _.isInteger(3);
                 * // => true
                 *
                 * _.isInteger(Number.MIN_VALUE);
                 * // => false
                 *
                 * _.isInteger(Infinity);
                 * // => false
                 *
                 * _.isInteger('3');
                 * // => false
                 */
                function isInteger(value) {
                  return typeof value == "number" && value == toInteger(value);
                }

                /**
                 * Checks if `value` is a valid array-like length.
                 *
                 * **Note:** This method is loosely based on
                 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
                 * @example
                 *
                 * _.isLength(3);
                 * // => true
                 *
                 * _.isLength(Number.MIN_VALUE);
                 * // => false
                 *
                 * _.isLength(Infinity);
                 * // => false
                 *
                 * _.isLength('3');
                 * // => false
                 */
                function isLength(value) {
                  return (
                    typeof value == "number" &&
                    value > -1 &&
                    value % 1 == 0 &&
                    value <= MAX_SAFE_INTEGER
                  );
                }

                /**
                 * Checks if `value` is the
                 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
                 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
                 * @example
                 *
                 * _.isObject({});
                 * // => true
                 *
                 * _.isObject([1, 2, 3]);
                 * // => true
                 *
                 * _.isObject(_.noop);
                 * // => true
                 *
                 * _.isObject(null);
                 * // => false
                 */
                function isObject(value) {
                  var type = typeof value;
                  return (
                    value != null && (type == "object" || type == "function")
                  );
                }

                /**
                 * Checks if `value` is object-like. A value is object-like if it's not `null`
                 * and has a `typeof` result of "object".
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
                 * @example
                 *
                 * _.isObjectLike({});
                 * // => true
                 *
                 * _.isObjectLike([1, 2, 3]);
                 * // => true
                 *
                 * _.isObjectLike(_.noop);
                 * // => false
                 *
                 * _.isObjectLike(null);
                 * // => false
                 */
                function isObjectLike(value) {
                  return value != null && typeof value == "object";
                }

                /**
                 * Checks if `value` is classified as a `Map` object.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.3.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
                 * @example
                 *
                 * _.isMap(new Map);
                 * // => true
                 *
                 * _.isMap(new WeakMap);
                 * // => false
                 */
                var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

                /**
                 * Performs a partial deep comparison between `object` and `source` to
                 * determine if `object` contains equivalent property values.
                 *
                 * **Note:** This method is equivalent to `_.matches` when `source` is
                 * partially applied.
                 *
                 * Partial comparisons will match empty array and empty object `source`
                 * values against any array or object value, respectively. See `_.isEqual`
                 * for a list of supported value comparisons.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category Lang
                 * @param {Object} object The object to inspect.
                 * @param {Object} source The object of property values to match.
                 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
                 * @example
                 *
                 * var object = { 'a': 1, 'b': 2 };
                 *
                 * _.isMatch(object, { 'b': 2 });
                 * // => true
                 *
                 * _.isMatch(object, { 'b': 1 });
                 * // => false
                 */
                function isMatch(object, source) {
                  return (
                    object === source ||
                    baseIsMatch(object, source, getMatchData(source))
                  );
                }

                /**
                 * This method is like `_.isMatch` except that it accepts `customizer` which
                 * is invoked to compare values. If `customizer` returns `undefined`, comparisons
                 * are handled by the method instead. The `customizer` is invoked with five
                 * arguments: (objValue, srcValue, index|key, object, source).
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Lang
                 * @param {Object} object The object to inspect.
                 * @param {Object} source The object of property values to match.
                 * @param {Function} [customizer] The function to customize comparisons.
                 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
                 * @example
                 *
                 * function isGreeting(value) {
                 *   return /^h(?:i|ello)$/.test(value);
                 * }
                 *
                 * function customizer(objValue, srcValue) {
                 *   if (isGreeting(objValue) && isGreeting(srcValue)) {
                 *     return true;
                 *   }
                 * }
                 *
                 * var object = { 'greeting': 'hello' };
                 * var source = { 'greeting': 'hi' };
                 *
                 * _.isMatchWith(object, source, customizer);
                 * // => true
                 */
                function isMatchWith(object, source, customizer) {
                  customizer =
                    typeof customizer == "function" ? customizer : undefined;
                  return baseIsMatch(
                    object,
                    source,
                    getMatchData(source),
                    customizer
                  );
                }

                /**
                 * Checks if `value` is `NaN`.
                 *
                 * **Note:** This method is based on
                 * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
                 * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
                 * `undefined` and other non-number values.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
                 * @example
                 *
                 * _.isNaN(NaN);
                 * // => true
                 *
                 * _.isNaN(new Number(NaN));
                 * // => true
                 *
                 * isNaN(undefined);
                 * // => true
                 *
                 * _.isNaN(undefined);
                 * // => false
                 */
                function isNaN(value) {
                  // An `NaN` primitive is the only value that is not equal to itself.
                  // Perform the `toStringTag` check first to avoid errors with some
                  // ActiveX objects in IE.
                  return isNumber(value) && value != +value;
                }

                /**
                 * Checks if `value` is a pristine native function.
                 *
                 * **Note:** This method can't reliably detect native functions in the presence
                 * of the core-js package because core-js circumvents this kind of detection.
                 * Despite multiple requests, the core-js maintainer has made it clear: any
                 * attempt to fix the detection will be obstructed. As a result, we're left
                 * with little choice but to throw an error. Unfortunately, this also affects
                 * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
                 * which rely on core-js.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is a native function,
                 *  else `false`.
                 * @example
                 *
                 * _.isNative(Array.prototype.push);
                 * // => true
                 *
                 * _.isNative(_);
                 * // => false
                 */
                function isNative(value) {
                  if (isMaskable(value)) {
                    throw new Error(CORE_ERROR_TEXT);
                  }
                  return baseIsNative(value);
                }

                /**
                 * Checks if `value` is `null`.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
                 * @example
                 *
                 * _.isNull(null);
                 * // => true
                 *
                 * _.isNull(void 0);
                 * // => false
                 */
                function isNull(value) {
                  return value === null;
                }

                /**
                 * Checks if `value` is `null` or `undefined`.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
                 * @example
                 *
                 * _.isNil(null);
                 * // => true
                 *
                 * _.isNil(void 0);
                 * // => true
                 *
                 * _.isNil(NaN);
                 * // => false
                 */
                function isNil(value) {
                  return value == null;
                }

                /**
                 * Checks if `value` is classified as a `Number` primitive or object.
                 *
                 * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
                 * classified as numbers, use the `_.isFinite` method.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is a number, else `false`.
                 * @example
                 *
                 * _.isNumber(3);
                 * // => true
                 *
                 * _.isNumber(Number.MIN_VALUE);
                 * // => true
                 *
                 * _.isNumber(Infinity);
                 * // => true
                 *
                 * _.isNumber('3');
                 * // => false
                 */
                function isNumber(value) {
                  return (
                    typeof value == "number" ||
                    (isObjectLike(value) && baseGetTag(value) == numberTag)
                  );
                }

                /**
                 * Checks if `value` is a plain object, that is, an object created by the
                 * `Object` constructor or one with a `[[Prototype]]` of `null`.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.8.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
                 * @example
                 *
                 * function Foo() {
                 *   this.a = 1;
                 * }
                 *
                 * _.isPlainObject(new Foo);
                 * // => false
                 *
                 * _.isPlainObject([1, 2, 3]);
                 * // => false
                 *
                 * _.isPlainObject({ 'x': 0, 'y': 0 });
                 * // => true
                 *
                 * _.isPlainObject(Object.create(null));
                 * // => true
                 */
                function isPlainObject(value) {
                  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
                    return false;
                  }
                  var proto = getPrototype(value);
                  if (proto === null) {
                    return true;
                  }
                  var Ctor =
                    hasOwnProperty.call(proto, "constructor") &&
                    proto.constructor;
                  return (
                    typeof Ctor == "function" &&
                    Ctor instanceof Ctor &&
                    funcToString.call(Ctor) == objectCtorString
                  );
                }

                /**
                 * Checks if `value` is classified as a `RegExp` object.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
                 * @example
                 *
                 * _.isRegExp(/abc/);
                 * // => true
                 *
                 * _.isRegExp('/abc/');
                 * // => false
                 */
                var isRegExp = nodeIsRegExp
                  ? baseUnary(nodeIsRegExp)
                  : baseIsRegExp;

                /**
                 * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
                 * double precision number which isn't the result of a rounded unsafe integer.
                 *
                 * **Note:** This method is based on
                 * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
                 * @example
                 *
                 * _.isSafeInteger(3);
                 * // => true
                 *
                 * _.isSafeInteger(Number.MIN_VALUE);
                 * // => false
                 *
                 * _.isSafeInteger(Infinity);
                 * // => false
                 *
                 * _.isSafeInteger('3');
                 * // => false
                 */
                function isSafeInteger(value) {
                  return (
                    isInteger(value) &&
                    value >= -MAX_SAFE_INTEGER &&
                    value <= MAX_SAFE_INTEGER
                  );
                }

                /**
                 * Checks if `value` is classified as a `Set` object.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.3.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
                 * @example
                 *
                 * _.isSet(new Set);
                 * // => true
                 *
                 * _.isSet(new WeakSet);
                 * // => false
                 */
                var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

                /**
                 * Checks if `value` is classified as a `String` primitive or object.
                 *
                 * @static
                 * @since 0.1.0
                 * @memberOf _
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is a string, else `false`.
                 * @example
                 *
                 * _.isString('abc');
                 * // => true
                 *
                 * _.isString(1);
                 * // => false
                 */
                function isString(value) {
                  return (
                    typeof value == "string" ||
                    (!isArray(value) &&
                      isObjectLike(value) &&
                      baseGetTag(value) == stringTag)
                  );
                }

                /**
                 * Checks if `value` is classified as a `Symbol` primitive or object.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
                 * @example
                 *
                 * _.isSymbol(Symbol.iterator);
                 * // => true
                 *
                 * _.isSymbol('abc');
                 * // => false
                 */
                function isSymbol(value) {
                  return (
                    typeof value == "symbol" ||
                    (isObjectLike(value) && baseGetTag(value) == symbolTag)
                  );
                }

                /**
                 * Checks if `value` is classified as a typed array.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
                 * @example
                 *
                 * _.isTypedArray(new Uint8Array);
                 * // => true
                 *
                 * _.isTypedArray([]);
                 * // => false
                 */
                var isTypedArray = nodeIsTypedArray
                  ? baseUnary(nodeIsTypedArray)
                  : baseIsTypedArray;

                /**
                 * Checks if `value` is `undefined`.
                 *
                 * @static
                 * @since 0.1.0
                 * @memberOf _
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
                 * @example
                 *
                 * _.isUndefined(void 0);
                 * // => true
                 *
                 * _.isUndefined(null);
                 * // => false
                 */
                function isUndefined(value) {
                  return value === undefined;
                }

                /**
                 * Checks if `value` is classified as a `WeakMap` object.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.3.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
                 * @example
                 *
                 * _.isWeakMap(new WeakMap);
                 * // => true
                 *
                 * _.isWeakMap(new Map);
                 * // => false
                 */
                function isWeakMap(value) {
                  return isObjectLike(value) && getTag(value) == weakMapTag;
                }

                /**
                 * Checks if `value` is classified as a `WeakSet` object.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.3.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
                 * @example
                 *
                 * _.isWeakSet(new WeakSet);
                 * // => true
                 *
                 * _.isWeakSet(new Set);
                 * // => false
                 */
                function isWeakSet(value) {
                  return isObjectLike(value) && baseGetTag(value) == weakSetTag;
                }

                /**
                 * Checks if `value` is less than `other`.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.9.0
                 * @category Lang
                 * @param {*} value The value to compare.
                 * @param {*} other The other value to compare.
                 * @returns {boolean} Returns `true` if `value` is less than `other`,
                 *  else `false`.
                 * @see _.gt
                 * @example
                 *
                 * _.lt(1, 3);
                 * // => true
                 *
                 * _.lt(3, 3);
                 * // => false
                 *
                 * _.lt(3, 1);
                 * // => false
                 */
                var lt = createRelationalOperation(baseLt);

                /**
                 * Checks if `value` is less than or equal to `other`.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.9.0
                 * @category Lang
                 * @param {*} value The value to compare.
                 * @param {*} other The other value to compare.
                 * @returns {boolean} Returns `true` if `value` is less than or equal to
                 *  `other`, else `false`.
                 * @see _.gte
                 * @example
                 *
                 * _.lte(1, 3);
                 * // => true
                 *
                 * _.lte(3, 3);
                 * // => true
                 *
                 * _.lte(3, 1);
                 * // => false
                 */
                var lte = createRelationalOperation(function (value, other) {
                  return value <= other;
                });

                /**
                 * Converts `value` to an array.
                 *
                 * @static
                 * @since 0.1.0
                 * @memberOf _
                 * @category Lang
                 * @param {*} value The value to convert.
                 * @returns {Array} Returns the converted array.
                 * @example
                 *
                 * _.toArray({ 'a': 1, 'b': 2 });
                 * // => [1, 2]
                 *
                 * _.toArray('abc');
                 * // => ['a', 'b', 'c']
                 *
                 * _.toArray(1);
                 * // => []
                 *
                 * _.toArray(null);
                 * // => []
                 */
                function toArray(value) {
                  if (!value) {
                    return [];
                  }
                  if (isArrayLike(value)) {
                    return isString(value)
                      ? stringToArray(value)
                      : copyArray(value);
                  }
                  if (symIterator && value[symIterator]) {
                    return iteratorToArray(value[symIterator]());
                  }
                  var tag = getTag(value),
                    func =
                      tag == mapTag
                        ? mapToArray
                        : tag == setTag
                        ? setToArray
                        : values;

                  return func(value);
                }

                /**
                 * Converts `value` to a finite number.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.12.0
                 * @category Lang
                 * @param {*} value The value to convert.
                 * @returns {number} Returns the converted number.
                 * @example
                 *
                 * _.toFinite(3.2);
                 * // => 3.2
                 *
                 * _.toFinite(Number.MIN_VALUE);
                 * // => 5e-324
                 *
                 * _.toFinite(Infinity);
                 * // => 1.7976931348623157e+308
                 *
                 * _.toFinite('3.2');
                 * // => 3.2
                 */
                function toFinite(value) {
                  if (!value) {
                    return value === 0 ? value : 0;
                  }
                  value = toNumber(value);
                  if (value === INFINITY || value === -INFINITY) {
                    var sign = value < 0 ? -1 : 1;
                    return sign * MAX_INTEGER;
                  }
                  return value === value ? value : 0;
                }

                /**
                 * Converts `value` to an integer.
                 *
                 * **Note:** This method is loosely based on
                 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Lang
                 * @param {*} value The value to convert.
                 * @returns {number} Returns the converted integer.
                 * @example
                 *
                 * _.toInteger(3.2);
                 * // => 3
                 *
                 * _.toInteger(Number.MIN_VALUE);
                 * // => 0
                 *
                 * _.toInteger(Infinity);
                 * // => 1.7976931348623157e+308
                 *
                 * _.toInteger('3.2');
                 * // => 3
                 */
                function toInteger(value) {
                  var result = toFinite(value),
                    remainder = result % 1;

                  return result === result
                    ? remainder
                      ? result - remainder
                      : result
                    : 0;
                }

                /**
                 * Converts `value` to an integer suitable for use as the length of an
                 * array-like object.
                 *
                 * **Note:** This method is based on
                 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Lang
                 * @param {*} value The value to convert.
                 * @returns {number} Returns the converted integer.
                 * @example
                 *
                 * _.toLength(3.2);
                 * // => 3
                 *
                 * _.toLength(Number.MIN_VALUE);
                 * // => 0
                 *
                 * _.toLength(Infinity);
                 * // => 4294967295
                 *
                 * _.toLength('3.2');
                 * // => 3
                 */
                function toLength(value) {
                  return value
                    ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH)
                    : 0;
                }

                /**
                 * Converts `value` to a number.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Lang
                 * @param {*} value The value to process.
                 * @returns {number} Returns the number.
                 * @example
                 *
                 * _.toNumber(3.2);
                 * // => 3.2
                 *
                 * _.toNumber(Number.MIN_VALUE);
                 * // => 5e-324
                 *
                 * _.toNumber(Infinity);
                 * // => Infinity
                 *
                 * _.toNumber('3.2');
                 * // => 3.2
                 */
                function toNumber(value) {
                  if (typeof value == "number") {
                    return value;
                  }
                  if (isSymbol(value)) {
                    return NAN;
                  }
                  if (isObject(value)) {
                    var other =
                      typeof value.valueOf == "function"
                        ? value.valueOf()
                        : value;
                    value = isObject(other) ? other + "" : other;
                  }
                  if (typeof value != "string") {
                    return value === 0 ? value : +value;
                  }
                  value = value.replace(reTrim, "");
                  var isBinary = reIsBinary.test(value);
                  return isBinary || reIsOctal.test(value)
                    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
                    : reIsBadHex.test(value)
                    ? NAN
                    : +value;
                }

                /**
                 * Converts `value` to a plain object flattening inherited enumerable string
                 * keyed properties of `value` to own properties of the plain object.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category Lang
                 * @param {*} value The value to convert.
                 * @returns {Object} Returns the converted plain object.
                 * @example
                 *
                 * function Foo() {
                 *   this.b = 2;
                 * }
                 *
                 * Foo.prototype.c = 3;
                 *
                 * _.assign({ 'a': 1 }, new Foo);
                 * // => { 'a': 1, 'b': 2 }
                 *
                 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
                 * // => { 'a': 1, 'b': 2, 'c': 3 }
                 */
                function toPlainObject(value) {
                  return copyObject(value, keysIn(value));
                }

                /**
                 * Converts `value` to a safe integer. A safe integer can be compared and
                 * represented correctly.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Lang
                 * @param {*} value The value to convert.
                 * @returns {number} Returns the converted integer.
                 * @example
                 *
                 * _.toSafeInteger(3.2);
                 * // => 3
                 *
                 * _.toSafeInteger(Number.MIN_VALUE);
                 * // => 0
                 *
                 * _.toSafeInteger(Infinity);
                 * // => 9007199254740991
                 *
                 * _.toSafeInteger('3.2');
                 * // => 3
                 */
                function toSafeInteger(value) {
                  return value
                    ? baseClamp(
                        toInteger(value),
                        -MAX_SAFE_INTEGER,
                        MAX_SAFE_INTEGER
                      )
                    : value === 0
                    ? value
                    : 0;
                }

                /**
                 * Converts `value` to a string. An empty string is returned for `null`
                 * and `undefined` values. The sign of `-0` is preserved.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Lang
                 * @param {*} value The value to convert.
                 * @returns {string} Returns the converted string.
                 * @example
                 *
                 * _.toString(null);
                 * // => ''
                 *
                 * _.toString(-0);
                 * // => '-0'
                 *
                 * _.toString([1, 2, 3]);
                 * // => '1,2,3'
                 */
                function toString(value) {
                  return value == null ? "" : baseToString(value);
                }

                /*------------------------------------------------------------------------*/

                /**
                 * Assigns own enumerable string keyed properties of source objects to the
                 * destination object. Source objects are applied from left to right.
                 * Subsequent sources overwrite property assignments of previous sources.
                 *
                 * **Note:** This method mutates `object` and is loosely based on
                 * [`Object.assign`](https://mdn.io/Object/assign).
                 *
                 * @static
                 * @memberOf _
                 * @since 0.10.0
                 * @category Object
                 * @param {Object} object The destination object.
                 * @param {...Object} [sources] The source objects.
                 * @returns {Object} Returns `object`.
                 * @see _.assignIn
                 * @example
                 *
                 * function Foo() {
                 *   this.a = 1;
                 * }
                 *
                 * function Bar() {
                 *   this.c = 3;
                 * }
                 *
                 * Foo.prototype.b = 2;
                 * Bar.prototype.d = 4;
                 *
                 * _.assign({ 'a': 0 }, new Foo, new Bar);
                 * // => { 'a': 1, 'c': 3 }
                 */
                var assign = createAssigner(function (object, source) {
                  if (isPrototype(source) || isArrayLike(source)) {
                    copyObject(source, keys(source), object);
                    return;
                  }
                  for (var key in source) {
                    if (hasOwnProperty.call(source, key)) {
                      assignValue(object, key, source[key]);
                    }
                  }
                });

                /**
                 * This method is like `_.assign` except that it iterates over own and
                 * inherited source properties.
                 *
                 * **Note:** This method mutates `object`.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @alias extend
                 * @category Object
                 * @param {Object} object The destination object.
                 * @param {...Object} [sources] The source objects.
                 * @returns {Object} Returns `object`.
                 * @see _.assign
                 * @example
                 *
                 * function Foo() {
                 *   this.a = 1;
                 * }
                 *
                 * function Bar() {
                 *   this.c = 3;
                 * }
                 *
                 * Foo.prototype.b = 2;
                 * Bar.prototype.d = 4;
                 *
                 * _.assignIn({ 'a': 0 }, new Foo, new Bar);
                 * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
                 */
                var assignIn = createAssigner(function (object, source) {
                  copyObject(source, keysIn(source), object);
                });

                /**
                 * This method is like `_.assignIn` except that it accepts `customizer`
                 * which is invoked to produce the assigned values. If `customizer` returns
                 * `undefined`, assignment is handled by the method instead. The `customizer`
                 * is invoked with five arguments: (objValue, srcValue, key, object, source).
                 *
                 * **Note:** This method mutates `object`.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @alias extendWith
                 * @category Object
                 * @param {Object} object The destination object.
                 * @param {...Object} sources The source objects.
                 * @param {Function} [customizer] The function to customize assigned values.
                 * @returns {Object} Returns `object`.
                 * @see _.assignWith
                 * @example
                 *
                 * function customizer(objValue, srcValue) {
                 *   return _.isUndefined(objValue) ? srcValue : objValue;
                 * }
                 *
                 * var defaults = _.partialRight(_.assignInWith, customizer);
                 *
                 * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
                 * // => { 'a': 1, 'b': 2 }
                 */
                var assignInWith = createAssigner(function (
                  object,
                  source,
                  srcIndex,
                  customizer
                ) {
                  copyObject(source, keysIn(source), object, customizer);
                });

                /**
                 * This method is like `_.assign` except that it accepts `customizer`
                 * which is invoked to produce the assigned values. If `customizer` returns
                 * `undefined`, assignment is handled by the method instead. The `customizer`
                 * is invoked with five arguments: (objValue, srcValue, key, object, source).
                 *
                 * **Note:** This method mutates `object`.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Object
                 * @param {Object} object The destination object.
                 * @param {...Object} sources The source objects.
                 * @param {Function} [customizer] The function to customize assigned values.
                 * @returns {Object} Returns `object`.
                 * @see _.assignInWith
                 * @example
                 *
                 * function customizer(objValue, srcValue) {
                 *   return _.isUndefined(objValue) ? srcValue : objValue;
                 * }
                 *
                 * var defaults = _.partialRight(_.assignWith, customizer);
                 *
                 * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
                 * // => { 'a': 1, 'b': 2 }
                 */
                var assignWith = createAssigner(function (
                  object,
                  source,
                  srcIndex,
                  customizer
                ) {
                  copyObject(source, keys(source), object, customizer);
                });

                /**
                 * Creates an array of values corresponding to `paths` of `object`.
                 *
                 * @static
                 * @memberOf _
                 * @since 1.0.0
                 * @category Object
                 * @param {Object} object The object to iterate over.
                 * @param {...(string|string[])} [paths] The property paths to pick.
                 * @returns {Array} Returns the picked values.
                 * @example
                 *
                 * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
                 *
                 * _.at(object, ['a[0].b.c', 'a[1]']);
                 * // => [3, 4]
                 */
                var at = flatRest(baseAt);

                /**
                 * Creates an object that inherits from the `prototype` object. If a
                 * `properties` object is given, its own enumerable string keyed properties
                 * are assigned to the created object.
                 *
                 * @static
                 * @memberOf _
                 * @since 2.3.0
                 * @category Object
                 * @param {Object} prototype The object to inherit from.
                 * @param {Object} [properties] The properties to assign to the object.
                 * @returns {Object} Returns the new object.
                 * @example
                 *
                 * function Shape() {
                 *   this.x = 0;
                 *   this.y = 0;
                 * }
                 *
                 * function Circle() {
                 *   Shape.call(this);
                 * }
                 *
                 * Circle.prototype = _.create(Shape.prototype, {
                 *   'constructor': Circle
                 * });
                 *
                 * var circle = new Circle;
                 * circle instanceof Circle;
                 * // => true
                 *
                 * circle instanceof Shape;
                 * // => true
                 */
                function create(prototype, properties) {
                  var result = baseCreate(prototype);
                  return properties == null
                    ? result
                    : baseAssign(result, properties);
                }

                /**
                 * Assigns own and inherited enumerable string keyed properties of source
                 * objects to the destination object for all destination properties that
                 * resolve to `undefined`. Source objects are applied from left to right.
                 * Once a property is set, additional values of the same property are ignored.
                 *
                 * **Note:** This method mutates `object`.
                 *
                 * @static
                 * @since 0.1.0
                 * @memberOf _
                 * @category Object
                 * @param {Object} object The destination object.
                 * @param {...Object} [sources] The source objects.
                 * @returns {Object} Returns `object`.
                 * @see _.defaultsDeep
                 * @example
                 *
                 * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
                 * // => { 'a': 1, 'b': 2 }
                 */
                var defaults = baseRest(function (object, sources) {
                  object = Object(object);

                  var index = -1;
                  var length = sources.length;
                  var guard = length > 2 ? sources[2] : undefined;

                  if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                    length = 1;
                  }

                  while (++index < length) {
                    var source = sources[index];
                    var props = keysIn(source);
                    var propsIndex = -1;
                    var propsLength = props.length;

                    while (++propsIndex < propsLength) {
                      var key = props[propsIndex];
                      var value = object[key];

                      if (
                        value === undefined ||
                        (eq(value, objectProto[key]) &&
                          !hasOwnProperty.call(object, key))
                      ) {
                        object[key] = source[key];
                      }
                    }
                  }

                  return object;
                });

                /**
                 * This method is like `_.defaults` except that it recursively assigns
                 * default properties.
                 *
                 * **Note:** This method mutates `object`.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.10.0
                 * @category Object
                 * @param {Object} object The destination object.
                 * @param {...Object} [sources] The source objects.
                 * @returns {Object} Returns `object`.
                 * @see _.defaults
                 * @example
                 *
                 * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
                 * // => { 'a': { 'b': 2, 'c': 3 } }
                 */
                var defaultsDeep = baseRest(function (args) {
                  args.push(undefined, customDefaultsMerge);
                  return apply(mergeWith, undefined, args);
                });

                /**
                 * This method is like `_.find` except that it returns the key of the first
                 * element `predicate` returns truthy for instead of the element itself.
                 *
                 * @static
                 * @memberOf _
                 * @since 1.1.0
                 * @category Object
                 * @param {Object} object The object to inspect.
                 * @param {Function} [predicate=_.identity] The function invoked per iteration.
                 * @returns {string|undefined} Returns the key of the matched element,
                 *  else `undefined`.
                 * @example
                 *
                 * var users = {
                 *   'barney':  { 'age': 36, 'active': true },
                 *   'fred':    { 'age': 40, 'active': false },
                 *   'pebbles': { 'age': 1,  'active': true }
                 * };
                 *
                 * _.findKey(users, function(o) { return o.age < 40; });
                 * // => 'barney' (iteration order is not guaranteed)
                 *
                 * // The `_.matches` iteratee shorthand.
                 * _.findKey(users, { 'age': 1, 'active': true });
                 * // => 'pebbles'
                 *
                 * // The `_.matchesProperty` iteratee shorthand.
                 * _.findKey(users, ['active', false]);
                 * // => 'fred'
                 *
                 * // The `_.property` iteratee shorthand.
                 * _.findKey(users, 'active');
                 * // => 'barney'
                 */
                function findKey(object, predicate) {
                  return baseFindKey(
                    object,
                    getIteratee(predicate, 3),
                    baseForOwn
                  );
                }

                /**
                 * This method is like `_.findKey` except that it iterates over elements of
                 * a collection in the opposite order.
                 *
                 * @static
                 * @memberOf _
                 * @since 2.0.0
                 * @category Object
                 * @param {Object} object The object to inspect.
                 * @param {Function} [predicate=_.identity] The function invoked per iteration.
                 * @returns {string|undefined} Returns the key of the matched element,
                 *  else `undefined`.
                 * @example
                 *
                 * var users = {
                 *   'barney':  { 'age': 36, 'active': true },
                 *   'fred':    { 'age': 40, 'active': false },
                 *   'pebbles': { 'age': 1,  'active': true }
                 * };
                 *
                 * _.findLastKey(users, function(o) { return o.age < 40; });
                 * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
                 *
                 * // The `_.matches` iteratee shorthand.
                 * _.findLastKey(users, { 'age': 36, 'active': true });
                 * // => 'barney'
                 *
                 * // The `_.matchesProperty` iteratee shorthand.
                 * _.findLastKey(users, ['active', false]);
                 * // => 'fred'
                 *
                 * // The `_.property` iteratee shorthand.
                 * _.findLastKey(users, 'active');
                 * // => 'pebbles'
                 */
                function findLastKey(object, predicate) {
                  return baseFindKey(
                    object,
                    getIteratee(predicate, 3),
                    baseForOwnRight
                  );
                }

                /**
                 * Iterates over own and inherited enumerable string keyed properties of an
                 * object and invokes `iteratee` for each property. The iteratee is invoked
                 * with three arguments: (value, key, object). Iteratee functions may exit
                 * iteration early by explicitly returning `false`.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.3.0
                 * @category Object
                 * @param {Object} object The object to iterate over.
                 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                 * @returns {Object} Returns `object`.
                 * @see _.forInRight
                 * @example
                 *
                 * function Foo() {
                 *   this.a = 1;
                 *   this.b = 2;
                 * }
                 *
                 * Foo.prototype.c = 3;
                 *
                 * _.forIn(new Foo, function(value, key) {
                 *   console.log(key);
                 * });
                 * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
                 */
                function forIn(object, iteratee) {
                  return object == null
                    ? object
                    : baseFor(object, getIteratee(iteratee, 3), keysIn);
                }

                /**
                 * This method is like `_.forIn` except that it iterates over properties of
                 * `object` in the opposite order.
                 *
                 * @static
                 * @memberOf _
                 * @since 2.0.0
                 * @category Object
                 * @param {Object} object The object to iterate over.
                 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                 * @returns {Object} Returns `object`.
                 * @see _.forIn
                 * @example
                 *
                 * function Foo() {
                 *   this.a = 1;
                 *   this.b = 2;
                 * }
                 *
                 * Foo.prototype.c = 3;
                 *
                 * _.forInRight(new Foo, function(value, key) {
                 *   console.log(key);
                 * });
                 * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
                 */
                function forInRight(object, iteratee) {
                  return object == null
                    ? object
                    : baseForRight(object, getIteratee(iteratee, 3), keysIn);
                }

                /**
                 * Iterates over own enumerable string keyed properties of an object and
                 * invokes `iteratee` for each property. The iteratee is invoked with three
                 * arguments: (value, key, object). Iteratee functions may exit iteration
                 * early by explicitly returning `false`.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.3.0
                 * @category Object
                 * @param {Object} object The object to iterate over.
                 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                 * @returns {Object} Returns `object`.
                 * @see _.forOwnRight
                 * @example
                 *
                 * function Foo() {
                 *   this.a = 1;
                 *   this.b = 2;
                 * }
                 *
                 * Foo.prototype.c = 3;
                 *
                 * _.forOwn(new Foo, function(value, key) {
                 *   console.log(key);
                 * });
                 * // => Logs 'a' then 'b' (iteration order is not guaranteed).
                 */
                function forOwn(object, iteratee) {
                  return object && baseForOwn(object, getIteratee(iteratee, 3));
                }

                /**
                 * This method is like `_.forOwn` except that it iterates over properties of
                 * `object` in the opposite order.
                 *
                 * @static
                 * @memberOf _
                 * @since 2.0.0
                 * @category Object
                 * @param {Object} object The object to iterate over.
                 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                 * @returns {Object} Returns `object`.
                 * @see _.forOwn
                 * @example
                 *
                 * function Foo() {
                 *   this.a = 1;
                 *   this.b = 2;
                 * }
                 *
                 * Foo.prototype.c = 3;
                 *
                 * _.forOwnRight(new Foo, function(value, key) {
                 *   console.log(key);
                 * });
                 * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
                 */
                function forOwnRight(object, iteratee) {
                  return (
                    object && baseForOwnRight(object, getIteratee(iteratee, 3))
                  );
                }

                /**
                 * Creates an array of function property names from own enumerable properties
                 * of `object`.
                 *
                 * @static
                 * @since 0.1.0
                 * @memberOf _
                 * @category Object
                 * @param {Object} object The object to inspect.
                 * @returns {Array} Returns the function names.
                 * @see _.functionsIn
                 * @example
                 *
                 * function Foo() {
                 *   this.a = _.constant('a');
                 *   this.b = _.constant('b');
                 * }
                 *
                 * Foo.prototype.c = _.constant('c');
                 *
                 * _.functions(new Foo);
                 * // => ['a', 'b']
                 */
                function functions(object) {
                  return object == null
                    ? []
                    : baseFunctions(object, keys(object));
                }

                /**
                 * Creates an array of function property names from own and inherited
                 * enumerable properties of `object`.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Object
                 * @param {Object} object The object to inspect.
                 * @returns {Array} Returns the function names.
                 * @see _.functions
                 * @example
                 *
                 * function Foo() {
                 *   this.a = _.constant('a');
                 *   this.b = _.constant('b');
                 * }
                 *
                 * Foo.prototype.c = _.constant('c');
                 *
                 * _.functionsIn(new Foo);
                 * // => ['a', 'b', 'c']
                 */
                function functionsIn(object) {
                  return object == null
                    ? []
                    : baseFunctions(object, keysIn(object));
                }

                /**
                 * Gets the value at `path` of `object`. If the resolved value is
                 * `undefined`, the `defaultValue` is returned in its place.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.7.0
                 * @category Object
                 * @param {Object} object The object to query.
                 * @param {Array|string} path The path of the property to get.
                 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
                 * @returns {*} Returns the resolved value.
                 * @example
                 *
                 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
                 *
                 * _.get(object, 'a[0].b.c');
                 * // => 3
                 *
                 * _.get(object, ['a', '0', 'b', 'c']);
                 * // => 3
                 *
                 * _.get(object, 'a.b.c', 'default');
                 * // => 'default'
                 */
                function get(object, path, defaultValue) {
                  var result =
                    object == null ? undefined : baseGet(object, path);
                  return result === undefined ? defaultValue : result;
                }

                /**
                 * Checks if `path` is a direct property of `object`.
                 *
                 * @static
                 * @since 0.1.0
                 * @memberOf _
                 * @category Object
                 * @param {Object} object The object to query.
                 * @param {Array|string} path The path to check.
                 * @returns {boolean} Returns `true` if `path` exists, else `false`.
                 * @example
                 *
                 * var object = { 'a': { 'b': 2 } };
                 * var other = _.create({ 'a': _.create({ 'b': 2 }) });
                 *
                 * _.has(object, 'a');
                 * // => true
                 *
                 * _.has(object, 'a.b');
                 * // => true
                 *
                 * _.has(object, ['a', 'b']);
                 * // => true
                 *
                 * _.has(other, 'a');
                 * // => false
                 */
                function has(object, path) {
                  return object != null && hasPath(object, path, baseHas);
                }

                /**
                 * Checks if `path` is a direct or inherited property of `object`.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Object
                 * @param {Object} object The object to query.
                 * @param {Array|string} path The path to check.
                 * @returns {boolean} Returns `true` if `path` exists, else `false`.
                 * @example
                 *
                 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
                 *
                 * _.hasIn(object, 'a');
                 * // => true
                 *
                 * _.hasIn(object, 'a.b');
                 * // => true
                 *
                 * _.hasIn(object, ['a', 'b']);
                 * // => true
                 *
                 * _.hasIn(object, 'b');
                 * // => false
                 */
                function hasIn(object, path) {
                  return object != null && hasPath(object, path, baseHasIn);
                }

                /**
                 * Creates an object composed of the inverted keys and values of `object`.
                 * If `object` contains duplicate values, subsequent values overwrite
                 * property assignments of previous values.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.7.0
                 * @category Object
                 * @param {Object} object The object to invert.
                 * @returns {Object} Returns the new inverted object.
                 * @example
                 *
                 * var object = { 'a': 1, 'b': 2, 'c': 1 };
                 *
                 * _.invert(object);
                 * // => { '1': 'c', '2': 'b' }
                 */
                var invert = createInverter(function (result, value, key) {
                  if (value != null && typeof value.toString != "function") {
                    value = nativeObjectToString.call(value);
                  }

                  result[value] = key;
                }, constant(identity));

                /**
                 * This method is like `_.invert` except that the inverted object is generated
                 * from the results of running each element of `object` thru `iteratee`. The
                 * corresponding inverted value of each inverted key is an array of keys
                 * responsible for generating the inverted value. The iteratee is invoked
                 * with one argument: (value).
                 *
                 * @static
                 * @memberOf _
                 * @since 4.1.0
                 * @category Object
                 * @param {Object} object The object to invert.
                 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
                 * @returns {Object} Returns the new inverted object.
                 * @example
                 *
                 * var object = { 'a': 1, 'b': 2, 'c': 1 };
                 *
                 * _.invertBy(object);
                 * // => { '1': ['a', 'c'], '2': ['b'] }
                 *
                 * _.invertBy(object, function(value) {
                 *   return 'group' + value;
                 * });
                 * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
                 */
                var invertBy = createInverter(function (result, value, key) {
                  if (value != null && typeof value.toString != "function") {
                    value = nativeObjectToString.call(value);
                  }

                  if (hasOwnProperty.call(result, value)) {
                    result[value].push(key);
                  } else {
                    result[value] = [key];
                  }
                }, getIteratee);

                /**
                 * Invokes the method at `path` of `object`.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Object
                 * @param {Object} object The object to query.
                 * @param {Array|string} path The path of the method to invoke.
                 * @param {...*} [args] The arguments to invoke the method with.
                 * @returns {*} Returns the result of the invoked method.
                 * @example
                 *
                 * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
                 *
                 * _.invoke(object, 'a[0].b.c.slice', 1, 3);
                 * // => [2, 3]
                 */
                var invoke = baseRest(baseInvoke);

                /**
                 * Creates an array of the own enumerable property names of `object`.
                 *
                 * **Note:** Non-object values are coerced to objects. See the
                 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
                 * for more details.
                 *
                 * @static
                 * @since 0.1.0
                 * @memberOf _
                 * @category Object
                 * @param {Object} object The object to query.
                 * @returns {Array} Returns the array of property names.
                 * @example
                 *
                 * function Foo() {
                 *   this.a = 1;
                 *   this.b = 2;
                 * }
                 *
                 * Foo.prototype.c = 3;
                 *
                 * _.keys(new Foo);
                 * // => ['a', 'b'] (iteration order is not guaranteed)
                 *
                 * _.keys('hi');
                 * // => ['0', '1']
                 */
                function keys(object) {
                  return isArrayLike(object)
                    ? arrayLikeKeys(object)
                    : baseKeys(object);
                }

                /**
                 * Creates an array of the own and inherited enumerable property names of `object`.
                 *
                 * **Note:** Non-object values are coerced to objects.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category Object
                 * @param {Object} object The object to query.
                 * @returns {Array} Returns the array of property names.
                 * @example
                 *
                 * function Foo() {
                 *   this.a = 1;
                 *   this.b = 2;
                 * }
                 *
                 * Foo.prototype.c = 3;
                 *
                 * _.keysIn(new Foo);
                 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
                 */
                function keysIn(object) {
                  return isArrayLike(object)
                    ? arrayLikeKeys(object, true)
                    : baseKeysIn(object);
                }

                /**
                 * The opposite of `_.mapValues`; this method creates an object with the
                 * same values as `object` and keys generated by running each own enumerable
                 * string keyed property of `object` thru `iteratee`. The iteratee is invoked
                 * with three arguments: (value, key, object).
                 *
                 * @static
                 * @memberOf _
                 * @since 3.8.0
                 * @category Object
                 * @param {Object} object The object to iterate over.
                 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                 * @returns {Object} Returns the new mapped object.
                 * @see _.mapValues
                 * @example
                 *
                 * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
                 *   return key + value;
                 * });
                 * // => { 'a1': 1, 'b2': 2 }
                 */
                function mapKeys(object, iteratee) {
                  var result = {};
                  iteratee = getIteratee(iteratee, 3);

                  baseForOwn(object, function (value, key, object) {
                    baseAssignValue(
                      result,
                      iteratee(value, key, object),
                      value
                    );
                  });
                  return result;
                }

                /**
                 * Creates an object with the same keys as `object` and values generated
                 * by running each own enumerable string keyed property of `object` thru
                 * `iteratee`. The iteratee is invoked with three arguments:
                 * (value, key, object).
                 *
                 * @static
                 * @memberOf _
                 * @since 2.4.0
                 * @category Object
                 * @param {Object} object The object to iterate over.
                 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                 * @returns {Object} Returns the new mapped object.
                 * @see _.mapKeys
                 * @example
                 *
                 * var users = {
                 *   'fred':    { 'user': 'fred',    'age': 40 },
                 *   'pebbles': { 'user': 'pebbles', 'age': 1 }
                 * };
                 *
                 * _.mapValues(users, function(o) { return o.age; });
                 * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
                 *
                 * // The `_.property` iteratee shorthand.
                 * _.mapValues(users, 'age');
                 * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
                 */
                function mapValues(object, iteratee) {
                  var result = {};
                  iteratee = getIteratee(iteratee, 3);

                  baseForOwn(object, function (value, key, object) {
                    baseAssignValue(result, key, iteratee(value, key, object));
                  });
                  return result;
                }

                /**
                 * This method is like `_.assign` except that it recursively merges own and
                 * inherited enumerable string keyed properties of source objects into the
                 * destination object. Source properties that resolve to `undefined` are
                 * skipped if a destination value exists. Array and plain object properties
                 * are merged recursively. Other objects and value types are overridden by
                 * assignment. Source objects are applied from left to right. Subsequent
                 * sources overwrite property assignments of previous sources.
                 *
                 * **Note:** This method mutates `object`.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.5.0
                 * @category Object
                 * @param {Object} object The destination object.
                 * @param {...Object} [sources] The source objects.
                 * @returns {Object} Returns `object`.
                 * @example
                 *
                 * var object = {
                 *   'a': [{ 'b': 2 }, { 'd': 4 }]
                 * };
                 *
                 * var other = {
                 *   'a': [{ 'c': 3 }, { 'e': 5 }]
                 * };
                 *
                 * _.merge(object, other);
                 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
                 */
                var merge = createAssigner(function (object, source, srcIndex) {
                  baseMerge(object, source, srcIndex);
                });

                /**
                 * This method is like `_.merge` except that it accepts `customizer` which
                 * is invoked to produce the merged values of the destination and source
                 * properties. If `customizer` returns `undefined`, merging is handled by the
                 * method instead. The `customizer` is invoked with six arguments:
                 * (objValue, srcValue, key, object, source, stack).
                 *
                 * **Note:** This method mutates `object`.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Object
                 * @param {Object} object The destination object.
                 * @param {...Object} sources The source objects.
                 * @param {Function} customizer The function to customize assigned values.
                 * @returns {Object} Returns `object`.
                 * @example
                 *
                 * function customizer(objValue, srcValue) {
                 *   if (_.isArray(objValue)) {
                 *     return objValue.concat(srcValue);
                 *   }
                 * }
                 *
                 * var object = { 'a': [1], 'b': [2] };
                 * var other = { 'a': [3], 'b': [4] };
                 *
                 * _.mergeWith(object, other, customizer);
                 * // => { 'a': [1, 3], 'b': [2, 4] }
                 */
                var mergeWith = createAssigner(function (
                  object,
                  source,
                  srcIndex,
                  customizer
                ) {
                  baseMerge(object, source, srcIndex, customizer);
                });

                /**
                 * The opposite of `_.pick`; this method creates an object composed of the
                 * own and inherited enumerable property paths of `object` that are not omitted.
                 *
                 * **Note:** This method is considerably slower than `_.pick`.
                 *
                 * @static
                 * @since 0.1.0
                 * @memberOf _
                 * @category Object
                 * @param {Object} object The source object.
                 * @param {...(string|string[])} [paths] The property paths to omit.
                 * @returns {Object} Returns the new object.
                 * @example
                 *
                 * var object = { 'a': 1, 'b': '2', 'c': 3 };
                 *
                 * _.omit(object, ['a', 'c']);
                 * // => { 'b': '2' }
                 */
                var omit = flatRest(function (object, paths) {
                  var result = {};
                  if (object == null) {
                    return result;
                  }
                  var isDeep = false;
                  paths = arrayMap(paths, function (path) {
                    path = castPath(path, object);
                    isDeep || (isDeep = path.length > 1);
                    return path;
                  });
                  copyObject(object, getAllKeysIn(object), result);
                  if (isDeep) {
                    result = baseClone(
                      result,
                      CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG,
                      customOmitClone
                    );
                  }
                  var length = paths.length;
                  while (length--) {
                    baseUnset(result, paths[length]);
                  }
                  return result;
                });

                /**
                 * The opposite of `_.pickBy`; this method creates an object composed of
                 * the own and inherited enumerable string keyed properties of `object` that
                 * `predicate` doesn't return truthy for. The predicate is invoked with two
                 * arguments: (value, key).
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Object
                 * @param {Object} object The source object.
                 * @param {Function} [predicate=_.identity] The function invoked per property.
                 * @returns {Object} Returns the new object.
                 * @example
                 *
                 * var object = { 'a': 1, 'b': '2', 'c': 3 };
                 *
                 * _.omitBy(object, _.isNumber);
                 * // => { 'b': '2' }
                 */
                function omitBy(object, predicate) {
                  return pickBy(object, negate(getIteratee(predicate)));
                }

                /**
                 * Creates an object composed of the picked `object` properties.
                 *
                 * @static
                 * @since 0.1.0
                 * @memberOf _
                 * @category Object
                 * @param {Object} object The source object.
                 * @param {...(string|string[])} [paths] The property paths to pick.
                 * @returns {Object} Returns the new object.
                 * @example
                 *
                 * var object = { 'a': 1, 'b': '2', 'c': 3 };
                 *
                 * _.pick(object, ['a', 'c']);
                 * // => { 'a': 1, 'c': 3 }
                 */
                var pick = flatRest(function (object, paths) {
                  return object == null ? {} : basePick(object, paths);
                });

                /**
                 * Creates an object composed of the `object` properties `predicate` returns
                 * truthy for. The predicate is invoked with two arguments: (value, key).
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Object
                 * @param {Object} object The source object.
                 * @param {Function} [predicate=_.identity] The function invoked per property.
                 * @returns {Object} Returns the new object.
                 * @example
                 *
                 * var object = { 'a': 1, 'b': '2', 'c': 3 };
                 *
                 * _.pickBy(object, _.isNumber);
                 * // => { 'a': 1, 'c': 3 }
                 */
                function pickBy(object, predicate) {
                  if (object == null) {
                    return {};
                  }
                  var props = arrayMap(getAllKeysIn(object), function (prop) {
                    return [prop];
                  });
                  predicate = getIteratee(predicate);
                  return basePickBy(object, props, function (value, path) {
                    return predicate(value, path[0]);
                  });
                }

                /**
                 * This method is like `_.get` except that if the resolved value is a
                 * function it's invoked with the `this` binding of its parent object and
                 * its result is returned.
                 *
                 * @static
                 * @since 0.1.0
                 * @memberOf _
                 * @category Object
                 * @param {Object} object The object to query.
                 * @param {Array|string} path The path of the property to resolve.
                 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
                 * @returns {*} Returns the resolved value.
                 * @example
                 *
                 * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
                 *
                 * _.result(object, 'a[0].b.c1');
                 * // => 3
                 *
                 * _.result(object, 'a[0].b.c2');
                 * // => 4
                 *
                 * _.result(object, 'a[0].b.c3', 'default');
                 * // => 'default'
                 *
                 * _.result(object, 'a[0].b.c3', _.constant('default'));
                 * // => 'default'
                 */
                function result(object, path, defaultValue) {
                  path = castPath(path, object);

                  var index = -1,
                    length = path.length;

                  // Ensure the loop is entered when path is empty.
                  if (!length) {
                    length = 1;
                    object = undefined;
                  }
                  while (++index < length) {
                    var value =
                      object == null ? undefined : object[toKey(path[index])];
                    if (value === undefined) {
                      index = length;
                      value = defaultValue;
                    }
                    object = isFunction(value) ? value.call(object) : value;
                  }
                  return object;
                }

                /**
                 * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
                 * it's created. Arrays are created for missing index properties while objects
                 * are created for all other missing properties. Use `_.setWith` to customize
                 * `path` creation.
                 *
                 * **Note:** This method mutates `object`.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.7.0
                 * @category Object
                 * @param {Object} object The object to modify.
                 * @param {Array|string} path The path of the property to set.
                 * @param {*} value The value to set.
                 * @returns {Object} Returns `object`.
                 * @example
                 *
                 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
                 *
                 * _.set(object, 'a[0].b.c', 4);
                 * console.log(object.a[0].b.c);
                 * // => 4
                 *
                 * _.set(object, ['x', '0', 'y', 'z'], 5);
                 * console.log(object.x[0].y.z);
                 * // => 5
                 */
                function set(object, path, value) {
                  return object == null ? object : baseSet(object, path, value);
                }

                /**
                 * This method is like `_.set` except that it accepts `customizer` which is
                 * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
                 * path creation is handled by the method instead. The `customizer` is invoked
                 * with three arguments: (nsValue, key, nsObject).
                 *
                 * **Note:** This method mutates `object`.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Object
                 * @param {Object} object The object to modify.
                 * @param {Array|string} path The path of the property to set.
                 * @param {*} value The value to set.
                 * @param {Function} [customizer] The function to customize assigned values.
                 * @returns {Object} Returns `object`.
                 * @example
                 *
                 * var object = {};
                 *
                 * _.setWith(object, '[0][1]', 'a', Object);
                 * // => { '0': { '1': 'a' } }
                 */
                function setWith(object, path, value, customizer) {
                  customizer =
                    typeof customizer == "function" ? customizer : undefined;
                  return object == null
                    ? object
                    : baseSet(object, path, value, customizer);
                }

                /**
                 * Creates an array of own enumerable string keyed-value pairs for `object`
                 * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
                 * entries are returned.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @alias entries
                 * @category Object
                 * @param {Object} object The object to query.
                 * @returns {Array} Returns the key-value pairs.
                 * @example
                 *
                 * function Foo() {
                 *   this.a = 1;
                 *   this.b = 2;
                 * }
                 *
                 * Foo.prototype.c = 3;
                 *
                 * _.toPairs(new Foo);
                 * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
                 */
                var toPairs = createToPairs(keys);

                /**
                 * Creates an array of own and inherited enumerable string keyed-value pairs
                 * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
                 * or set, its entries are returned.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @alias entriesIn
                 * @category Object
                 * @param {Object} object The object to query.
                 * @returns {Array} Returns the key-value pairs.
                 * @example
                 *
                 * function Foo() {
                 *   this.a = 1;
                 *   this.b = 2;
                 * }
                 *
                 * Foo.prototype.c = 3;
                 *
                 * _.toPairsIn(new Foo);
                 * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
                 */
                var toPairsIn = createToPairs(keysIn);

                /**
                 * An alternative to `_.reduce`; this method transforms `object` to a new
                 * `accumulator` object which is the result of running each of its own
                 * enumerable string keyed properties thru `iteratee`, with each invocation
                 * potentially mutating the `accumulator` object. If `accumulator` is not
                 * provided, a new object with the same `[[Prototype]]` will be used. The
                 * iteratee is invoked with four arguments: (accumulator, value, key, object).
                 * Iteratee functions may exit iteration early by explicitly returning `false`.
                 *
                 * @static
                 * @memberOf _
                 * @since 1.3.0
                 * @category Object
                 * @param {Object} object The object to iterate over.
                 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                 * @param {*} [accumulator] The custom accumulator value.
                 * @returns {*} Returns the accumulated value.
                 * @example
                 *
                 * _.transform([2, 3, 4], function(result, n) {
                 *   result.push(n *= n);
                 *   return n % 2 == 0;
                 * }, []);
                 * // => [4, 9]
                 *
                 * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
                 *   (result[value] || (result[value] = [])).push(key);
                 * }, {});
                 * // => { '1': ['a', 'c'], '2': ['b'] }
                 */
                function transform(object, iteratee, accumulator) {
                  var isArr = isArray(object),
                    isArrLike =
                      isArr || isBuffer(object) || isTypedArray(object);

                  iteratee = getIteratee(iteratee, 4);
                  if (accumulator == null) {
                    var Ctor = object && object.constructor;
                    if (isArrLike) {
                      accumulator = isArr ? new Ctor() : [];
                    } else if (isObject(object)) {
                      accumulator = isFunction(Ctor)
                        ? baseCreate(getPrototype(object))
                        : {};
                    } else {
                      accumulator = {};
                    }
                  }
                  (isArrLike ? arrayEach : baseForOwn)(object, function (
                    value,
                    index,
                    object
                  ) {
                    return iteratee(accumulator, value, index, object);
                  });
                  return accumulator;
                }

                /**
                 * Removes the property at `path` of `object`.
                 *
                 * **Note:** This method mutates `object`.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Object
                 * @param {Object} object The object to modify.
                 * @param {Array|string} path The path of the property to unset.
                 * @returns {boolean} Returns `true` if the property is deleted, else `false`.
                 * @example
                 *
                 * var object = { 'a': [{ 'b': { 'c': 7 } }] };
                 * _.unset(object, 'a[0].b.c');
                 * // => true
                 *
                 * console.log(object);
                 * // => { 'a': [{ 'b': {} }] };
                 *
                 * _.unset(object, ['a', '0', 'b', 'c']);
                 * // => true
                 *
                 * console.log(object);
                 * // => { 'a': [{ 'b': {} }] };
                 */
                function unset(object, path) {
                  return object == null ? true : baseUnset(object, path);
                }

                /**
                 * This method is like `_.set` except that accepts `updater` to produce the
                 * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
                 * is invoked with one argument: (value).
                 *
                 * **Note:** This method mutates `object`.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.6.0
                 * @category Object
                 * @param {Object} object The object to modify.
                 * @param {Array|string} path The path of the property to set.
                 * @param {Function} updater The function to produce the updated value.
                 * @returns {Object} Returns `object`.
                 * @example
                 *
                 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
                 *
                 * _.update(object, 'a[0].b.c', function(n) { return n * n; });
                 * console.log(object.a[0].b.c);
                 * // => 9
                 *
                 * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
                 * console.log(object.x[0].y.z);
                 * // => 0
                 */
                function update(object, path, updater) {
                  return object == null
                    ? object
                    : baseUpdate(object, path, castFunction(updater));
                }

                /**
                 * This method is like `_.update` except that it accepts `customizer` which is
                 * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
                 * path creation is handled by the method instead. The `customizer` is invoked
                 * with three arguments: (nsValue, key, nsObject).
                 *
                 * **Note:** This method mutates `object`.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.6.0
                 * @category Object
                 * @param {Object} object The object to modify.
                 * @param {Array|string} path The path of the property to set.
                 * @param {Function} updater The function to produce the updated value.
                 * @param {Function} [customizer] The function to customize assigned values.
                 * @returns {Object} Returns `object`.
                 * @example
                 *
                 * var object = {};
                 *
                 * _.updateWith(object, '[0][1]', _.constant('a'), Object);
                 * // => { '0': { '1': 'a' } }
                 */
                function updateWith(object, path, updater, customizer) {
                  customizer =
                    typeof customizer == "function" ? customizer : undefined;
                  return object == null
                    ? object
                    : baseUpdate(
                        object,
                        path,
                        castFunction(updater),
                        customizer
                      );
                }

                /**
                 * Creates an array of the own enumerable string keyed property values of `object`.
                 *
                 * **Note:** Non-object values are coerced to objects.
                 *
                 * @static
                 * @since 0.1.0
                 * @memberOf _
                 * @category Object
                 * @param {Object} object The object to query.
                 * @returns {Array} Returns the array of property values.
                 * @example
                 *
                 * function Foo() {
                 *   this.a = 1;
                 *   this.b = 2;
                 * }
                 *
                 * Foo.prototype.c = 3;
                 *
                 * _.values(new Foo);
                 * // => [1, 2] (iteration order is not guaranteed)
                 *
                 * _.values('hi');
                 * // => ['h', 'i']
                 */
                function values(object) {
                  return object == null ? [] : baseValues(object, keys(object));
                }

                /**
                 * Creates an array of the own and inherited enumerable string keyed property
                 * values of `object`.
                 *
                 * **Note:** Non-object values are coerced to objects.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category Object
                 * @param {Object} object The object to query.
                 * @returns {Array} Returns the array of property values.
                 * @example
                 *
                 * function Foo() {
                 *   this.a = 1;
                 *   this.b = 2;
                 * }
                 *
                 * Foo.prototype.c = 3;
                 *
                 * _.valuesIn(new Foo);
                 * // => [1, 2, 3] (iteration order is not guaranteed)
                 */
                function valuesIn(object) {
                  return object == null
                    ? []
                    : baseValues(object, keysIn(object));
                }

                /*------------------------------------------------------------------------*/

                /**
                 * Clamps `number` within the inclusive `lower` and `upper` bounds.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Number
                 * @param {number} number The number to clamp.
                 * @param {number} [lower] The lower bound.
                 * @param {number} upper The upper bound.
                 * @returns {number} Returns the clamped number.
                 * @example
                 *
                 * _.clamp(-10, -5, 5);
                 * // => -5
                 *
                 * _.clamp(10, -5, 5);
                 * // => 5
                 */
                function clamp(number, lower, upper) {
                  if (upper === undefined) {
                    upper = lower;
                    lower = undefined;
                  }
                  if (upper !== undefined) {
                    upper = toNumber(upper);
                    upper = upper === upper ? upper : 0;
                  }
                  if (lower !== undefined) {
                    lower = toNumber(lower);
                    lower = lower === lower ? lower : 0;
                  }
                  return baseClamp(toNumber(number), lower, upper);
                }

                /**
                 * Checks if `n` is between `start` and up to, but not including, `end`. If
                 * `end` is not specified, it's set to `start` with `start` then set to `0`.
                 * If `start` is greater than `end` the params are swapped to support
                 * negative ranges.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.3.0
                 * @category Number
                 * @param {number} number The number to check.
                 * @param {number} [start=0] The start of the range.
                 * @param {number} end The end of the range.
                 * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
                 * @see _.range, _.rangeRight
                 * @example
                 *
                 * _.inRange(3, 2, 4);
                 * // => true
                 *
                 * _.inRange(4, 8);
                 * // => true
                 *
                 * _.inRange(4, 2);
                 * // => false
                 *
                 * _.inRange(2, 2);
                 * // => false
                 *
                 * _.inRange(1.2, 2);
                 * // => true
                 *
                 * _.inRange(5.2, 4);
                 * // => false
                 *
                 * _.inRange(-3, -2, -6);
                 * // => true
                 */
                function inRange(number, start, end) {
                  start = toFinite(start);
                  if (end === undefined) {
                    end = start;
                    start = 0;
                  } else {
                    end = toFinite(end);
                  }
                  number = toNumber(number);
                  return baseInRange(number, start, end);
                }

                /**
                 * Produces a random number between the inclusive `lower` and `upper` bounds.
                 * If only one argument is provided a number between `0` and the given number
                 * is returned. If `floating` is `true`, or either `lower` or `upper` are
                 * floats, a floating-point number is returned instead of an integer.
                 *
                 * **Note:** JavaScript follows the IEEE-754 standard for resolving
                 * floating-point values which can produce unexpected results.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.7.0
                 * @category Number
                 * @param {number} [lower=0] The lower bound.
                 * @param {number} [upper=1] The upper bound.
                 * @param {boolean} [floating] Specify returning a floating-point number.
                 * @returns {number} Returns the random number.
                 * @example
                 *
                 * _.random(0, 5);
                 * // => an integer between 0 and 5
                 *
                 * _.random(5);
                 * // => also an integer between 0 and 5
                 *
                 * _.random(5, true);
                 * // => a floating-point number between 0 and 5
                 *
                 * _.random(1.2, 5.2);
                 * // => a floating-point number between 1.2 and 5.2
                 */
                function random(lower, upper, floating) {
                  if (
                    floating &&
                    typeof floating != "boolean" &&
                    isIterateeCall(lower, upper, floating)
                  ) {
                    upper = floating = undefined;
                  }
                  if (floating === undefined) {
                    if (typeof upper == "boolean") {
                      floating = upper;
                      upper = undefined;
                    } else if (typeof lower == "boolean") {
                      floating = lower;
                      lower = undefined;
                    }
                  }
                  if (lower === undefined && upper === undefined) {
                    lower = 0;
                    upper = 1;
                  } else {
                    lower = toFinite(lower);
                    if (upper === undefined) {
                      upper = lower;
                      lower = 0;
                    } else {
                      upper = toFinite(upper);
                    }
                  }
                  if (lower > upper) {
                    var temp = lower;
                    lower = upper;
                    upper = temp;
                  }
                  if (floating || lower % 1 || upper % 1) {
                    var rand = nativeRandom();
                    return nativeMin(
                      lower +
                        rand *
                          (upper -
                            lower +
                            freeParseFloat("1e-" + ((rand + "").length - 1))),
                      upper
                    );
                  }
                  return baseRandom(lower, upper);
                }

                /*------------------------------------------------------------------------*/

                /**
                 * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category String
                 * @param {string} [string=''] The string to convert.
                 * @returns {string} Returns the camel cased string.
                 * @example
                 *
                 * _.camelCase('Foo Bar');
                 * // => 'fooBar'
                 *
                 * _.camelCase('--foo-bar--');
                 * // => 'fooBar'
                 *
                 * _.camelCase('__FOO_BAR__');
                 * // => 'fooBar'
                 */
                var camelCase = createCompounder(function (
                  result,
                  word,
                  index
                ) {
                  word = word.toLowerCase();
                  return result + (index ? capitalize(word) : word);
                });

                /**
                 * Converts the first character of `string` to upper case and the remaining
                 * to lower case.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category String
                 * @param {string} [string=''] The string to capitalize.
                 * @returns {string} Returns the capitalized string.
                 * @example
                 *
                 * _.capitalize('FRED');
                 * // => 'Fred'
                 */
                function capitalize(string) {
                  return upperFirst(toString(string).toLowerCase());
                }

                /**
                 * Deburrs `string` by converting
                 * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
                 * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
                 * letters to basic Latin letters and removing
                 * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category String
                 * @param {string} [string=''] The string to deburr.
                 * @returns {string} Returns the deburred string.
                 * @example
                 *
                 * _.deburr('déjà vu');
                 * // => 'deja vu'
                 */
                function deburr(string) {
                  string = toString(string);
                  return (
                    string &&
                    string
                      .replace(reLatin, deburrLetter)
                      .replace(reComboMark, "")
                  );
                }

                /**
                 * Checks if `string` ends with the given target string.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category String
                 * @param {string} [string=''] The string to inspect.
                 * @param {string} [target] The string to search for.
                 * @param {number} [position=string.length] The position to search up to.
                 * @returns {boolean} Returns `true` if `string` ends with `target`,
                 *  else `false`.
                 * @example
                 *
                 * _.endsWith('abc', 'c');
                 * // => true
                 *
                 * _.endsWith('abc', 'b');
                 * // => false
                 *
                 * _.endsWith('abc', 'b', 2);
                 * // => true
                 */
                function endsWith(string, target, position) {
                  string = toString(string);
                  target = baseToString(target);

                  var length = string.length;
                  position =
                    position === undefined
                      ? length
                      : baseClamp(toInteger(position), 0, length);

                  var end = position;
                  position -= target.length;
                  return position >= 0 && string.slice(position, end) == target;
                }

                /**
                 * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
                 * corresponding HTML entities.
                 *
                 * **Note:** No other characters are escaped. To escape additional
                 * characters use a third-party library like [_he_](https://mths.be/he).
                 *
                 * Though the ">" character is escaped for symmetry, characters like
                 * ">" and "/" don't need escaping in HTML and have no special meaning
                 * unless they're part of a tag or unquoted attribute value. See
                 * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
                 * (under "semi-related fun fact") for more details.
                 *
                 * When working with HTML you should always
                 * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
                 * XSS vectors.
                 *
                 * @static
                 * @since 0.1.0
                 * @memberOf _
                 * @category String
                 * @param {string} [string=''] The string to escape.
                 * @returns {string} Returns the escaped string.
                 * @example
                 *
                 * _.escape('fred, barney, & pebbles');
                 * // => 'fred, barney, &amp; pebbles'
                 */
                function escape(string) {
                  string = toString(string);
                  return string && reHasUnescapedHtml.test(string)
                    ? string.replace(reUnescapedHtml, escapeHtmlChar)
                    : string;
                }

                /**
                 * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
                 * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category String
                 * @param {string} [string=''] The string to escape.
                 * @returns {string} Returns the escaped string.
                 * @example
                 *
                 * _.escapeRegExp('[lodash](https://lodash.com/)');
                 * // => '\[lodash\]\(https://lodash\.com/\)'
                 */
                function escapeRegExp(string) {
                  string = toString(string);
                  return string && reHasRegExpChar.test(string)
                    ? string.replace(reRegExpChar, "\\$&")
                    : string;
                }

                /**
                 * Converts `string` to
                 * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category String
                 * @param {string} [string=''] The string to convert.
                 * @returns {string} Returns the kebab cased string.
                 * @example
                 *
                 * _.kebabCase('Foo Bar');
                 * // => 'foo-bar'
                 *
                 * _.kebabCase('fooBar');
                 * // => 'foo-bar'
                 *
                 * _.kebabCase('__FOO_BAR__');
                 * // => 'foo-bar'
                 */
                var kebabCase = createCompounder(function (
                  result,
                  word,
                  index
                ) {
                  return result + (index ? "-" : "") + word.toLowerCase();
                });

                /**
                 * Converts `string`, as space separated words, to lower case.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category String
                 * @param {string} [string=''] The string to convert.
                 * @returns {string} Returns the lower cased string.
                 * @example
                 *
                 * _.lowerCase('--Foo-Bar--');
                 * // => 'foo bar'
                 *
                 * _.lowerCase('fooBar');
                 * // => 'foo bar'
                 *
                 * _.lowerCase('__FOO_BAR__');
                 * // => 'foo bar'
                 */
                var lowerCase = createCompounder(function (
                  result,
                  word,
                  index
                ) {
                  return result + (index ? " " : "") + word.toLowerCase();
                });

                /**
                 * Converts the first character of `string` to lower case.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category String
                 * @param {string} [string=''] The string to convert.
                 * @returns {string} Returns the converted string.
                 * @example
                 *
                 * _.lowerFirst('Fred');
                 * // => 'fred'
                 *
                 * _.lowerFirst('FRED');
                 * // => 'fRED'
                 */
                var lowerFirst = createCaseFirst("toLowerCase");

                /**
                 * Pads `string` on the left and right sides if it's shorter than `length`.
                 * Padding characters are truncated if they can't be evenly divided by `length`.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category String
                 * @param {string} [string=''] The string to pad.
                 * @param {number} [length=0] The padding length.
                 * @param {string} [chars=' '] The string used as padding.
                 * @returns {string} Returns the padded string.
                 * @example
                 *
                 * _.pad('abc', 8);
                 * // => '  abc   '
                 *
                 * _.pad('abc', 8, '_-');
                 * // => '_-abc_-_'
                 *
                 * _.pad('abc', 3);
                 * // => 'abc'
                 */
                function pad(string, length, chars) {
                  string = toString(string);
                  length = toInteger(length);

                  var strLength = length ? stringSize(string) : 0;
                  if (!length || strLength >= length) {
                    return string;
                  }
                  var mid = (length - strLength) / 2;
                  return (
                    createPadding(nativeFloor(mid), chars) +
                    string +
                    createPadding(nativeCeil(mid), chars)
                  );
                }

                /**
                 * Pads `string` on the right side if it's shorter than `length`. Padding
                 * characters are truncated if they exceed `length`.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category String
                 * @param {string} [string=''] The string to pad.
                 * @param {number} [length=0] The padding length.
                 * @param {string} [chars=' '] The string used as padding.
                 * @returns {string} Returns the padded string.
                 * @example
                 *
                 * _.padEnd('abc', 6);
                 * // => 'abc   '
                 *
                 * _.padEnd('abc', 6, '_-');
                 * // => 'abc_-_'
                 *
                 * _.padEnd('abc', 3);
                 * // => 'abc'
                 */
                function padEnd(string, length, chars) {
                  string = toString(string);
                  length = toInteger(length);

                  var strLength = length ? stringSize(string) : 0;
                  return length && strLength < length
                    ? string + createPadding(length - strLength, chars)
                    : string;
                }

                /**
                 * Pads `string` on the left side if it's shorter than `length`. Padding
                 * characters are truncated if they exceed `length`.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category String
                 * @param {string} [string=''] The string to pad.
                 * @param {number} [length=0] The padding length.
                 * @param {string} [chars=' '] The string used as padding.
                 * @returns {string} Returns the padded string.
                 * @example
                 *
                 * _.padStart('abc', 6);
                 * // => '   abc'
                 *
                 * _.padStart('abc', 6, '_-');
                 * // => '_-_abc'
                 *
                 * _.padStart('abc', 3);
                 * // => 'abc'
                 */
                function padStart(string, length, chars) {
                  string = toString(string);
                  length = toInteger(length);

                  var strLength = length ? stringSize(string) : 0;
                  return length && strLength < length
                    ? createPadding(length - strLength, chars) + string
                    : string;
                }

                /**
                 * Converts `string` to an integer of the specified radix. If `radix` is
                 * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
                 * hexadecimal, in which case a `radix` of `16` is used.
                 *
                 * **Note:** This method aligns with the
                 * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
                 *
                 * @static
                 * @memberOf _
                 * @since 1.1.0
                 * @category String
                 * @param {string} string The string to convert.
                 * @param {number} [radix=10] The radix to interpret `value` by.
                 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
                 * @returns {number} Returns the converted integer.
                 * @example
                 *
                 * _.parseInt('08');
                 * // => 8
                 *
                 * _.map(['6', '08', '10'], _.parseInt);
                 * // => [6, 8, 10]
                 */
                function parseInt(string, radix, guard) {
                  if (guard || radix == null) {
                    radix = 0;
                  } else if (radix) {
                    radix = +radix;
                  }
                  return nativeParseInt(
                    toString(string).replace(reTrimStart, ""),
                    radix || 0
                  );
                }

                /**
                 * Repeats the given string `n` times.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category String
                 * @param {string} [string=''] The string to repeat.
                 * @param {number} [n=1] The number of times to repeat the string.
                 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
                 * @returns {string} Returns the repeated string.
                 * @example
                 *
                 * _.repeat('*', 3);
                 * // => '***'
                 *
                 * _.repeat('abc', 2);
                 * // => 'abcabc'
                 *
                 * _.repeat('abc', 0);
                 * // => ''
                 */
                function repeat(string, n, guard) {
                  if (
                    guard ? isIterateeCall(string, n, guard) : n === undefined
                  ) {
                    n = 1;
                  } else {
                    n = toInteger(n);
                  }
                  return baseRepeat(toString(string), n);
                }

                /**
                 * Replaces matches for `pattern` in `string` with `replacement`.
                 *
                 * **Note:** This method is based on
                 * [`String#replace`](https://mdn.io/String/replace).
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category String
                 * @param {string} [string=''] The string to modify.
                 * @param {RegExp|string} pattern The pattern to replace.
                 * @param {Function|string} replacement The match replacement.
                 * @returns {string} Returns the modified string.
                 * @example
                 *
                 * _.replace('Hi Fred', 'Fred', 'Barney');
                 * // => 'Hi Barney'
                 */
                function replace() {
                  var args = arguments,
                    string = toString(args[0]);

                  return args.length < 3
                    ? string
                    : string.replace(args[1], args[2]);
                }

                /**
                 * Converts `string` to
                 * [snake case](https://en.wikipedia.org/wiki/Snake_case).
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category String
                 * @param {string} [string=''] The string to convert.
                 * @returns {string} Returns the snake cased string.
                 * @example
                 *
                 * _.snakeCase('Foo Bar');
                 * // => 'foo_bar'
                 *
                 * _.snakeCase('fooBar');
                 * // => 'foo_bar'
                 *
                 * _.snakeCase('--FOO-BAR--');
                 * // => 'foo_bar'
                 */
                var snakeCase = createCompounder(function (
                  result,
                  word,
                  index
                ) {
                  return result + (index ? "_" : "") + word.toLowerCase();
                });

                /**
                 * Splits `string` by `separator`.
                 *
                 * **Note:** This method is based on
                 * [`String#split`](https://mdn.io/String/split).
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category String
                 * @param {string} [string=''] The string to split.
                 * @param {RegExp|string} separator The separator pattern to split by.
                 * @param {number} [limit] The length to truncate results to.
                 * @returns {Array} Returns the string segments.
                 * @example
                 *
                 * _.split('a-b-c', '-', 2);
                 * // => ['a', 'b']
                 */
                function split(string, separator, limit) {
                  if (
                    limit &&
                    typeof limit != "number" &&
                    isIterateeCall(string, separator, limit)
                  ) {
                    separator = limit = undefined;
                  }
                  limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;
                  if (!limit) {
                    return [];
                  }
                  string = toString(string);
                  if (
                    string &&
                    (typeof separator == "string" ||
                      (separator != null && !isRegExp(separator)))
                  ) {
                    separator = baseToString(separator);
                    if (!separator && hasUnicode(string)) {
                      return castSlice(stringToArray(string), 0, limit);
                    }
                  }
                  return string.split(separator, limit);
                }

                /**
                 * Converts `string` to
                 * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
                 *
                 * @static
                 * @memberOf _
                 * @since 3.1.0
                 * @category String
                 * @param {string} [string=''] The string to convert.
                 * @returns {string} Returns the start cased string.
                 * @example
                 *
                 * _.startCase('--foo-bar--');
                 * // => 'Foo Bar'
                 *
                 * _.startCase('fooBar');
                 * // => 'Foo Bar'
                 *
                 * _.startCase('__FOO_BAR__');
                 * // => 'FOO BAR'
                 */
                var startCase = createCompounder(function (
                  result,
                  word,
                  index
                ) {
                  return result + (index ? " " : "") + upperFirst(word);
                });

                /**
                 * Checks if `string` starts with the given target string.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category String
                 * @param {string} [string=''] The string to inspect.
                 * @param {string} [target] The string to search for.
                 * @param {number} [position=0] The position to search from.
                 * @returns {boolean} Returns `true` if `string` starts with `target`,
                 *  else `false`.
                 * @example
                 *
                 * _.startsWith('abc', 'a');
                 * // => true
                 *
                 * _.startsWith('abc', 'b');
                 * // => false
                 *
                 * _.startsWith('abc', 'b', 1);
                 * // => true
                 */
                function startsWith(string, target, position) {
                  string = toString(string);
                  position =
                    position == null
                      ? 0
                      : baseClamp(toInteger(position), 0, string.length);

                  target = baseToString(target);
                  return (
                    string.slice(position, position + target.length) == target
                  );
                }

                /**
                 * Creates a compiled template function that can interpolate data properties
                 * in "interpolate" delimiters, HTML-escape interpolated data properties in
                 * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
                 * properties may be accessed as free variables in the template. If a setting
                 * object is given, it takes precedence over `_.templateSettings` values.
                 *
                 * **Note:** In the development build `_.template` utilizes
                 * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
                 * for easier debugging.
                 *
                 * For more information on precompiling templates see
                 * [lodash's custom builds documentation](https://lodash.com/custom-builds).
                 *
                 * For more information on Chrome extension sandboxes see
                 * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
                 *
                 * @static
                 * @since 0.1.0
                 * @memberOf _
                 * @category String
                 * @param {string} [string=''] The template string.
                 * @param {Object} [options={}] The options object.
                 * @param {RegExp} [options.escape=_.templateSettings.escape]
                 *  The HTML "escape" delimiter.
                 * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
                 *  The "evaluate" delimiter.
                 * @param {Object} [options.imports=_.templateSettings.imports]
                 *  An object to import into the template as free variables.
                 * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
                 *  The "interpolate" delimiter.
                 * @param {string} [options.sourceURL='lodash.templateSources[n]']
                 *  The sourceURL of the compiled template.
                 * @param {string} [options.variable='obj']
                 *  The data object variable name.
                 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
                 * @returns {Function} Returns the compiled template function.
                 * @example
                 *
                 * // Use the "interpolate" delimiter to create a compiled template.
                 * var compiled = _.template('hello <%= user %>!');
                 * compiled({ 'user': 'fred' });
                 * // => 'hello fred!'
                 *
                 * // Use the HTML "escape" delimiter to escape data property values.
                 * var compiled = _.template('<b><%- value %></b>');
                 * compiled({ 'value': '<script>' });
                 * // => '<b>&lt;script&gt;</b>'
                 *
                 * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
                 * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
                 * compiled({ 'users': ['fred', 'barney'] });
                 * // => '<li>fred</li><li>barney</li>'
                 *
                 * // Use the internal `print` function in "evaluate" delimiters.
                 * var compiled = _.template('<% print("hello " + user); %>!');
                 * compiled({ 'user': 'barney' });
                 * // => 'hello barney!'
                 *
                 * // Use the ES template literal delimiter as an "interpolate" delimiter.
                 * // Disable support by replacing the "interpolate" delimiter.
                 * var compiled = _.template('hello ${ user }!');
                 * compiled({ 'user': 'pebbles' });
                 * // => 'hello pebbles!'
                 *
                 * // Use backslashes to treat delimiters as plain text.
                 * var compiled = _.template('<%= "\\<%- value %\\>" %>');
                 * compiled({ 'value': 'ignored' });
                 * // => '<%- value %>'
                 *
                 * // Use the `imports` option to import `jQuery` as `jq`.
                 * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
                 * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
                 * compiled({ 'users': ['fred', 'barney'] });
                 * // => '<li>fred</li><li>barney</li>'
                 *
                 * // Use the `sourceURL` option to specify a custom sourceURL for the template.
                 * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
                 * compiled(data);
                 * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
                 *
                 * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
                 * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
                 * compiled.source;
                 * // => function(data) {
                 * //   var __t, __p = '';
                 * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
                 * //   return __p;
                 * // }
                 *
                 * // Use custom template delimiters.
                 * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
                 * var compiled = _.template('hello {{ user }}!');
                 * compiled({ 'user': 'mustache' });
                 * // => 'hello mustache!'
                 *
                 * // Use the `source` property to inline compiled templates for meaningful
                 * // line numbers in error messages and stack traces.
                 * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
                 *   var JST = {\
                 *     "main": ' + _.template(mainText).source + '\
                 *   };\
                 * ');
                 */
                function template(string, options, guard) {
                  // Based on John Resig's `tmpl` implementation
                  // (http://ejohn.org/blog/javascript-micro-templating/)
                  // and Laura Doktorova's doT.js (https://github.com/olado/doT).
                  var settings = lodash.templateSettings;

                  if (guard && isIterateeCall(string, options, guard)) {
                    options = undefined;
                  }
                  string = toString(string);
                  options = assignInWith(
                    {},
                    options,
                    settings,
                    customDefaultsAssignIn
                  );

                  var imports = assignInWith(
                      {},
                      options.imports,
                      settings.imports,
                      customDefaultsAssignIn
                    ),
                    importsKeys = keys(imports),
                    importsValues = baseValues(imports, importsKeys);

                  var isEscaping,
                    isEvaluating,
                    index = 0,
                    interpolate = options.interpolate || reNoMatch,
                    source = "__p += '";

                  // Compile the regexp to match each delimiter.
                  var reDelimiters = RegExp(
                    (options.escape || reNoMatch).source +
                      "|" +
                      interpolate.source +
                      "|" +
                      (interpolate === reInterpolate ? reEsTemplate : reNoMatch)
                        .source +
                      "|" +
                      (options.evaluate || reNoMatch).source +
                      "|$",
                    "g"
                  );

                  // Use a sourceURL for easier debugging.
                  // The sourceURL gets injected into the source that's eval-ed, so be careful
                  // to normalize all kinds of whitespace, so e.g. newlines (and unicode versions of it) can't sneak in
                  // and escape the comment, thus injecting code that gets evaled.
                  var sourceURL =
                    "//# sourceURL=" +
                    (hasOwnProperty.call(options, "sourceURL")
                      ? (options.sourceURL + "").replace(/\s/g, " ")
                      : "lodash.templateSources[" + ++templateCounter + "]") +
                    "\n";

                  string.replace(reDelimiters, function (
                    match,
                    escapeValue,
                    interpolateValue,
                    esTemplateValue,
                    evaluateValue,
                    offset
                  ) {
                    interpolateValue || (interpolateValue = esTemplateValue);

                    // Escape characters that can't be included in string literals.
                    source += string
                      .slice(index, offset)
                      .replace(reUnescapedString, escapeStringChar);

                    // Replace delimiters with snippets.
                    if (escapeValue) {
                      isEscaping = true;
                      source += "' +\n__e(" + escapeValue + ") +\n'";
                    }
                    if (evaluateValue) {
                      isEvaluating = true;
                      source += "';\n" + evaluateValue + ";\n__p += '";
                    }
                    if (interpolateValue) {
                      source +=
                        "' +\n((__t = (" +
                        interpolateValue +
                        ")) == null ? '' : __t) +\n'";
                    }
                    index = offset + match.length;

                    // The JS engine embedded in Adobe products needs `match` returned in
                    // order to produce the correct `offset` value.
                    return match;
                  });

                  source += "';\n";

                  // If `variable` is not specified wrap a with-statement around the generated
                  // code to add the data object to the top of the scope chain.
                  var variable =
                    hasOwnProperty.call(options, "variable") &&
                    options.variable;
                  if (!variable) {
                    source = "with (obj) {\n" + source + "\n}\n";
                  }
                  // Cleanup code by stripping empty strings.
                  source = (isEvaluating
                    ? source.replace(reEmptyStringLeading, "")
                    : source
                  )
                    .replace(reEmptyStringMiddle, "$1")
                    .replace(reEmptyStringTrailing, "$1;");

                  // Frame code as the function body.
                  source =
                    "function(" +
                    (variable || "obj") +
                    ") {\n" +
                    (variable ? "" : "obj || (obj = {});\n") +
                    "var __t, __p = ''" +
                    (isEscaping ? ", __e = _.escape" : "") +
                    (isEvaluating
                      ? ", __j = Array.prototype.join;\n" +
                        "function print() { __p += __j.call(arguments, '') }\n"
                      : ";\n") +
                    source +
                    "return __p\n}";

                  var result = attempt(function () {
                    return Function(
                      importsKeys,
                      sourceURL + "return " + source
                    ).apply(undefined, importsValues);
                  });

                  // Provide the compiled function's source by its `toString` method or
                  // the `source` property as a convenience for inlining compiled templates.
                  result.source = source;
                  if (isError(result)) {
                    throw result;
                  }
                  return result;
                }

                /**
                 * Converts `string`, as a whole, to lower case just like
                 * [String#toLowerCase](https://mdn.io/toLowerCase).
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category String
                 * @param {string} [string=''] The string to convert.
                 * @returns {string} Returns the lower cased string.
                 * @example
                 *
                 * _.toLower('--Foo-Bar--');
                 * // => '--foo-bar--'
                 *
                 * _.toLower('fooBar');
                 * // => 'foobar'
                 *
                 * _.toLower('__FOO_BAR__');
                 * // => '__foo_bar__'
                 */
                function toLower(value) {
                  return toString(value).toLowerCase();
                }

                /**
                 * Converts `string`, as a whole, to upper case just like
                 * [String#toUpperCase](https://mdn.io/toUpperCase).
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category String
                 * @param {string} [string=''] The string to convert.
                 * @returns {string} Returns the upper cased string.
                 * @example
                 *
                 * _.toUpper('--foo-bar--');
                 * // => '--FOO-BAR--'
                 *
                 * _.toUpper('fooBar');
                 * // => 'FOOBAR'
                 *
                 * _.toUpper('__foo_bar__');
                 * // => '__FOO_BAR__'
                 */
                function toUpper(value) {
                  return toString(value).toUpperCase();
                }

                /**
                 * Removes leading and trailing whitespace or specified characters from `string`.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category String
                 * @param {string} [string=''] The string to trim.
                 * @param {string} [chars=whitespace] The characters to trim.
                 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
                 * @returns {string} Returns the trimmed string.
                 * @example
                 *
                 * _.trim('  abc  ');
                 * // => 'abc'
                 *
                 * _.trim('-_-abc-_-', '_-');
                 * // => 'abc'
                 *
                 * _.map(['  foo  ', '  bar  '], _.trim);
                 * // => ['foo', 'bar']
                 */
                function trim(string, chars, guard) {
                  string = toString(string);
                  if (string && (guard || chars === undefined)) {
                    return string.replace(reTrim, "");
                  }
                  if (!string || !(chars = baseToString(chars))) {
                    return string;
                  }
                  var strSymbols = stringToArray(string),
                    chrSymbols = stringToArray(chars),
                    start = charsStartIndex(strSymbols, chrSymbols),
                    end = charsEndIndex(strSymbols, chrSymbols) + 1;

                  return castSlice(strSymbols, start, end).join("");
                }

                /**
                 * Removes trailing whitespace or specified characters from `string`.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category String
                 * @param {string} [string=''] The string to trim.
                 * @param {string} [chars=whitespace] The characters to trim.
                 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
                 * @returns {string} Returns the trimmed string.
                 * @example
                 *
                 * _.trimEnd('  abc  ');
                 * // => '  abc'
                 *
                 * _.trimEnd('-_-abc-_-', '_-');
                 * // => '-_-abc'
                 */
                function trimEnd(string, chars, guard) {
                  string = toString(string);
                  if (string && (guard || chars === undefined)) {
                    return string.replace(reTrimEnd, "");
                  }
                  if (!string || !(chars = baseToString(chars))) {
                    return string;
                  }
                  var strSymbols = stringToArray(string),
                    end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;

                  return castSlice(strSymbols, 0, end).join("");
                }

                /**
                 * Removes leading whitespace or specified characters from `string`.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category String
                 * @param {string} [string=''] The string to trim.
                 * @param {string} [chars=whitespace] The characters to trim.
                 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
                 * @returns {string} Returns the trimmed string.
                 * @example
                 *
                 * _.trimStart('  abc  ');
                 * // => 'abc  '
                 *
                 * _.trimStart('-_-abc-_-', '_-');
                 * // => 'abc-_-'
                 */
                function trimStart(string, chars, guard) {
                  string = toString(string);
                  if (string && (guard || chars === undefined)) {
                    return string.replace(reTrimStart, "");
                  }
                  if (!string || !(chars = baseToString(chars))) {
                    return string;
                  }
                  var strSymbols = stringToArray(string),
                    start = charsStartIndex(strSymbols, stringToArray(chars));

                  return castSlice(strSymbols, start).join("");
                }

                /**
                 * Truncates `string` if it's longer than the given maximum string length.
                 * The last characters of the truncated string are replaced with the omission
                 * string which defaults to "...".
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category String
                 * @param {string} [string=''] The string to truncate.
                 * @param {Object} [options={}] The options object.
                 * @param {number} [options.length=30] The maximum string length.
                 * @param {string} [options.omission='...'] The string to indicate text is omitted.
                 * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
                 * @returns {string} Returns the truncated string.
                 * @example
                 *
                 * _.truncate('hi-diddly-ho there, neighborino');
                 * // => 'hi-diddly-ho there, neighbo...'
                 *
                 * _.truncate('hi-diddly-ho there, neighborino', {
                 *   'length': 24,
                 *   'separator': ' '
                 * });
                 * // => 'hi-diddly-ho there,...'
                 *
                 * _.truncate('hi-diddly-ho there, neighborino', {
                 *   'length': 24,
                 *   'separator': /,? +/
                 * });
                 * // => 'hi-diddly-ho there...'
                 *
                 * _.truncate('hi-diddly-ho there, neighborino', {
                 *   'omission': ' [...]'
                 * });
                 * // => 'hi-diddly-ho there, neig [...]'
                 */
                function truncate(string, options) {
                  var length = DEFAULT_TRUNC_LENGTH,
                    omission = DEFAULT_TRUNC_OMISSION;

                  if (isObject(options)) {
                    var separator =
                      "separator" in options ? options.separator : separator;
                    length =
                      "length" in options ? toInteger(options.length) : length;
                    omission =
                      "omission" in options
                        ? baseToString(options.omission)
                        : omission;
                  }
                  string = toString(string);

                  var strLength = string.length;
                  if (hasUnicode(string)) {
                    var strSymbols = stringToArray(string);
                    strLength = strSymbols.length;
                  }
                  if (length >= strLength) {
                    return string;
                  }
                  var end = length - stringSize(omission);
                  if (end < 1) {
                    return omission;
                  }
                  var result = strSymbols
                    ? castSlice(strSymbols, 0, end).join("")
                    : string.slice(0, end);

                  if (separator === undefined) {
                    return result + omission;
                  }
                  if (strSymbols) {
                    end += result.length - end;
                  }
                  if (isRegExp(separator)) {
                    if (string.slice(end).search(separator)) {
                      var match,
                        substring = result;

                      if (!separator.global) {
                        separator = RegExp(
                          separator.source,
                          toString(reFlags.exec(separator)) + "g"
                        );
                      }
                      separator.lastIndex = 0;
                      while ((match = separator.exec(substring))) {
                        var newEnd = match.index;
                      }
                      result = result.slice(
                        0,
                        newEnd === undefined ? end : newEnd
                      );
                    }
                  } else if (
                    string.indexOf(baseToString(separator), end) != end
                  ) {
                    var index = result.lastIndexOf(separator);
                    if (index > -1) {
                      result = result.slice(0, index);
                    }
                  }
                  return result + omission;
                }

                /**
                 * The inverse of `_.escape`; this method converts the HTML entities
                 * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
                 * their corresponding characters.
                 *
                 * **Note:** No other HTML entities are unescaped. To unescape additional
                 * HTML entities use a third-party library like [_he_](https://mths.be/he).
                 *
                 * @static
                 * @memberOf _
                 * @since 0.6.0
                 * @category String
                 * @param {string} [string=''] The string to unescape.
                 * @returns {string} Returns the unescaped string.
                 * @example
                 *
                 * _.unescape('fred, barney, &amp; pebbles');
                 * // => 'fred, barney, & pebbles'
                 */
                function unescape(string) {
                  string = toString(string);
                  return string && reHasEscapedHtml.test(string)
                    ? string.replace(reEscapedHtml, unescapeHtmlChar)
                    : string;
                }

                /**
                 * Converts `string`, as space separated words, to upper case.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category String
                 * @param {string} [string=''] The string to convert.
                 * @returns {string} Returns the upper cased string.
                 * @example
                 *
                 * _.upperCase('--foo-bar');
                 * // => 'FOO BAR'
                 *
                 * _.upperCase('fooBar');
                 * // => 'FOO BAR'
                 *
                 * _.upperCase('__foo_bar__');
                 * // => 'FOO BAR'
                 */
                var upperCase = createCompounder(function (
                  result,
                  word,
                  index
                ) {
                  return result + (index ? " " : "") + word.toUpperCase();
                });

                /**
                 * Converts the first character of `string` to upper case.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category String
                 * @param {string} [string=''] The string to convert.
                 * @returns {string} Returns the converted string.
                 * @example
                 *
                 * _.upperFirst('fred');
                 * // => 'Fred'
                 *
                 * _.upperFirst('FRED');
                 * // => 'FRED'
                 */
                var upperFirst = createCaseFirst("toUpperCase");

                /**
                 * Splits `string` into an array of its words.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category String
                 * @param {string} [string=''] The string to inspect.
                 * @param {RegExp|string} [pattern] The pattern to match words.
                 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
                 * @returns {Array} Returns the words of `string`.
                 * @example
                 *
                 * _.words('fred, barney, & pebbles');
                 * // => ['fred', 'barney', 'pebbles']
                 *
                 * _.words('fred, barney, & pebbles', /[^, ]+/g);
                 * // => ['fred', 'barney', '&', 'pebbles']
                 */
                function words(string, pattern, guard) {
                  string = toString(string);
                  pattern = guard ? undefined : pattern;

                  if (pattern === undefined) {
                    return hasUnicodeWord(string)
                      ? unicodeWords(string)
                      : asciiWords(string);
                  }
                  return string.match(pattern) || [];
                }

                /*------------------------------------------------------------------------*/

                /**
                 * Attempts to invoke `func`, returning either the result or the caught error
                 * object. Any additional arguments are provided to `func` when it's invoked.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category Util
                 * @param {Function} func The function to attempt.
                 * @param {...*} [args] The arguments to invoke `func` with.
                 * @returns {*} Returns the `func` result or error object.
                 * @example
                 *
                 * // Avoid throwing errors for invalid selectors.
                 * var elements = _.attempt(function(selector) {
                 *   return document.querySelectorAll(selector);
                 * }, '>_>');
                 *
                 * if (_.isError(elements)) {
                 *   elements = [];
                 * }
                 */
                var attempt = baseRest(function (func, args) {
                  try {
                    return apply(func, undefined, args);
                  } catch (e) {
                    return isError(e) ? e : new Error(e);
                  }
                });

                /**
                 * Binds methods of an object to the object itself, overwriting the existing
                 * method.
                 *
                 * **Note:** This method doesn't set the "length" property of bound functions.
                 *
                 * @static
                 * @since 0.1.0
                 * @memberOf _
                 * @category Util
                 * @param {Object} object The object to bind and assign the bound methods to.
                 * @param {...(string|string[])} methodNames The object method names to bind.
                 * @returns {Object} Returns `object`.
                 * @example
                 *
                 * var view = {
                 *   'label': 'docs',
                 *   'click': function() {
                 *     console.log('clicked ' + this.label);
                 *   }
                 * };
                 *
                 * _.bindAll(view, ['click']);
                 * jQuery(element).on('click', view.click);
                 * // => Logs 'clicked docs' when clicked.
                 */
                var bindAll = flatRest(function (object, methodNames) {
                  arrayEach(methodNames, function (key) {
                    key = toKey(key);
                    baseAssignValue(object, key, bind(object[key], object));
                  });
                  return object;
                });

                /**
                 * Creates a function that iterates over `pairs` and invokes the corresponding
                 * function of the first predicate to return truthy. The predicate-function
                 * pairs are invoked with the `this` binding and arguments of the created
                 * function.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Util
                 * @param {Array} pairs The predicate-function pairs.
                 * @returns {Function} Returns the new composite function.
                 * @example
                 *
                 * var func = _.cond([
                 *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
                 *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
                 *   [_.stubTrue,                      _.constant('no match')]
                 * ]);
                 *
                 * func({ 'a': 1, 'b': 2 });
                 * // => 'matches A'
                 *
                 * func({ 'a': 0, 'b': 1 });
                 * // => 'matches B'
                 *
                 * func({ 'a': '1', 'b': '2' });
                 * // => 'no match'
                 */
                function cond(pairs) {
                  var length = pairs == null ? 0 : pairs.length,
                    toIteratee = getIteratee();

                  pairs = !length
                    ? []
                    : arrayMap(pairs, function (pair) {
                        if (typeof pair[1] != "function") {
                          throw new TypeError(FUNC_ERROR_TEXT);
                        }
                        return [toIteratee(pair[0]), pair[1]];
                      });

                  return baseRest(function (args) {
                    var index = -1;
                    while (++index < length) {
                      var pair = pairs[index];
                      if (apply(pair[0], this, args)) {
                        return apply(pair[1], this, args);
                      }
                    }
                  });
                }

                /**
                 * Creates a function that invokes the predicate properties of `source` with
                 * the corresponding property values of a given object, returning `true` if
                 * all predicates return truthy, else `false`.
                 *
                 * **Note:** The created function is equivalent to `_.conformsTo` with
                 * `source` partially applied.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Util
                 * @param {Object} source The object of property predicates to conform to.
                 * @returns {Function} Returns the new spec function.
                 * @example
                 *
                 * var objects = [
                 *   { 'a': 2, 'b': 1 },
                 *   { 'a': 1, 'b': 2 }
                 * ];
                 *
                 * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
                 * // => [{ 'a': 1, 'b': 2 }]
                 */
                function conforms(source) {
                  return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
                }

                /**
                 * Creates a function that returns `value`.
                 *
                 * @static
                 * @memberOf _
                 * @since 2.4.0
                 * @category Util
                 * @param {*} value The value to return from the new function.
                 * @returns {Function} Returns the new constant function.
                 * @example
                 *
                 * var objects = _.times(2, _.constant({ 'a': 1 }));
                 *
                 * console.log(objects);
                 * // => [{ 'a': 1 }, { 'a': 1 }]
                 *
                 * console.log(objects[0] === objects[1]);
                 * // => true
                 */
                function constant(value) {
                  return function () {
                    return value;
                  };
                }

                /**
                 * Checks `value` to determine whether a default value should be returned in
                 * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
                 * or `undefined`.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.14.0
                 * @category Util
                 * @param {*} value The value to check.
                 * @param {*} defaultValue The default value.
                 * @returns {*} Returns the resolved value.
                 * @example
                 *
                 * _.defaultTo(1, 10);
                 * // => 1
                 *
                 * _.defaultTo(undefined, 10);
                 * // => 10
                 */
                function defaultTo(value, defaultValue) {
                  return value == null || value !== value
                    ? defaultValue
                    : value;
                }

                /**
                 * Creates a function that returns the result of invoking the given functions
                 * with the `this` binding of the created function, where each successive
                 * invocation is supplied the return value of the previous.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category Util
                 * @param {...(Function|Function[])} [funcs] The functions to invoke.
                 * @returns {Function} Returns the new composite function.
                 * @see _.flowRight
                 * @example
                 *
                 * function square(n) {
                 *   return n * n;
                 * }
                 *
                 * var addSquare = _.flow([_.add, square]);
                 * addSquare(1, 2);
                 * // => 9
                 */
                var flow = createFlow();

                /**
                 * This method is like `_.flow` except that it creates a function that
                 * invokes the given functions from right to left.
                 *
                 * @static
                 * @since 3.0.0
                 * @memberOf _
                 * @category Util
                 * @param {...(Function|Function[])} [funcs] The functions to invoke.
                 * @returns {Function} Returns the new composite function.
                 * @see _.flow
                 * @example
                 *
                 * function square(n) {
                 *   return n * n;
                 * }
                 *
                 * var addSquare = _.flowRight([square, _.add]);
                 * addSquare(1, 2);
                 * // => 9
                 */
                var flowRight = createFlow(true);

                /**
                 * This method returns the first argument it receives.
                 *
                 * @static
                 * @since 0.1.0
                 * @memberOf _
                 * @category Util
                 * @param {*} value Any value.
                 * @returns {*} Returns `value`.
                 * @example
                 *
                 * var object = { 'a': 1 };
                 *
                 * console.log(_.identity(object) === object);
                 * // => true
                 */
                function identity(value) {
                  return value;
                }

                /**
                 * Creates a function that invokes `func` with the arguments of the created
                 * function. If `func` is a property name, the created function returns the
                 * property value for a given element. If `func` is an array or object, the
                 * created function returns `true` for elements that contain the equivalent
                 * source properties, otherwise it returns `false`.
                 *
                 * @static
                 * @since 4.0.0
                 * @memberOf _
                 * @category Util
                 * @param {*} [func=_.identity] The value to convert to a callback.
                 * @returns {Function} Returns the callback.
                 * @example
                 *
                 * var users = [
                 *   { 'user': 'barney', 'age': 36, 'active': true },
                 *   { 'user': 'fred',   'age': 40, 'active': false }
                 * ];
                 *
                 * // The `_.matches` iteratee shorthand.
                 * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
                 * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
                 *
                 * // The `_.matchesProperty` iteratee shorthand.
                 * _.filter(users, _.iteratee(['user', 'fred']));
                 * // => [{ 'user': 'fred', 'age': 40 }]
                 *
                 * // The `_.property` iteratee shorthand.
                 * _.map(users, _.iteratee('user'));
                 * // => ['barney', 'fred']
                 *
                 * // Create custom iteratee shorthands.
                 * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
                 *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
                 *     return func.test(string);
                 *   };
                 * });
                 *
                 * _.filter(['abc', 'def'], /ef/);
                 * // => ['def']
                 */
                function iteratee(func) {
                  return baseIteratee(
                    typeof func == "function"
                      ? func
                      : baseClone(func, CLONE_DEEP_FLAG)
                  );
                }

                /**
                 * Creates a function that performs a partial deep comparison between a given
                 * object and `source`, returning `true` if the given object has equivalent
                 * property values, else `false`.
                 *
                 * **Note:** The created function is equivalent to `_.isMatch` with `source`
                 * partially applied.
                 *
                 * Partial comparisons will match empty array and empty object `source`
                 * values against any array or object value, respectively. See `_.isEqual`
                 * for a list of supported value comparisons.
                 *
                 * **Note:** Multiple values can be checked by combining several matchers
                 * using `_.overSome`
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category Util
                 * @param {Object} source The object of property values to match.
                 * @returns {Function} Returns the new spec function.
                 * @example
                 *
                 * var objects = [
                 *   { 'a': 1, 'b': 2, 'c': 3 },
                 *   { 'a': 4, 'b': 5, 'c': 6 }
                 * ];
                 *
                 * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
                 * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
                 *
                 * // Checking for several possible values
                 * _.filter(objects, _.overSome([_.matches({ 'a': 1 }), _.matches({ 'a': 4 })]));
                 * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
                 */
                function matches(source) {
                  return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
                }

                /**
                 * Creates a function that performs a partial deep comparison between the
                 * value at `path` of a given object to `srcValue`, returning `true` if the
                 * object value is equivalent, else `false`.
                 *
                 * **Note:** Partial comparisons will match empty array and empty object
                 * `srcValue` values against any array or object value, respectively. See
                 * `_.isEqual` for a list of supported value comparisons.
                 *
                 * **Note:** Multiple values can be checked by combining several matchers
                 * using `_.overSome`
                 *
                 * @static
                 * @memberOf _
                 * @since 3.2.0
                 * @category Util
                 * @param {Array|string} path The path of the property to get.
                 * @param {*} srcValue The value to match.
                 * @returns {Function} Returns the new spec function.
                 * @example
                 *
                 * var objects = [
                 *   { 'a': 1, 'b': 2, 'c': 3 },
                 *   { 'a': 4, 'b': 5, 'c': 6 }
                 * ];
                 *
                 * _.find(objects, _.matchesProperty('a', 4));
                 * // => { 'a': 4, 'b': 5, 'c': 6 }
                 *
                 * // Checking for several possible values
                 * _.filter(objects, _.overSome([_.matchesProperty('a', 1), _.matchesProperty('a', 4)]));
                 * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
                 */
                function matchesProperty(path, srcValue) {
                  return baseMatchesProperty(
                    path,
                    baseClone(srcValue, CLONE_DEEP_FLAG)
                  );
                }

                /**
                 * Creates a function that invokes the method at `path` of a given object.
                 * Any additional arguments are provided to the invoked method.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.7.0
                 * @category Util
                 * @param {Array|string} path The path of the method to invoke.
                 * @param {...*} [args] The arguments to invoke the method with.
                 * @returns {Function} Returns the new invoker function.
                 * @example
                 *
                 * var objects = [
                 *   { 'a': { 'b': _.constant(2) } },
                 *   { 'a': { 'b': _.constant(1) } }
                 * ];
                 *
                 * _.map(objects, _.method('a.b'));
                 * // => [2, 1]
                 *
                 * _.map(objects, _.method(['a', 'b']));
                 * // => [2, 1]
                 */
                var method = baseRest(function (path, args) {
                  return function (object) {
                    return baseInvoke(object, path, args);
                  };
                });

                /**
                 * The opposite of `_.method`; this method creates a function that invokes
                 * the method at a given path of `object`. Any additional arguments are
                 * provided to the invoked method.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.7.0
                 * @category Util
                 * @param {Object} object The object to query.
                 * @param {...*} [args] The arguments to invoke the method with.
                 * @returns {Function} Returns the new invoker function.
                 * @example
                 *
                 * var array = _.times(3, _.constant),
                 *     object = { 'a': array, 'b': array, 'c': array };
                 *
                 * _.map(['a[2]', 'c[0]'], _.methodOf(object));
                 * // => [2, 0]
                 *
                 * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
                 * // => [2, 0]
                 */
                var methodOf = baseRest(function (object, args) {
                  return function (path) {
                    return baseInvoke(object, path, args);
                  };
                });

                /**
                 * Adds all own enumerable string keyed function properties of a source
                 * object to the destination object. If `object` is a function, then methods
                 * are added to its prototype as well.
                 *
                 * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
                 * avoid conflicts caused by modifying the original.
                 *
                 * @static
                 * @since 0.1.0
                 * @memberOf _
                 * @category Util
                 * @param {Function|Object} [object=lodash] The destination object.
                 * @param {Object} source The object of functions to add.
                 * @param {Object} [options={}] The options object.
                 * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
                 * @returns {Function|Object} Returns `object`.
                 * @example
                 *
                 * function vowels(string) {
                 *   return _.filter(string, function(v) {
                 *     return /[aeiou]/i.test(v);
                 *   });
                 * }
                 *
                 * _.mixin({ 'vowels': vowels });
                 * _.vowels('fred');
                 * // => ['e']
                 *
                 * _('fred').vowels().value();
                 * // => ['e']
                 *
                 * _.mixin({ 'vowels': vowels }, { 'chain': false });
                 * _('fred').vowels();
                 * // => ['e']
                 */
                function mixin(object, source, options) {
                  var props = keys(source),
                    methodNames = baseFunctions(source, props);

                  if (
                    options == null &&
                    !(isObject(source) && (methodNames.length || !props.length))
                  ) {
                    options = source;
                    source = object;
                    object = this;
                    methodNames = baseFunctions(source, keys(source));
                  }
                  var chain =
                      !(isObject(options) && "chain" in options) ||
                      !!options.chain,
                    isFunc = isFunction(object);

                  arrayEach(methodNames, function (methodName) {
                    var func = source[methodName];
                    object[methodName] = func;
                    if (isFunc) {
                      object.prototype[methodName] = function () {
                        var chainAll = this.__chain__;
                        if (chain || chainAll) {
                          var result = object(this.__wrapped__),
                            actions = (result.__actions__ = copyArray(
                              this.__actions__
                            ));

                          actions.push({
                            func: func,
                            args: arguments,
                            thisArg: object,
                          });
                          result.__chain__ = chainAll;
                          return result;
                        }
                        return func.apply(
                          object,
                          arrayPush([this.value()], arguments)
                        );
                      };
                    }
                  });

                  return object;
                }

                /**
                 * Reverts the `_` variable to its previous value and returns a reference to
                 * the `lodash` function.
                 *
                 * @static
                 * @since 0.1.0
                 * @memberOf _
                 * @category Util
                 * @returns {Function} Returns the `lodash` function.
                 * @example
                 *
                 * var lodash = _.noConflict();
                 */
                function noConflict() {
                  if (root._ === this) {
                    root._ = oldDash;
                  }
                  return this;
                }

                /**
                 * This method returns `undefined`.
                 *
                 * @static
                 * @memberOf _
                 * @since 2.3.0
                 * @category Util
                 * @example
                 *
                 * _.times(2, _.noop);
                 * // => [undefined, undefined]
                 */
                function noop() {
                  // No operation performed.
                }

                /**
                 * Creates a function that gets the argument at index `n`. If `n` is negative,
                 * the nth argument from the end is returned.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Util
                 * @param {number} [n=0] The index of the argument to return.
                 * @returns {Function} Returns the new pass-thru function.
                 * @example
                 *
                 * var func = _.nthArg(1);
                 * func('a', 'b', 'c', 'd');
                 * // => 'b'
                 *
                 * var func = _.nthArg(-2);
                 * func('a', 'b', 'c', 'd');
                 * // => 'c'
                 */
                function nthArg(n) {
                  n = toInteger(n);
                  return baseRest(function (args) {
                    return baseNth(args, n);
                  });
                }

                /**
                 * Creates a function that invokes `iteratees` with the arguments it receives
                 * and returns their results.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Util
                 * @param {...(Function|Function[])} [iteratees=[_.identity]]
                 *  The iteratees to invoke.
                 * @returns {Function} Returns the new function.
                 * @example
                 *
                 * var func = _.over([Math.max, Math.min]);
                 *
                 * func(1, 2, 3, 4);
                 * // => [4, 1]
                 */
                var over = createOver(arrayMap);

                /**
                 * Creates a function that checks if **all** of the `predicates` return
                 * truthy when invoked with the arguments it receives.
                 *
                 * Following shorthands are possible for providing predicates.
                 * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
                 * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Util
                 * @param {...(Function|Function[])} [predicates=[_.identity]]
                 *  The predicates to check.
                 * @returns {Function} Returns the new function.
                 * @example
                 *
                 * var func = _.overEvery([Boolean, isFinite]);
                 *
                 * func('1');
                 * // => true
                 *
                 * func(null);
                 * // => false
                 *
                 * func(NaN);
                 * // => false
                 */
                var overEvery = createOver(arrayEvery);

                /**
                 * Creates a function that checks if **any** of the `predicates` return
                 * truthy when invoked with the arguments it receives.
                 *
                 * Following shorthands are possible for providing predicates.
                 * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
                 * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Util
                 * @param {...(Function|Function[])} [predicates=[_.identity]]
                 *  The predicates to check.
                 * @returns {Function} Returns the new function.
                 * @example
                 *
                 * var func = _.overSome([Boolean, isFinite]);
                 *
                 * func('1');
                 * // => true
                 *
                 * func(null);
                 * // => true
                 *
                 * func(NaN);
                 * // => false
                 *
                 * var matchesFunc = _.overSome([{ 'a': 1 }, { 'a': 2 }])
                 * var matchesPropertyFunc = _.overSome([['a', 1], ['a', 2]])
                 */
                var overSome = createOver(arraySome);

                /**
                 * Creates a function that returns the value at `path` of a given object.
                 *
                 * @static
                 * @memberOf _
                 * @since 2.4.0
                 * @category Util
                 * @param {Array|string} path The path of the property to get.
                 * @returns {Function} Returns the new accessor function.
                 * @example
                 *
                 * var objects = [
                 *   { 'a': { 'b': 2 } },
                 *   { 'a': { 'b': 1 } }
                 * ];
                 *
                 * _.map(objects, _.property('a.b'));
                 * // => [2, 1]
                 *
                 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
                 * // => [1, 2]
                 */
                function property(path) {
                  return isKey(path)
                    ? baseProperty(toKey(path))
                    : basePropertyDeep(path);
                }

                /**
                 * The opposite of `_.property`; this method creates a function that returns
                 * the value at a given path of `object`.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category Util
                 * @param {Object} object The object to query.
                 * @returns {Function} Returns the new accessor function.
                 * @example
                 *
                 * var array = [0, 1, 2],
                 *     object = { 'a': array, 'b': array, 'c': array };
                 *
                 * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
                 * // => [2, 0]
                 *
                 * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
                 * // => [2, 0]
                 */
                function propertyOf(object) {
                  return function (path) {
                    return object == null ? undefined : baseGet(object, path);
                  };
                }

                /**
                 * Creates an array of numbers (positive and/or negative) progressing from
                 * `start` up to, but not including, `end`. A step of `-1` is used if a negative
                 * `start` is specified without an `end` or `step`. If `end` is not specified,
                 * it's set to `start` with `start` then set to `0`.
                 *
                 * **Note:** JavaScript follows the IEEE-754 standard for resolving
                 * floating-point values which can produce unexpected results.
                 *
                 * @static
                 * @since 0.1.0
                 * @memberOf _
                 * @category Util
                 * @param {number} [start=0] The start of the range.
                 * @param {number} end The end of the range.
                 * @param {number} [step=1] The value to increment or decrement by.
                 * @returns {Array} Returns the range of numbers.
                 * @see _.inRange, _.rangeRight
                 * @example
                 *
                 * _.range(4);
                 * // => [0, 1, 2, 3]
                 *
                 * _.range(-4);
                 * // => [0, -1, -2, -3]
                 *
                 * _.range(1, 5);
                 * // => [1, 2, 3, 4]
                 *
                 * _.range(0, 20, 5);
                 * // => [0, 5, 10, 15]
                 *
                 * _.range(0, -4, -1);
                 * // => [0, -1, -2, -3]
                 *
                 * _.range(1, 4, 0);
                 * // => [1, 1, 1]
                 *
                 * _.range(0);
                 * // => []
                 */
                var range = createRange();

                /**
                 * This method is like `_.range` except that it populates values in
                 * descending order.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Util
                 * @param {number} [start=0] The start of the range.
                 * @param {number} end The end of the range.
                 * @param {number} [step=1] The value to increment or decrement by.
                 * @returns {Array} Returns the range of numbers.
                 * @see _.inRange, _.range
                 * @example
                 *
                 * _.rangeRight(4);
                 * // => [3, 2, 1, 0]
                 *
                 * _.rangeRight(-4);
                 * // => [-3, -2, -1, 0]
                 *
                 * _.rangeRight(1, 5);
                 * // => [4, 3, 2, 1]
                 *
                 * _.rangeRight(0, 20, 5);
                 * // => [15, 10, 5, 0]
                 *
                 * _.rangeRight(0, -4, -1);
                 * // => [-3, -2, -1, 0]
                 *
                 * _.rangeRight(1, 4, 0);
                 * // => [1, 1, 1]
                 *
                 * _.rangeRight(0);
                 * // => []
                 */
                var rangeRight = createRange(true);

                /**
                 * This method returns a new empty array.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.13.0
                 * @category Util
                 * @returns {Array} Returns the new empty array.
                 * @example
                 *
                 * var arrays = _.times(2, _.stubArray);
                 *
                 * console.log(arrays);
                 * // => [[], []]
                 *
                 * console.log(arrays[0] === arrays[1]);
                 * // => false
                 */
                function stubArray() {
                  return [];
                }

                /**
                 * This method returns `false`.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.13.0
                 * @category Util
                 * @returns {boolean} Returns `false`.
                 * @example
                 *
                 * _.times(2, _.stubFalse);
                 * // => [false, false]
                 */
                function stubFalse() {
                  return false;
                }

                /**
                 * This method returns a new empty object.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.13.0
                 * @category Util
                 * @returns {Object} Returns the new empty object.
                 * @example
                 *
                 * var objects = _.times(2, _.stubObject);
                 *
                 * console.log(objects);
                 * // => [{}, {}]
                 *
                 * console.log(objects[0] === objects[1]);
                 * // => false
                 */
                function stubObject() {
                  return {};
                }

                /**
                 * This method returns an empty string.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.13.0
                 * @category Util
                 * @returns {string} Returns the empty string.
                 * @example
                 *
                 * _.times(2, _.stubString);
                 * // => ['', '']
                 */
                function stubString() {
                  return "";
                }

                /**
                 * This method returns `true`.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.13.0
                 * @category Util
                 * @returns {boolean} Returns `true`.
                 * @example
                 *
                 * _.times(2, _.stubTrue);
                 * // => [true, true]
                 */
                function stubTrue() {
                  return true;
                }

                /**
                 * Invokes the iteratee `n` times, returning an array of the results of
                 * each invocation. The iteratee is invoked with one argument; (index).
                 *
                 * @static
                 * @since 0.1.0
                 * @memberOf _
                 * @category Util
                 * @param {number} n The number of times to invoke `iteratee`.
                 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                 * @returns {Array} Returns the array of results.
                 * @example
                 *
                 * _.times(3, String);
                 * // => ['0', '1', '2']
                 *
                 *  _.times(4, _.constant(0));
                 * // => [0, 0, 0, 0]
                 */
                function times(n, iteratee) {
                  n = toInteger(n);
                  if (n < 1 || n > MAX_SAFE_INTEGER) {
                    return [];
                  }
                  var index = MAX_ARRAY_LENGTH,
                    length = nativeMin(n, MAX_ARRAY_LENGTH);

                  iteratee = getIteratee(iteratee);
                  n -= MAX_ARRAY_LENGTH;

                  var result = baseTimes(length, iteratee);
                  while (++index < n) {
                    iteratee(index);
                  }
                  return result;
                }

                /**
                 * Converts `value` to a property path array.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Util
                 * @param {*} value The value to convert.
                 * @returns {Array} Returns the new property path array.
                 * @example
                 *
                 * _.toPath('a.b.c');
                 * // => ['a', 'b', 'c']
                 *
                 * _.toPath('a[0].b.c');
                 * // => ['a', '0', 'b', 'c']
                 */
                function toPath(value) {
                  if (isArray(value)) {
                    return arrayMap(value, toKey);
                  }
                  return isSymbol(value)
                    ? [value]
                    : copyArray(stringToPath(toString(value)));
                }

                /**
                 * Generates a unique ID. If `prefix` is given, the ID is appended to it.
                 *
                 * @static
                 * @since 0.1.0
                 * @memberOf _
                 * @category Util
                 * @param {string} [prefix=''] The value to prefix the ID with.
                 * @returns {string} Returns the unique ID.
                 * @example
                 *
                 * _.uniqueId('contact_');
                 * // => 'contact_104'
                 *
                 * _.uniqueId();
                 * // => '105'
                 */
                function uniqueId(prefix) {
                  var id = ++idCounter;
                  return toString(prefix) + id;
                }

                /*------------------------------------------------------------------------*/

                /**
                 * Adds two numbers.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.4.0
                 * @category Math
                 * @param {number} augend The first number in an addition.
                 * @param {number} addend The second number in an addition.
                 * @returns {number} Returns the total.
                 * @example
                 *
                 * _.add(6, 4);
                 * // => 10
                 */
                var add = createMathOperation(function (augend, addend) {
                  return augend + addend;
                }, 0);

                /**
                 * Computes `number` rounded up to `precision`.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.10.0
                 * @category Math
                 * @param {number} number The number to round up.
                 * @param {number} [precision=0] The precision to round up to.
                 * @returns {number} Returns the rounded up number.
                 * @example
                 *
                 * _.ceil(4.006);
                 * // => 5
                 *
                 * _.ceil(6.004, 2);
                 * // => 6.01
                 *
                 * _.ceil(6040, -2);
                 * // => 6100
                 */
                var ceil = createRound("ceil");

                /**
                 * Divide two numbers.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.7.0
                 * @category Math
                 * @param {number} dividend The first number in a division.
                 * @param {number} divisor The second number in a division.
                 * @returns {number} Returns the quotient.
                 * @example
                 *
                 * _.divide(6, 4);
                 * // => 1.5
                 */
                var divide = createMathOperation(function (dividend, divisor) {
                  return dividend / divisor;
                }, 1);

                /**
                 * Computes `number` rounded down to `precision`.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.10.0
                 * @category Math
                 * @param {number} number The number to round down.
                 * @param {number} [precision=0] The precision to round down to.
                 * @returns {number} Returns the rounded down number.
                 * @example
                 *
                 * _.floor(4.006);
                 * // => 4
                 *
                 * _.floor(0.046, 2);
                 * // => 0.04
                 *
                 * _.floor(4060, -2);
                 * // => 4000
                 */
                var floor = createRound("floor");

                /**
                 * Computes the maximum value of `array`. If `array` is empty or falsey,
                 * `undefined` is returned.
                 *
                 * @static
                 * @since 0.1.0
                 * @memberOf _
                 * @category Math
                 * @param {Array} array The array to iterate over.
                 * @returns {*} Returns the maximum value.
                 * @example
                 *
                 * _.max([4, 2, 8, 6]);
                 * // => 8
                 *
                 * _.max([]);
                 * // => undefined
                 */
                function max(array) {
                  return array && array.length
                    ? baseExtremum(array, identity, baseGt)
                    : undefined;
                }

                /**
                 * This method is like `_.max` except that it accepts `iteratee` which is
                 * invoked for each element in `array` to generate the criterion by which
                 * the value is ranked. The iteratee is invoked with one argument: (value).
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Math
                 * @param {Array} array The array to iterate over.
                 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
                 * @returns {*} Returns the maximum value.
                 * @example
                 *
                 * var objects = [{ 'n': 1 }, { 'n': 2 }];
                 *
                 * _.maxBy(objects, function(o) { return o.n; });
                 * // => { 'n': 2 }
                 *
                 * // The `_.property` iteratee shorthand.
                 * _.maxBy(objects, 'n');
                 * // => { 'n': 2 }
                 */
                function maxBy(array, iteratee) {
                  return array && array.length
                    ? baseExtremum(array, getIteratee(iteratee, 2), baseGt)
                    : undefined;
                }

                /**
                 * Computes the mean of the values in `array`.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Math
                 * @param {Array} array The array to iterate over.
                 * @returns {number} Returns the mean.
                 * @example
                 *
                 * _.mean([4, 2, 8, 6]);
                 * // => 5
                 */
                function mean(array) {
                  return baseMean(array, identity);
                }

                /**
                 * This method is like `_.mean` except that it accepts `iteratee` which is
                 * invoked for each element in `array` to generate the value to be averaged.
                 * The iteratee is invoked with one argument: (value).
                 *
                 * @static
                 * @memberOf _
                 * @since 4.7.0
                 * @category Math
                 * @param {Array} array The array to iterate over.
                 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
                 * @returns {number} Returns the mean.
                 * @example
                 *
                 * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
                 *
                 * _.meanBy(objects, function(o) { return o.n; });
                 * // => 5
                 *
                 * // The `_.property` iteratee shorthand.
                 * _.meanBy(objects, 'n');
                 * // => 5
                 */
                function meanBy(array, iteratee) {
                  return baseMean(array, getIteratee(iteratee, 2));
                }

                /**
                 * Computes the minimum value of `array`. If `array` is empty or falsey,
                 * `undefined` is returned.
                 *
                 * @static
                 * @since 0.1.0
                 * @memberOf _
                 * @category Math
                 * @param {Array} array The array to iterate over.
                 * @returns {*} Returns the minimum value.
                 * @example
                 *
                 * _.min([4, 2, 8, 6]);
                 * // => 2
                 *
                 * _.min([]);
                 * // => undefined
                 */
                function min(array) {
                  return array && array.length
                    ? baseExtremum(array, identity, baseLt)
                    : undefined;
                }

                /**
                 * This method is like `_.min` except that it accepts `iteratee` which is
                 * invoked for each element in `array` to generate the criterion by which
                 * the value is ranked. The iteratee is invoked with one argument: (value).
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Math
                 * @param {Array} array The array to iterate over.
                 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
                 * @returns {*} Returns the minimum value.
                 * @example
                 *
                 * var objects = [{ 'n': 1 }, { 'n': 2 }];
                 *
                 * _.minBy(objects, function(o) { return o.n; });
                 * // => { 'n': 1 }
                 *
                 * // The `_.property` iteratee shorthand.
                 * _.minBy(objects, 'n');
                 * // => { 'n': 1 }
                 */
                function minBy(array, iteratee) {
                  return array && array.length
                    ? baseExtremum(array, getIteratee(iteratee, 2), baseLt)
                    : undefined;
                }

                /**
                 * Multiply two numbers.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.7.0
                 * @category Math
                 * @param {number} multiplier The first number in a multiplication.
                 * @param {number} multiplicand The second number in a multiplication.
                 * @returns {number} Returns the product.
                 * @example
                 *
                 * _.multiply(6, 4);
                 * // => 24
                 */
                var multiply = createMathOperation(function (
                  multiplier,
                  multiplicand
                ) {
                  return multiplier * multiplicand;
                },
                1);

                /**
                 * Computes `number` rounded to `precision`.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.10.0
                 * @category Math
                 * @param {number} number The number to round.
                 * @param {number} [precision=0] The precision to round to.
                 * @returns {number} Returns the rounded number.
                 * @example
                 *
                 * _.round(4.006);
                 * // => 4
                 *
                 * _.round(4.006, 2);
                 * // => 4.01
                 *
                 * _.round(4060, -2);
                 * // => 4100
                 */
                var round = createRound("round");

                /**
                 * Subtract two numbers.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Math
                 * @param {number} minuend The first number in a subtraction.
                 * @param {number} subtrahend The second number in a subtraction.
                 * @returns {number} Returns the difference.
                 * @example
                 *
                 * _.subtract(6, 4);
                 * // => 2
                 */
                var subtract = createMathOperation(function (
                  minuend,
                  subtrahend
                ) {
                  return minuend - subtrahend;
                },
                0);

                /**
                 * Computes the sum of the values in `array`.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.4.0
                 * @category Math
                 * @param {Array} array The array to iterate over.
                 * @returns {number} Returns the sum.
                 * @example
                 *
                 * _.sum([4, 2, 8, 6]);
                 * // => 20
                 */
                function sum(array) {
                  return array && array.length ? baseSum(array, identity) : 0;
                }

                /**
                 * This method is like `_.sum` except that it accepts `iteratee` which is
                 * invoked for each element in `array` to generate the value to be summed.
                 * The iteratee is invoked with one argument: (value).
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Math
                 * @param {Array} array The array to iterate over.
                 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
                 * @returns {number} Returns the sum.
                 * @example
                 *
                 * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
                 *
                 * _.sumBy(objects, function(o) { return o.n; });
                 * // => 20
                 *
                 * // The `_.property` iteratee shorthand.
                 * _.sumBy(objects, 'n');
                 * // => 20
                 */
                function sumBy(array, iteratee) {
                  return array && array.length
                    ? baseSum(array, getIteratee(iteratee, 2))
                    : 0;
                }

                /*------------------------------------------------------------------------*/

                // Add methods that return wrapped values in chain sequences.
                lodash.after = after;
                lodash.ary = ary;
                lodash.assign = assign;
                lodash.assignIn = assignIn;
                lodash.assignInWith = assignInWith;
                lodash.assignWith = assignWith;
                lodash.at = at;
                lodash.before = before;
                lodash.bind = bind;
                lodash.bindAll = bindAll;
                lodash.bindKey = bindKey;
                lodash.castArray = castArray;
                lodash.chain = chain;
                lodash.chunk = chunk;
                lodash.compact = compact;
                lodash.concat = concat;
                lodash.cond = cond;
                lodash.conforms = conforms;
                lodash.constant = constant;
                lodash.countBy = countBy;
                lodash.create = create;
                lodash.curry = curry;
                lodash.curryRight = curryRight;
                lodash.debounce = debounce;
                lodash.defaults = defaults;
                lodash.defaultsDeep = defaultsDeep;
                lodash.defer = defer;
                lodash.delay = delay;
                lodash.difference = difference;
                lodash.differenceBy = differenceBy;
                lodash.differenceWith = differenceWith;
                lodash.drop = drop;
                lodash.dropRight = dropRight;
                lodash.dropRightWhile = dropRightWhile;
                lodash.dropWhile = dropWhile;
                lodash.fill = fill;
                lodash.filter = filter;
                lodash.flatMap = flatMap;
                lodash.flatMapDeep = flatMapDeep;
                lodash.flatMapDepth = flatMapDepth;
                lodash.flatten = flatten;
                lodash.flattenDeep = flattenDeep;
                lodash.flattenDepth = flattenDepth;
                lodash.flip = flip;
                lodash.flow = flow;
                lodash.flowRight = flowRight;
                lodash.fromPairs = fromPairs;
                lodash.functions = functions;
                lodash.functionsIn = functionsIn;
                lodash.groupBy = groupBy;
                lodash.initial = initial;
                lodash.intersection = intersection;
                lodash.intersectionBy = intersectionBy;
                lodash.intersectionWith = intersectionWith;
                lodash.invert = invert;
                lodash.invertBy = invertBy;
                lodash.invokeMap = invokeMap;
                lodash.iteratee = iteratee;
                lodash.keyBy = keyBy;
                lodash.keys = keys;
                lodash.keysIn = keysIn;
                lodash.map = map;
                lodash.mapKeys = mapKeys;
                lodash.mapValues = mapValues;
                lodash.matches = matches;
                lodash.matchesProperty = matchesProperty;
                lodash.memoize = memoize;
                lodash.merge = merge;
                lodash.mergeWith = mergeWith;
                lodash.method = method;
                lodash.methodOf = methodOf;
                lodash.mixin = mixin;
                lodash.negate = negate;
                lodash.nthArg = nthArg;
                lodash.omit = omit;
                lodash.omitBy = omitBy;
                lodash.once = once;
                lodash.orderBy = orderBy;
                lodash.over = over;
                lodash.overArgs = overArgs;
                lodash.overEvery = overEvery;
                lodash.overSome = overSome;
                lodash.partial = partial;
                lodash.partialRight = partialRight;
                lodash.partition = partition;
                lodash.pick = pick;
                lodash.pickBy = pickBy;
                lodash.property = property;
                lodash.propertyOf = propertyOf;
                lodash.pull = pull;
                lodash.pullAll = pullAll;
                lodash.pullAllBy = pullAllBy;
                lodash.pullAllWith = pullAllWith;
                lodash.pullAt = pullAt;
                lodash.range = range;
                lodash.rangeRight = rangeRight;
                lodash.rearg = rearg;
                lodash.reject = reject;
                lodash.remove = remove;
                lodash.rest = rest;
                lodash.reverse = reverse;
                lodash.sampleSize = sampleSize;
                lodash.set = set;
                lodash.setWith = setWith;
                lodash.shuffle = shuffle;
                lodash.slice = slice;
                lodash.sortBy = sortBy;
                lodash.sortedUniq = sortedUniq;
                lodash.sortedUniqBy = sortedUniqBy;
                lodash.split = split;
                lodash.spread = spread;
                lodash.tail = tail;
                lodash.take = take;
                lodash.takeRight = takeRight;
                lodash.takeRightWhile = takeRightWhile;
                lodash.takeWhile = takeWhile;
                lodash.tap = tap;
                lodash.throttle = throttle;
                lodash.thru = thru;
                lodash.toArray = toArray;
                lodash.toPairs = toPairs;
                lodash.toPairsIn = toPairsIn;
                lodash.toPath = toPath;
                lodash.toPlainObject = toPlainObject;
                lodash.transform = transform;
                lodash.unary = unary;
                lodash.union = union;
                lodash.unionBy = unionBy;
                lodash.unionWith = unionWith;
                lodash.uniq = uniq;
                lodash.uniqBy = uniqBy;
                lodash.uniqWith = uniqWith;
                lodash.unset = unset;
                lodash.unzip = unzip;
                lodash.unzipWith = unzipWith;
                lodash.update = update;
                lodash.updateWith = updateWith;
                lodash.values = values;
                lodash.valuesIn = valuesIn;
                lodash.without = without;
                lodash.words = words;
                lodash.wrap = wrap;
                lodash.xor = xor;
                lodash.xorBy = xorBy;
                lodash.xorWith = xorWith;
                lodash.zip = zip;
                lodash.zipObject = zipObject;
                lodash.zipObjectDeep = zipObjectDeep;
                lodash.zipWith = zipWith;

                // Add aliases.
                lodash.entries = toPairs;
                lodash.entriesIn = toPairsIn;
                lodash.extend = assignIn;
                lodash.extendWith = assignInWith;

                // Add methods to `lodash.prototype`.
                mixin(lodash, lodash);

                /*------------------------------------------------------------------------*/

                // Add methods that return unwrapped values in chain sequences.
                lodash.add = add;
                lodash.attempt = attempt;
                lodash.camelCase = camelCase;
                lodash.capitalize = capitalize;
                lodash.ceil = ceil;
                lodash.clamp = clamp;
                lodash.clone = clone;
                lodash.cloneDeep = cloneDeep;
                lodash.cloneDeepWith = cloneDeepWith;
                lodash.cloneWith = cloneWith;
                lodash.conformsTo = conformsTo;
                lodash.deburr = deburr;
                lodash.defaultTo = defaultTo;
                lodash.divide = divide;
                lodash.endsWith = endsWith;
                lodash.eq = eq;
                lodash.escape = escape;
                lodash.escapeRegExp = escapeRegExp;
                lodash.every = every;
                lodash.find = find;
                lodash.findIndex = findIndex;
                lodash.findKey = findKey;
                lodash.findLast = findLast;
                lodash.findLastIndex = findLastIndex;
                lodash.findLastKey = findLastKey;
                lodash.floor = floor;
                lodash.forEach = forEach;
                lodash.forEachRight = forEachRight;
                lodash.forIn = forIn;
                lodash.forInRight = forInRight;
                lodash.forOwn = forOwn;
                lodash.forOwnRight = forOwnRight;
                lodash.get = get;
                lodash.gt = gt;
                lodash.gte = gte;
                lodash.has = has;
                lodash.hasIn = hasIn;
                lodash.head = head;
                lodash.identity = identity;
                lodash.includes = includes;
                lodash.indexOf = indexOf;
                lodash.inRange = inRange;
                lodash.invoke = invoke;
                lodash.isArguments = isArguments;
                lodash.isArray = isArray;
                lodash.isArrayBuffer = isArrayBuffer;
                lodash.isArrayLike = isArrayLike;
                lodash.isArrayLikeObject = isArrayLikeObject;
                lodash.isBoolean = isBoolean;
                lodash.isBuffer = isBuffer;
                lodash.isDate = isDate;
                lodash.isElement = isElement;
                lodash.isEmpty = isEmpty;
                lodash.isEqual = isEqual;
                lodash.isEqualWith = isEqualWith;
                lodash.isError = isError;
                lodash.isFinite = isFinite;
                lodash.isFunction = isFunction;
                lodash.isInteger = isInteger;
                lodash.isLength = isLength;
                lodash.isMap = isMap;
                lodash.isMatch = isMatch;
                lodash.isMatchWith = isMatchWith;
                lodash.isNaN = isNaN;
                lodash.isNative = isNative;
                lodash.isNil = isNil;
                lodash.isNull = isNull;
                lodash.isNumber = isNumber;
                lodash.isObject = isObject;
                lodash.isObjectLike = isObjectLike;
                lodash.isPlainObject = isPlainObject;
                lodash.isRegExp = isRegExp;
                lodash.isSafeInteger = isSafeInteger;
                lodash.isSet = isSet;
                lodash.isString = isString;
                lodash.isSymbol = isSymbol;
                lodash.isTypedArray = isTypedArray;
                lodash.isUndefined = isUndefined;
                lodash.isWeakMap = isWeakMap;
                lodash.isWeakSet = isWeakSet;
                lodash.join = join;
                lodash.kebabCase = kebabCase;
                lodash.last = last;
                lodash.lastIndexOf = lastIndexOf;
                lodash.lowerCase = lowerCase;
                lodash.lowerFirst = lowerFirst;
                lodash.lt = lt;
                lodash.lte = lte;
                lodash.max = max;
                lodash.maxBy = maxBy;
                lodash.mean = mean;
                lodash.meanBy = meanBy;
                lodash.min = min;
                lodash.minBy = minBy;
                lodash.stubArray = stubArray;
                lodash.stubFalse = stubFalse;
                lodash.stubObject = stubObject;
                lodash.stubString = stubString;
                lodash.stubTrue = stubTrue;
                lodash.multiply = multiply;
                lodash.nth = nth;
                lodash.noConflict = noConflict;
                lodash.noop = noop;
                lodash.now = now;
                lodash.pad = pad;
                lodash.padEnd = padEnd;
                lodash.padStart = padStart;
                lodash.parseInt = parseInt;
                lodash.random = random;
                lodash.reduce = reduce;
                lodash.reduceRight = reduceRight;
                lodash.repeat = repeat;
                lodash.replace = replace;
                lodash.result = result;
                lodash.round = round;
                lodash.runInContext = runInContext;
                lodash.sample = sample;
                lodash.size = size;
                lodash.snakeCase = snakeCase;
                lodash.some = some;
                lodash.sortedIndex = sortedIndex;
                lodash.sortedIndexBy = sortedIndexBy;
                lodash.sortedIndexOf = sortedIndexOf;
                lodash.sortedLastIndex = sortedLastIndex;
                lodash.sortedLastIndexBy = sortedLastIndexBy;
                lodash.sortedLastIndexOf = sortedLastIndexOf;
                lodash.startCase = startCase;
                lodash.startsWith = startsWith;
                lodash.subtract = subtract;
                lodash.sum = sum;
                lodash.sumBy = sumBy;
                lodash.template = template;
                lodash.times = times;
                lodash.toFinite = toFinite;
                lodash.toInteger = toInteger;
                lodash.toLength = toLength;
                lodash.toLower = toLower;
                lodash.toNumber = toNumber;
                lodash.toSafeInteger = toSafeInteger;
                lodash.toString = toString;
                lodash.toUpper = toUpper;
                lodash.trim = trim;
                lodash.trimEnd = trimEnd;
                lodash.trimStart = trimStart;
                lodash.truncate = truncate;
                lodash.unescape = unescape;
                lodash.uniqueId = uniqueId;
                lodash.upperCase = upperCase;
                lodash.upperFirst = upperFirst;

                // Add aliases.
                lodash.each = forEach;
                lodash.eachRight = forEachRight;
                lodash.first = head;

                mixin(
                  lodash,
                  (function () {
                    var source = {};
                    baseForOwn(lodash, function (func, methodName) {
                      if (!hasOwnProperty.call(lodash.prototype, methodName)) {
                        source[methodName] = func;
                      }
                    });
                    return source;
                  })(),
                  { chain: false }
                );

                /*------------------------------------------------------------------------*/

                /**
                 * The semantic version number.
                 *
                 * @static
                 * @memberOf _
                 * @type {string}
                 */
                lodash.VERSION = VERSION;

                // Assign default placeholders.
                arrayEach(
                  [
                    "bind",
                    "bindKey",
                    "curry",
                    "curryRight",
                    "partial",
                    "partialRight",
                  ],
                  function (methodName) {
                    lodash[methodName].placeholder = lodash;
                  }
                );

                // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
                arrayEach(["drop", "take"], function (methodName, index) {
                  LazyWrapper.prototype[methodName] = function (n) {
                    n = n === undefined ? 1 : nativeMax(toInteger(n), 0);

                    var result =
                      this.__filtered__ && !index
                        ? new LazyWrapper(this)
                        : this.clone();

                    if (result.__filtered__) {
                      result.__takeCount__ = nativeMin(n, result.__takeCount__);
                    } else {
                      result.__views__.push({
                        size: nativeMin(n, MAX_ARRAY_LENGTH),
                        type: methodName + (result.__dir__ < 0 ? "Right" : ""),
                      });
                    }
                    return result;
                  };

                  LazyWrapper.prototype[methodName + "Right"] = function (n) {
                    return this.reverse()[methodName](n).reverse();
                  };
                });

                // Add `LazyWrapper` methods that accept an `iteratee` value.
                arrayEach(["filter", "map", "takeWhile"], function (
                  methodName,
                  index
                ) {
                  var type = index + 1,
                    isFilter =
                      type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;

                  LazyWrapper.prototype[methodName] = function (iteratee) {
                    var result = this.clone();
                    result.__iteratees__.push({
                      iteratee: getIteratee(iteratee, 3),
                      type: type,
                    });
                    result.__filtered__ = result.__filtered__ || isFilter;
                    return result;
                  };
                });

                // Add `LazyWrapper` methods for `_.head` and `_.last`.
                arrayEach(["head", "last"], function (methodName, index) {
                  var takeName = "take" + (index ? "Right" : "");

                  LazyWrapper.prototype[methodName] = function () {
                    return this[takeName](1).value()[0];
                  };
                });

                // Add `LazyWrapper` methods for `_.initial` and `_.tail`.
                arrayEach(["initial", "tail"], function (methodName, index) {
                  var dropName = "drop" + (index ? "" : "Right");

                  LazyWrapper.prototype[methodName] = function () {
                    return this.__filtered__
                      ? new LazyWrapper(this)
                      : this[dropName](1);
                  };
                });

                LazyWrapper.prototype.compact = function () {
                  return this.filter(identity);
                };

                LazyWrapper.prototype.find = function (predicate) {
                  return this.filter(predicate).head();
                };

                LazyWrapper.prototype.findLast = function (predicate) {
                  return this.reverse().find(predicate);
                };

                LazyWrapper.prototype.invokeMap = baseRest(function (
                  path,
                  args
                ) {
                  if (typeof path == "function") {
                    return new LazyWrapper(this);
                  }
                  return this.map(function (value) {
                    return baseInvoke(value, path, args);
                  });
                });

                LazyWrapper.prototype.reject = function (predicate) {
                  return this.filter(negate(getIteratee(predicate)));
                };

                LazyWrapper.prototype.slice = function (start, end) {
                  start = toInteger(start);

                  var result = this;
                  if (result.__filtered__ && (start > 0 || end < 0)) {
                    return new LazyWrapper(result);
                  }
                  if (start < 0) {
                    result = result.takeRight(-start);
                  } else if (start) {
                    result = result.drop(start);
                  }
                  if (end !== undefined) {
                    end = toInteger(end);
                    result =
                      end < 0
                        ? result.dropRight(-end)
                        : result.take(end - start);
                  }
                  return result;
                };

                LazyWrapper.prototype.takeRightWhile = function (predicate) {
                  return this.reverse().takeWhile(predicate).reverse();
                };

                LazyWrapper.prototype.toArray = function () {
                  return this.take(MAX_ARRAY_LENGTH);
                };

                // Add `LazyWrapper` methods to `lodash.prototype`.
                baseForOwn(LazyWrapper.prototype, function (func, methodName) {
                  var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(
                      methodName
                    ),
                    isTaker = /^(?:head|last)$/.test(methodName),
                    lodashFunc =
                      lodash[
                        isTaker
                          ? "take" + (methodName == "last" ? "Right" : "")
                          : methodName
                      ],
                    retUnwrapped = isTaker || /^find/.test(methodName);

                  if (!lodashFunc) {
                    return;
                  }
                  lodash.prototype[methodName] = function () {
                    var value = this.__wrapped__,
                      args = isTaker ? [1] : arguments,
                      isLazy = value instanceof LazyWrapper,
                      iteratee = args[0],
                      useLazy = isLazy || isArray(value);

                    var interceptor = function (value) {
                      var result = lodashFunc.apply(
                        lodash,
                        arrayPush([value], args)
                      );
                      return isTaker && chainAll ? result[0] : result;
                    };

                    if (
                      useLazy &&
                      checkIteratee &&
                      typeof iteratee == "function" &&
                      iteratee.length != 1
                    ) {
                      // Avoid lazy use if the iteratee has a "length" value other than `1`.
                      isLazy = useLazy = false;
                    }
                    var chainAll = this.__chain__,
                      isHybrid = !!this.__actions__.length,
                      isUnwrapped = retUnwrapped && !chainAll,
                      onlyLazy = isLazy && !isHybrid;

                    if (!retUnwrapped && useLazy) {
                      value = onlyLazy ? value : new LazyWrapper(this);
                      var result = func.apply(value, args);
                      result.__actions__.push({
                        func: thru,
                        args: [interceptor],
                        thisArg: undefined,
                      });
                      return new LodashWrapper(result, chainAll);
                    }
                    if (isUnwrapped && onlyLazy) {
                      return func.apply(this, args);
                    }
                    result = this.thru(interceptor);
                    return isUnwrapped
                      ? isTaker
                        ? result.value()[0]
                        : result.value()
                      : result;
                  };
                });

                // Add `Array` methods to `lodash.prototype`.
                arrayEach(
                  ["pop", "push", "shift", "sort", "splice", "unshift"],
                  function (methodName) {
                    var func = arrayProto[methodName],
                      chainName = /^(?:push|sort|unshift)$/.test(methodName)
                        ? "tap"
                        : "thru",
                      retUnwrapped = /^(?:pop|shift)$/.test(methodName);

                    lodash.prototype[methodName] = function () {
                      var args = arguments;
                      if (retUnwrapped && !this.__chain__) {
                        var value = this.value();
                        return func.apply(isArray(value) ? value : [], args);
                      }
                      return this[chainName](function (value) {
                        return func.apply(isArray(value) ? value : [], args);
                      });
                    };
                  }
                );

                // Map minified method names to their real names.
                baseForOwn(LazyWrapper.prototype, function (func, methodName) {
                  var lodashFunc = lodash[methodName];
                  if (lodashFunc) {
                    var key = lodashFunc.name + "";
                    if (!hasOwnProperty.call(realNames, key)) {
                      realNames[key] = [];
                    }
                    realNames[key].push({ name: methodName, func: lodashFunc });
                  }
                });

                realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [
                  {
                    name: "wrapper",
                    func: undefined,
                  },
                ];

                // Add methods to `LazyWrapper`.
                LazyWrapper.prototype.clone = lazyClone;
                LazyWrapper.prototype.reverse = lazyReverse;
                LazyWrapper.prototype.value = lazyValue;

                // Add chain sequence methods to the `lodash` wrapper.
                lodash.prototype.at = wrapperAt;
                lodash.prototype.chain = wrapperChain;
                lodash.prototype.commit = wrapperCommit;
                lodash.prototype.next = wrapperNext;
                lodash.prototype.plant = wrapperPlant;
                lodash.prototype.reverse = wrapperReverse;
                lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

                // Add lazy aliases.
                lodash.prototype.first = lodash.prototype.head;

                if (symIterator) {
                  lodash.prototype[symIterator] = wrapperToIterator;
                }
                return lodash;
              };

              /*--------------------------------------------------------------------------*/

              // Export lodash.
              var _ = runInContext();

              // Some AMD build optimizers, like r.js, check for condition patterns like:
              if (
                typeof define == "function" &&
                typeof define.amd == "object" &&
                define.amd
              ) {
                // Expose Lodash on the global object to prevent errors when Lodash is
                // loaded by a script tag in the presence of an AMD loader.
                // See http://requirejs.org/docs/errors.html#mismatch for more details.
                // Use `_.noConflict` to remove Lodash from the global object.
                root._ = _;

                // Define as an anonymous module so, through path mapping, it can be
                // referenced as the "underscore" module.
                define(function () {
                  return _;
                });
              }
              // Check for `exports` after `define` in case a build optimizer adds it.
              else if (freeModule) {
                // Export for Node.js.
                (freeModule.exports = _)._ = _;
                // Export for CommonJS support.
                freeExports._ = _;
              } else {
                // Export to the global object.
                root._ = _;
              }
            }.call(this));
          }.call(this));
        }.call(
          this,
          typeof global !== "undefined"
            ? global
            : typeof self !== "undefined"
            ? self
            : typeof window !== "undefined"
            ? window
            : {}
        ));
      },
      {},
    ],
  },
  {},
  [1]
);
